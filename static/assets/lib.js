! function (t, e) {
	"object" == typeof module && "object" == typeof module.exports ? module.exports = t.document ? e(t, !0) : function (t) {
		if (!t.document) throw new Error("jQuery requires a window with a document");
		return e(t)
	} : e(t)
}("undefined" != typeof window ? window : this, function (k, R) {
	function F(t) {
		var e = !!t && "length" in t && t.length,
			i = C.type(t);
		return "function" === i || C.isWindow(t) ? !1 : "array" === i || 0 === e || "number" == typeof e && e > 0 && e - 1 in t
	}

	function H(t, i, n) {
		if (C.isFunction(i)) return C.grep(t, function (t, e) {
			return !!i.call(t, e, t) !== n
		});
		if (i.nodeType) return C.grep(t, function (t) {
			return t === i !== n
		});
		if ("string" == typeof i) {
			if (zt.test(i)) return C.filter(i, t, n);
			i = C.filter(i, t)
		}
		return C.grep(t, function (t) {
			return C.inArray(t, i) > -1 !== n
		})
	}

	function z(t, e) {
		do {
			t = t[e]
		} while (t && 1 !== t.nodeType);
		return t
	}

	function W(t) {
		var i = {};
		return C.each(t.match(D) || [], function (t, e) {
			i[e] = !0
		}), i
	}

	function B() {
		p.addEventListener ? (p.removeEventListener("DOMContentLoaded", e), k.removeEventListener("load", e)) : (p.detachEvent("onreadystatechange", e), k.detachEvent("onload", e))
	}

	function e() {
		(p.addEventListener || "load" === k.event.type || "complete" === p.readyState) && (B(), C.ready())
	}

	function j(t, e, i) {
		if (void 0 === i && 1 === t.nodeType) {
			var n = "data-" + e.replace(qt, "-$1").toLowerCase();
			if (i = t.getAttribute(n), "string" == typeof i) {
				try {
					i = "true" === i ? !0 : "false" === i ? !1 : "null" === i ? null : +i + "" === i ? +i : Ut.test(i) ? C.parseJSON(i) : i
				} catch (t) { }
				C.data(t, e, i)
			} else i = void 0
		}
		return i
	}

	function Y(t) {
		var e;
		for (e in t)
			if (("data" !== e || !C.isEmptyObject(t[e])) && "toJSON" !== e) return !1;
		return !0
	}

	function V(t, e, i, n) {
		if (y(t)) {
			var s, o, r = C.expando,
				a = t.nodeType,
				l = a ? C.cache : t,
				h = a ? t[r] : t[r] && r;
			if (h && l[h] && (n || l[h].data) || void 0 !== i || "string" != typeof e) return h || (h = a ? t[r] = d.pop() || C.guid++ : r), l[h] || (l[h] = a ? {} : {
				toJSON: C.noop
			}), "object" != typeof e && "function" != typeof e || (n ? l[h] = C.extend(l[h], e) : l[h].data = C.extend(l[h].data, e)), o = l[h], n || (o.data || (o.data = {}), o = o.data), void 0 !== i && (o[C.camelCase(e)] = i), "string" == typeof e ? (s = o[e], null == s && (s = o[C.camelCase(e)])) : s = o, s
		}
	}

	function $(t, e, i) {
		if (y(t)) {
			var n, s, o = t.nodeType,
				r = o ? C.cache : t,
				a = o ? t[C.expando] : C.expando;
			if (r[a]) {
				if (e && (n = i ? r[a] : r[a].data)) {
					C.isArray(e) ? e = e.concat(C.map(e, C.camelCase)) : e in n ? e = [e] : (e = C.camelCase(e), e = e in n ? [e] : e.split(" ")), s = e.length;
					for (; s--;) delete n[e[s]];
					if (i ? !Y(n) : !C.isEmptyObject(n)) return
				} (i || (delete r[a].data, Y(r[a]))) && (o ? C.cleanData([t], !0) : _.deleteExpando || r != r.window ? delete r[a] : r[a] = void 0)
			}
		}
	}

	function U(t, e, i, n) {
		var s, o = 1,
			r = 20,
			a = n ? function () {
				return n.cur()
			} : function () {
				return C.css(t, e, "")
			},
			l = a(),
			h = i && i[3] || (C.cssNumber[e] ? "" : "px"),
			c = (C.cssNumber[e] || "px" !== h && +l) && Kt.exec(C.css(t, e));
		if (c && c[3] !== h) {
			h = h || c[3], i = i || [], c = +l || 1;
			do {
				o = o || ".5", c /= o, C.style(t, e, c + h)
			} while (o !== (o = a() / l) && 1 !== o && --r)
		}
		return i && (c = +c || +l || 0, s = i[1] ? c + (i[1] + 1) * i[2] : +i[2], n && (n.unit = h, n.start = c, n.end = s)), s
	}

	function q(t) {
		var e = te.split("|"),
			i = t.createDocumentFragment();
		if (i.createElement)
			for (; e.length;) i.createElement(e.pop());
		return i
	}

	function m(t, e) {
		var i, n, s = 0,
			o = "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e || "*") : "undefined" != typeof t.querySelectorAll ? t.querySelectorAll(e || "*") : void 0;
		if (!o)
			for (o = [], i = t.childNodes || t; null != (n = i[s]); s++) !e || C.nodeName(n, e) ? o.push(n) : C.merge(o, m(n, e));
		return void 0 === e || e && C.nodeName(t, e) ? C.merge([t], o) : o
	}

	function G(t, e) {
		for (var i, n = 0; null != (i = t[n]); n++) C._data(i, "globalEval", !e || C._data(e[n], "globalEval"))
	}

	function K(t) {
		Xt.test(t.type) && (t.defaultChecked = t.checked)
	}

	function X(t, e, i, n, s) {
		for (var o, r, a, l, h, c, u, d = t.length, f = q(e), p = [], g = 0; d > g; g++)
			if (r = t[g], r || 0 === r)
				if ("object" === C.type(r)) C.merge(p, r.nodeType ? [r] : r);
				else if (ee.test(r)) {
					for (l = l || f.appendChild(e.createElement("div")), h = (Zt.exec(r) || ["", ""])[1].toLowerCase(), u = M[h] || M._default, l.innerHTML = u[1] + C.htmlPrefilter(r) + u[2], o = u[0]; o--;) l = l.lastChild;
					if (!_.leadingWhitespace && Jt.test(r) && p.push(e.createTextNode(Jt.exec(r)[0])), !_.tbody)
						for (r = "table" !== h || ie.test(r) ? "<table>" !== u[1] || ie.test(r) ? 0 : l : l.firstChild, o = r && r.childNodes.length; o--;) C.nodeName(c = r.childNodes[o], "tbody") && !c.childNodes.length && r.removeChild(c);
					for (C.merge(p, l.childNodes), l.textContent = ""; l.firstChild;) l.removeChild(l.firstChild);
					l = f.lastChild
				} else p.push(e.createTextNode(r));
		for (l && f.removeChild(l), _.appendChecked || C.grep(m(p, "input"), K), g = 0; r = p[g++];)
			if (n && C.inArray(r, n) > -1) s && s.push(r);
			else if (a = C.contains(r.ownerDocument, r), l = m(f.appendChild(r), "script"), a && G(l), i)
				for (o = 0; r = l[o++];) Qt.test(r.type || "") && i.push(r);
		return l = null, f
	}

	function i() {
		return !0
	}

	function l() {
		return !1
	}

	function Z() {
		try {
			return p.activeElement
		} catch (t) { }
	}

	function Q(t, e, i, n, s, o) {
		var r, a;
		if ("object" == typeof e) {
			"string" != typeof i && (n = n || i, i = void 0);
			for (a in e) Q(t, a, i, n, e[a], o);
			return t
		}
		if (null == n && null == s ? (s = i, n = i = void 0) : null == s && ("string" == typeof i ? (s = n, n = void 0) : (s = n, n = i, i = void 0)), s === !1) s = l;
		else if (!s) return t;
		return 1 === o && (r = s, s = function (t) {
			return C().off(t), r.apply(this, arguments)
		}, s.guid = r.guid || (r.guid = C.guid++)), t.each(function () {
			C.event.add(this, e, s, n, i)
		})
	}

	function J(t, e) {
		return C.nodeName(t, "table") && C.nodeName(11 !== e.nodeType ? e : e.firstChild, "tr") ? t.getElementsByTagName("tbody")[0] || t.appendChild(t.ownerDocument.createElement("tbody")) : t
	}

	function tt(t) {
		return t.type = (null !== C.find.attr(t, "type")) + "/" + t.type, t
	}

	function et(t) {
		var e = fe.exec(t.type);
		return e ? t.type = e[1] : t.removeAttribute("type"), t
	}

	function it(t, e) {
		if (1 === e.nodeType && C.hasData(t)) {
			var i, n, s, o = C._data(t),
				r = C._data(e, o),
				a = o.events;
			if (a) {
				delete r.handle, r.events = {};
				for (i in a)
					for (n = 0, s = a[i].length; s > n; n++) C.event.add(e, i, a[i][n])
			}
			r.data && (r.data = C.extend({}, r.data))
		}
	}

	function nt(t, e) {
		var i, n, s;
		if (1 === e.nodeType) {
			if (i = e.nodeName.toLowerCase(), !_.noCloneEvent && e[C.expando]) {
				s = C._data(e);
				for (n in s.events) C.removeEvent(e, n, s.handle);
				e.removeAttribute(C.expando)
			}
			"script" === i && e.text !== t.text ? (tt(e).text = t.text, et(e)) : "object" === i ? (e.parentNode && (e.outerHTML = t.outerHTML), _.html5Clone && t.innerHTML && !C.trim(e.innerHTML) && (e.innerHTML = t.innerHTML)) : "input" === i && Xt.test(t.type) ? (e.defaultChecked = e.checked = t.checked, e.value !== t.value && (e.value = t.value)) : "option" === i ? e.defaultSelected = e.selected = t.defaultSelected : "input" !== i && "textarea" !== i || (e.defaultValue = t.defaultValue)
		}
	}

	function g(i, n, s, o) {
		n = Tt.apply([], n);
		var t, e, r, a, l, h, c = 0,
			u = i.length,
			d = u - 1,
			f = n[0],
			p = C.isFunction(f);
		if (p || u > 1 && "string" == typeof f && !_.checkClone && de.test(f)) return i.each(function (t) {
			var e = i.eq(t);
			p && (n[0] = f.call(this, t, e.html())), g(e, n, s, o)
		});
		if (u && (h = X(n, i[0].ownerDocument, !1, i, o), t = h.firstChild, 1 === h.childNodes.length && (h = t), t || o)) {
			for (a = C.map(m(h, "script"), tt), r = a.length; u > c; c++) e = h, c !== d && (e = C.clone(e, !0, !0), r && C.merge(a, m(e, "script"))), s.call(i[c], e, c);
			if (r)
				for (l = a[a.length - 1].ownerDocument, C.map(a, et), c = 0; r > c; c++) e = a[c], Qt.test(e.type || "") && !C._data(e, "globalEval") && C.contains(l, e) && (e.src ? C._evalUrl && C._evalUrl(e.src) : C.globalEval((e.text || e.textContent || e.innerHTML || "").replace(pe, "")));
			h = t = null
		}
		return i
	}

	function st(t, e, i) {
		for (var n, s = e ? C.filter(e, t) : t, o = 0; null != (n = s[o]); o++) i || 1 !== n.nodeType || C.cleanData(m(n)), n.parentNode && (i && C.contains(n.ownerDocument, n) && G(m(n, "script")), n.parentNode.removeChild(n));
		return t
	}

	function ot(t, e) {
		var i = C(e.createElement(t)).appendTo(e.body),
			n = C.css(i[0], "display");
		return i.detach(), n
	}

	function v(t) {
		var e = p,
			i = ve[t];
		return i || (i = ot(t, e), "none" !== i && i || (T = (T || C("<iframe frameborder='0' width='0' height='0'/>")).appendTo(e.documentElement), e = (T[0].contentWindow || T[0].contentDocument).document, e.write(), e.close(), i = ot(t, e), T.detach()), ve[t] = i), i
	}

	function rt(t, e) {
		return {
			get: function () {
				return t() ? void delete this.get : (this.get = e).apply(this, arguments)
			}
		}
	}

	function at(t) {
		if (t in Ie) return t;
		for (var e = t.charAt(0).toUpperCase() + t.slice(1), i = Pe.length; i--;)
			if (t = Pe[i] + e, t in Ie) return t
	}

	function lt(t, e) {
		for (var i, n, s, o = [], r = 0, a = t.length; a > r; r++) n = t[r], n.style && (o[r] = C._data(n, "olddisplay"), i = n.style.display, e ? (o[r] || "none" !== i || (n.style.display = ""), "" === n.style.display && x(n) && (o[r] = C._data(n, "olddisplay", v(n.nodeName)))) : (s = x(n), (i && "none" !== i || !s) && C._data(n, "olddisplay", s ? i : C.css(n, "display"))));
		for (r = 0; a > r; r++) n = t[r], n.style && (e && "none" !== n.style.display && "" !== n.style.display || (n.style.display = e ? o[r] || "" : "none"));
		return t
	}

	function ht(t, e, i) {
		var n = Me.exec(e);
		return n ? Math.max(0, n[1] - (i || 0)) + (n[2] || "px") : e
	}

	function ct(t, e, i, n, s) {
		for (var o = i === (n ? "border" : "content") ? 4 : "width" === e ? 1 : 0, r = 0; 4 > o; o += 2) "margin" === i && (r += C.css(t, i + f[o], !0, s)), n ? ("content" === i && (r -= C.css(t, "padding" + f[o], !0, s)), "margin" !== i && (r -= C.css(t, "border" + f[o] + "Width", !0, s))) : (r += C.css(t, "padding" + f[o], !0, s), "padding" !== i && (r += C.css(t, "border" + f[o] + "Width", !0, s)));
		return r
	}

	function ut(t, e, i) {
		var n = !0,
			s = "width" === e ? t.offsetWidth : t.offsetHeight,
			o = S(t),
			r = _.boxSizing && "border-box" === C.css(t, "boxSizing", !1, o);
		if (0 >= s || null == s) {
			if (s = P(t, e, o), (0 > s || null == s) && (s = t.style[e]), _e.test(s)) return s;
			n = r && (_.boxSizingReliable() || s === t.style[e]), s = parseFloat(s) || 0
		}
		return s + ct(t, e, i || (r ? "border" : "content"), n, o) + "px"
	}

	function o(t, e, i, n, s) {
		return new o.prototype.init(t, e, i, n, s)
	}

	function dt() {
		return k.setTimeout(function () {
			I = void 0
		}), I = C.now()
	}

	function r(t, e) {
		var i, n = {
			height: t
		},
			s = 0;
		for (e = e ? 1 : 0; 4 > s; s += 2 - e) i = f[s], n["margin" + i] = n["padding" + i] = t;
		return e && (n.opacity = n.width = t), n
	}

	function ft(t, e, i) {
		for (var n, s = (u.tweeners[e] || []).concat(u.tweeners["*"]), o = 0, r = s.length; r > o; o++)
			if (n = s[o].call(i, e, t)) return n
	}

	function pt(e, t, i) {
		var n, s, o, r, a, l, h, c, u = this,
			d = {},
			f = e.style,
			p = e.nodeType && x(e),
			g = C._data(e, "fxshow");
		i.queue || (a = C._queueHooks(e, "fx"), null == a.unqueued && (a.unqueued = 0, l = a.empty.fire, a.empty.fire = function () {
			a.unqueued || l()
		}), a.unqueued++, u.always(function () {
			u.always(function () {
				a.unqueued--, C.queue(e, "fx").length || a.empty.fire()
			})
		})), 1 === e.nodeType && ("height" in t || "width" in t) && (i.overflow = [f.overflow, f.overflowX, f.overflowY], h = C.css(e, "display"), c = "none" === h ? C._data(e, "olddisplay") || v(e.nodeName) : h, "inline" === c && "none" === C.css(e, "float") && (_.inlineBlockNeedsLayout && "inline" !== v(e.nodeName) ? f.zoom = 1 : f.display = "inline-block")), i.overflow && (f.overflow = "hidden", _.shrinkWrapBlocks() || u.always(function () {
			f.overflow = i.overflow[0], f.overflowX = i.overflow[1], f.overflowY = i.overflow[2]
		}));
		for (n in t)
			if (s = t[n], Oe.exec(s)) {
				if (delete t[n], o = o || "toggle" === s, s === (p ? "hide" : "show")) {
					if ("show" !== s || !g || void 0 === g[n]) continue;
					p = !0
				}
				d[n] = g && g[n] || C.style(e, n)
			} else h = void 0;
		if (C.isEmptyObject(d)) "inline" === ("none" === h ? v(e.nodeName) : h) && (f.display = h);
		else {
			g ? "hidden" in g && (p = g.hidden) : g = C._data(e, "fxshow", {}), o && (g.hidden = !p), p ? C(e).show() : u.done(function () {
				C(e).hide()
			}), u.done(function () {
				var t;
				C._removeData(e, "fxshow");
				for (t in d) C.style(e, t, d[t])
			});
			for (n in d) r = ft(p ? g[n] : 0, n, u), n in g || (g[n] = r.start, p && (r.end = r.start, r.start = "width" === n || "height" === n ? 1 : 0))
		}
	}

	function gt(t, e) {
		var i, n, s, o, r;
		for (i in t)
			if (n = C.camelCase(i), s = e[n], o = t[i], C.isArray(o) && (s = o[1], o = t[i] = o[0]), i !== n && (t[n] = o, delete t[i]), r = C.cssHooks[n], r && "expand" in r) {
				o = r.expand(o), delete t[n];
				for (i in o) i in t || (t[i] = o[i], e[i] = s)
			} else e[n] = s
	}

	function u(r, t, e) {
		var i, a, n = 0,
			s = u.prefilters.length,
			l = C.Deferred().always(function () {
				delete o.elem
			}),
			o = function () {
				if (a) return !1;
				for (var t = I || dt(), e = Math.max(0, h.startTime + h.duration - t), i = e / h.duration || 0, n = 1 - i, s = 0, o = h.tweens.length; o > s; s++) h.tweens[s].run(n);
				return l.notifyWith(r, [h, n, e]), 1 > n && o ? e : (l.resolveWith(r, [h]), !1)
			},
			h = l.promise({
				elem: r,
				props: C.extend({}, t),
				opts: C.extend(!0, {
					specialEasing: {},
					easing: C.easing._default
				}, e),
				originalProperties: t,
				originalOptions: e,
				startTime: I || dt(),
				duration: e.duration,
				tweens: [],
				createTween: function (t, e) {
					var i = C.Tween(r, h.opts, t, e, h.opts.specialEasing[t] || h.opts.easing);
					return h.tweens.push(i), i
				},
				stop: function (t) {
					var e = 0,
						i = t ? h.tweens.length : 0;
					if (a) return this;
					for (a = !0; i > e; e++) h.tweens[e].run(1);
					return t ? (l.notifyWith(r, [h, 1, 0]), l.resolveWith(r, [h, t])) : l.rejectWith(r, [h, t]), this
				}
			}),
			c = h.props;
		for (gt(c, h.opts.specialEasing); s > n; n++)
			if (i = u.prefilters[n].call(h, r, c, h.opts)) return C.isFunction(i.stop) && (C._queueHooks(h.elem, h.opts.queue).stop = C.proxy(i.stop, i)), i;
		return C.map(c, ft, h), C.isFunction(h.opts.start) && h.opts.start.call(r, h), C.fx.timer(C.extend(o, {
			elem: r,
			anim: h,
			queue: h.opts.queue
		})), h.progress(h.opts.progress).done(h.opts.done, h.opts.complete).fail(h.opts.fail).always(h.opts.always)
	}

	function h(t) {
		return C.attr(t, "class") || ""
	}

	function mt(o) {
		return function (t, e) {
			"string" != typeof t && (e = t, t = "*");
			var i, n = 0,
				s = t.toLowerCase().match(D) || [];
			if (C.isFunction(e))
				for (; i = s[n++];) "+" === i.charAt(0) ? (i = i.slice(1) || "*", (o[i] = o[i] || []).unshift(e)) : (o[i] = o[i] || []).push(e)
		}
	}

	function vt(e, s, o, r) {
		function a(t) {
			var n;
			return l[t] = !0, C.each(e[t] || [], function (t, e) {
				var i = e(s, o, r);
				return "string" != typeof i || h || l[i] ? h ? !(n = i) : void 0 : (s.dataTypes.unshift(i), a(i), !1)
			}), n
		}
		var l = {},
			h = e === ti;
		return a(s.dataTypes[0]) || !l["*"] && a("*")
	}

	function bt(t, e) {
		var i, n, s = C.ajaxSettings.flatOptions || {};
		for (n in e) void 0 !== e[n] && ((s[n] ? t : i || (i = {}))[n] = e[n]);
		return i && C.extend(!0, t, i), t
	}

	function _t(t, e, i) {
		for (var n, s, o, r, a = t.contents, l = t.dataTypes;
			"*" === l[0];) l.shift(), void 0 === s && (s = t.mimeType || e.getResponseHeader("Content-Type"));
		if (s)
			for (r in a)
				if (a[r] && a[r].test(s)) {
					l.unshift(r);
					break
				}
		if (l[0] in i) o = l[0];
		else {
			for (r in i) {
				if (!l[0] || t.converters[r + " " + l[0]]) {
					o = r;
					break
				}
				n || (n = r)
			}
			o = o || n
		}
		return o ? (o !== l[0] && l.unshift(o), i[o]) : void 0
	}

	function yt(t, e, i, n) {
		var s, o, r, a, l, h = {},
			c = t.dataTypes.slice();
		if (c[1])
			for (r in t.converters) h[r.toLowerCase()] = t.converters[r];
		for (o = c.shift(); o;)
			if (t.responseFields[o] && (i[t.responseFields[o]] = e), !l && n && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = o, o = c.shift())
				if ("*" === o) o = l;
				else if ("*" !== l && l !== o) {
					if (r = h[l + " " + o] || h["* " + o], !r)
						for (s in h)
							if (a = s.split(" "), a[1] === o && (r = h[l + " " + a[0]] || h["* " + a[0]])) {
								r === !0 ? r = h[s] : h[s] !== !0 && (o = a[0], c.unshift(a[1]));
								break
							}
					if (r !== !0)
						if (r && t["throws"]) e = r(e);
						else try {
							e = r(e)
						} catch (t) {
							return {
								state: "parsererror",
								error: r ? t : "No conversion from " + l + " to " + o
							}
						}
				}
		return {
			state: "success",
			data: e
		}
	}

	function xt(t) {
		return t.style && t.style.display || C.css(t, "display")
	}

	function wt(t) {
		if (!C.contains(t.ownerDocument || p, t)) return !0;
		for (; t && 1 === t.nodeType;) {
			if ("none" === xt(t) || "hidden" === t.type) return !0;
			t = t.parentNode
		}
		return !1
	}

	function kt(i, t, n, s) {
		var e;
		if (C.isArray(t)) C.each(t, function (t, e) {
			n || si.test(i) ? s(i, e) : kt(i + "[" + ("object" == typeof e && null != e ? t : "") + "]", e, n, s)
		});
		else if (n || "object" !== C.type(t)) s(i, t);
		else
			for (e in t) kt(i + "[" + e + "]", t[e], n, s)
	}

	function Ct() {
		try {
			return new k.XMLHttpRequest
		} catch (t) { }
	}

	function Dt() {
		try {
			return new k.ActiveXObject("Microsoft.XMLHTTP")
		} catch (t) { }
	}

	function Mt(t) {
		return C.isWindow(t) ? t : 9 === t.nodeType ? t.defaultView || t.parentWindow : !1
	}
	var d = [],
		p = k.document,
		c = d.slice,
		Tt = d.concat,
		St = d.push,
		Pt = d.indexOf,
		n = {},
		It = n.toString,
		b = n.hasOwnProperty,
		_ = {},
		Et = "1.12.4",
		C = function (t, e) {
			return new C.fn.init(t, e)
		},
		Ot = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
		At = /^-ms-/,
		Lt = /-([\da-z])/gi,
		Nt = function (t, e) {
			return e.toUpperCase()
		};
	C.fn = C.prototype = {
		jquery: Et,
		constructor: C,
		selector: "",
		length: 0,
		toArray: function () {
			return c.call(this)
		},
		get: function (t) {
			return null != t ? 0 > t ? this[t + this.length] : this[t] : c.call(this)
		},
		pushStack: function (t) {
			var e = C.merge(this.constructor(), t);
			return e.prevObject = this, e.context = this.context, e
		},
		each: function (t) {
			return C.each(this, t)
		},
		map: function (i) {
			return this.pushStack(C.map(this, function (t, e) {
				return i.call(t, e, t)
			}))
		},
		slice: function () {
			return this.pushStack(c.apply(this, arguments))
		},
		first: function () {
			return this.eq(0)
		},
		last: function () {
			return this.eq(-1)
		},
		eq: function (t) {
			var e = this.length,
				i = +t + (0 > t ? e : 0);
			return this.pushStack(i >= 0 && e > i ? [this[i]] : [])
		},
		end: function () {
			return this.prevObject || this.constructor()
		},
		push: St,
		sort: d.sort,
		splice: d.splice
	}, C.extend = C.fn.extend = function () {
		var t, e, i, n, s, o, r = arguments[0] || {},
			a = 1,
			l = arguments.length,
			h = !1;
		for ("boolean" == typeof r && (h = r, r = arguments[a] || {}, a++), "object" == typeof r || C.isFunction(r) || (r = {}), a === l && (r = this, a--); l > a; a++)
			if (null != (s = arguments[a]))
				for (n in s) t = r[n], i = s[n], r !== i && (h && i && (C.isPlainObject(i) || (e = C.isArray(i))) ? (e ? (e = !1, o = t && C.isArray(t) ? t : []) : o = t && C.isPlainObject(t) ? t : {}, r[n] = C.extend(h, o, i)) : void 0 !== i && (r[n] = i));
		return r
	}, C.extend({
		expando: "jQuery" + (Et + Math.random()).replace(/\D/g, ""),
		isReady: !0,
		error: function (t) {
			throw new Error(t)
		},
		noop: function () { },
		isFunction: function (t) {
			return "function" === C.type(t)
		},
		isArray: Array.isArray || function (t) {
			return "array" === C.type(t)
		},
		isWindow: function (t) {
			return null != t && t == t.window
		},
		isNumeric: function (t) {
			var e = t && t.toString();
			return !C.isArray(t) && e - parseFloat(e) + 1 >= 0
		},
		isEmptyObject: function (t) {
			var e;
			for (e in t) return !1;
			return !0
		},
		isPlainObject: function (t) {
			var e;
			if (!t || "object" !== C.type(t) || t.nodeType || C.isWindow(t)) return !1;
			try {
				if (t.constructor && !b.call(t, "constructor") && !b.call(t.constructor.prototype, "isPrototypeOf")) return !1
			} catch (t) {
				return !1
			}
			if (!_.ownFirst)
				for (e in t) return b.call(t, e);
			for (e in t);
			return void 0 === e || b.call(t, e)
		},
		type: function (t) {
			return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? n[It.call(t)] || "object" : typeof t
		},
		globalEval: function (t) {
			t && C.trim(t) && (k.execScript || function (t) {
				k.eval.call(k, t)
			})(t)
		},
		camelCase: function (t) {
			return t.replace(At, "ms-").replace(Lt, Nt)
		},
		nodeName: function (t, e) {
			return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
		},
		each: function (t, e) {
			var i, n = 0;
			if (F(t))
				for (i = t.length; i > n && e.call(t[n], n, t[n]) !== !1; n++);
			else
				for (n in t)
					if (e.call(t[n], n, t[n]) === !1) break; return t
		},
		trim: function (t) {
			return null == t ? "" : (t + "").replace(Ot, "")
		},
		makeArray: function (t, e) {
			var i = e || [];
			return null != t && (F(Object(t)) ? C.merge(i, "string" == typeof t ? [t] : t) : St.call(i, t)), i
		},
		inArray: function (t, e, i) {
			var n;
			if (e) {
				if (Pt) return Pt.call(e, t, i);
				for (n = e.length, i = i ? 0 > i ? Math.max(0, n + i) : i : 0; n > i; i++)
					if (i in e && e[i] === t) return i
			}
			return -1
		},
		merge: function (t, e) {
			for (var i = +e.length, n = 0, s = t.length; i > n;) t[s++] = e[n++];
			if (i !== i)
				for (; void 0 !== e[n];) t[s++] = e[n++];
			return t.length = s, t
		},
		grep: function (t, e, i) {
			for (var n, s = [], o = 0, r = t.length, a = !i; r > o; o++) n = !e(t[o], o), n !== a && s.push(t[o]);
			return s
		},
		map: function (t, e, i) {
			var n, s, o = 0,
				r = [];
			if (F(t))
				for (n = t.length; n > o; o++) s = e(t[o], o, i), null != s && r.push(s);
			else
				for (o in t) s = e(t[o], o, i), null != s && r.push(s);
			return Tt.apply([], r)
		},
		guid: 1,
		proxy: function (t, e) {
			var i, n, s;
			return "string" == typeof e && (s = t[e], e = t, t = s), C.isFunction(t) ? (i = c.call(arguments, 2), n = function () {
				return t.apply(e || this, i.concat(c.call(arguments)))
			}, n.guid = t.guid = t.guid || C.guid++, n) : void 0
		},
		now: function () {
			return +new Date
		},
		support: _
	}), "function" == typeof Symbol && (C.fn[Symbol.iterator] = d[Symbol.iterator]), C.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (t, e) {
		n["[object " + e + "]"] = e.toLowerCase()
	});
	var t = function (R) {
		function y(t, e, i, n) {
			var s, o, r, a, l, h, c, u, d = e && e.ownerDocument,
				f = e ? e.nodeType : 9;
			if (i = i || [], "string" != typeof t || !t || 1 !== f && 9 !== f && 11 !== f) return i;
			if (!n && ((e ? e.ownerDocument || e : _) !== D && C(e), e = e || D, M)) {
				if (11 !== f && (h = _t.exec(t)))
					if (s = h[1]) {
						if (9 === f) {
							if (!(r = e.getElementById(s))) return i;
							if (r.id === s) return i.push(r), i
						} else if (d && (r = d.getElementById(s)) && b(e, r) && r.id === s) return i.push(r), i
					} else {
						if (h[2]) return I.apply(i, e.getElementsByTagName(t)), i;
						if ((s = h[3]) && g.getElementsByClassName && e.getElementsByClassName) return I.apply(i, e.getElementsByClassName(s)), i
					}
				if (g.qsa && !P[t + " "] && (!v || !v.test(t))) {
					if (1 !== f) d = e, u = t;
					else if ("object" !== e.nodeName.toLowerCase()) {
						for ((a = e.getAttribute("id")) ? a = a.replace(xt, "\\$&") : e.setAttribute("id", a = T), c = m(t), o = c.length, l = mt.test(a) ? "#" + a : "[id='" + a + "']"; o--;) c[o] = l + " " + p(c[o]);
						u = c.join(","), d = yt.test(t) && j(e.parentNode) || e
					}
					if (u) try {
						return I.apply(i, d.querySelectorAll(u)), i
					} catch (t) { } finally {
							a === T && e.removeAttribute("id")
						}
				}
			}
			return Q(t.replace(O, "$1"), e, i, n)
		}

		function F() {
			function i(t, e) {
				return n.push(t + " ") > w.cacheLength && delete i[n.shift()], i[t + " "] = e
			}
			var n = [];
			return i
		}

		function i(t) {
			return t[T] = !0, t
		}

		function s(t) {
			var e = D.createElement("div");
			try {
				return !!t(e)
			} catch (t) {
				return !1
			} finally {
				e.parentNode && e.parentNode.removeChild(e), e = null
			}
		}

		function H(t, e) {
			for (var i = t.split("|"), n = i.length; n--;) w.attrHandle[i[n]] = e
		}

		function z(t, e) {
			var i = e && t,
				n = i && 1 === t.nodeType && 1 === e.nodeType && (~e.sourceIndex || nt) - (~t.sourceIndex || nt);
			if (n) return n;
			if (i)
				for (; i = i.nextSibling;)
					if (i === e) return -1;
			return t ? 1 : -1
		}

		function W(i) {
			return function (t) {
				var e = t.nodeName.toLowerCase();
				return "input" === e && t.type === i
			}
		}

		function B(i) {
			return function (t) {
				var e = t.nodeName.toLowerCase();
				return ("input" === e || "button" === e) && t.type === i
			}
		}

		function t(r) {
			return i(function (o) {
				return o = +o, i(function (t, e) {
					for (var i, n = r([], t.length, o), s = n.length; s--;) t[i = n[s]] && (t[i] = !(e[i] = t[i]))
				})
			})
		}

		function j(t) {
			return t && "undefined" != typeof t.getElementsByTagName && t
		}

		function Y() { }

		function p(t) {
			for (var e = 0, i = t.length, n = ""; i > e; e++) n += t[e].value;
			return n
		}

		function V(a, t, e) {
			var l = t.dir,
				h = e && "parentNode" === l,
				c = J++;
			return t.first ? function (t, e, i) {
				for (; t = t[l];)
					if (1 === t.nodeType || h) return a(t, e, i)
			} : function (t, e, i) {
				var n, s, o, r = [S, c];
				if (i) {
					for (; t = t[l];)
						if ((1 === t.nodeType || h) && a(t, e, i)) return !0
				} else
					for (; t = t[l];)
						if (1 === t.nodeType || h) {
							if (o = t[T] || (t[T] = {}), s = o[t.uniqueID] || (o[t.uniqueID] = {}), (n = s[l]) && n[0] === S && n[1] === c) return r[2] = n[2];
							if (s[l] = r, r[2] = a(t, e, i)) return !0
						}
			}
		}

		function $(s) {
			return s.length > 1 ? function (t, e, i) {
				for (var n = s.length; n--;)
					if (!s[n](t, e, i)) return !1;
				return !0
			} : s[0]
		}

		function U(t, e, i) {
			for (var n = 0, s = e.length; s > n; n++) y(t, e[n], i);
			return i
		}

		function x(t, e, i, n, s) {
			for (var o, r = [], a = 0, l = t.length, h = null != e; l > a; a++)(o = t[a]) && (i && !i(o, n, s) || (r.push(o), h && e.push(a)));
			return r
		}

		function q(f, p, g, m, v, t) {
			return m && !m[T] && (m = q(m)), v && !v[T] && (v = q(v, t)), i(function (t, e, i, n) {
				var s, o, r, a = [],
					l = [],
					h = e.length,
					c = t || U(p || "*", i.nodeType ? [i] : i, []),
					u = !f || !t && p ? c : x(c, a, f, i, n),
					d = g ? v || (t ? f : h || m) ? [] : e : u;
				if (g && g(u, d, i, n), m)
					for (s = x(d, l), m(s, [], i, n), o = s.length; o--;)(r = s[o]) && (d[l[o]] = !(u[l[o]] = r));
				if (t) {
					if (v || f) {
						if (v) {
							for (s = [], o = d.length; o--;)(r = d[o]) && s.push(u[o] = r);
							v(null, d = [], s, n)
						}
						for (o = d.length; o--;)(r = d[o]) && (s = v ? E(t, r) : a[o]) > -1 && (t[s] = !(e[s] = r))
					}
				} else d = x(d === e ? d.splice(h, d.length) : d), v ? v(null, e, d, n) : I.apply(e, d)
			})
		}

		function G(t) {
			for (var s, e, i, n = t.length, o = w.relative[t[0].type], r = o || w.relative[" "], a = o ? 1 : 0, l = V(function (t) {
				return t === s
			}, r, !0), h = V(function (t) {
				return E(s, t) > -1
			}, r, !0), c = [function (t, e, i) {
				var n = !o && (i || e !== k) || ((s = e).nodeType ? l(t, e, i) : h(t, e, i));
				return s = null, n
			}]; n > a; a++)
				if (e = w.relative[t[a].type]) c = [V($(c), e)];
				else {
					if (e = w.filter[t[a].type].apply(null, t[a].matches), e[T]) {
						for (i = ++a; n > i && !w.relative[t[i].type]; i++);
						return q(a > 1 && $(c), a > 1 && p(t.slice(0, a - 1).concat({
							value: " " === t[a - 2].type ? "*" : ""
						})).replace(O, "$1"), e, i > a && G(t.slice(a, i)), n > i && G(t = t.slice(i)), n > i && p(t))
					}
					c.push(e)
				}
			return $(c)
		}

		function K(m, v) {
			var b = v.length > 0,
				_ = m.length > 0,
				t = function (t, e, i, n, s) {
					var o, r, a, l = 0,
						h = "0",
						c = t && [],
						u = [],
						d = k,
						f = t || _ && w.find.TAG("*", s),
						p = S += null == d ? 1 : Math.random() || .1,
						g = f.length;
					for (s && (k = e === D || e || s); h !== g && null != (o = f[h]); h++) {
						if (_ && o) {
							for (r = 0, e || o.ownerDocument === D || (C(o), i = !M); a = m[r++];)
								if (a(o, e || D, i)) {
									n.push(o);
									break
								}
							s && (S = p)
						}
						b && ((o = !a && o) && l--, t && c.push(o))
					}
					if (l += h, b && h !== l) {
						for (r = 0; a = v[r++];) a(c, u, e, i);
						if (t) {
							if (l > 0)
								for (; h--;) c[h] || u[h] || (u[h] = ot.call(n));
							u = x(u)
						}
						I.apply(n, u), s && !t && u.length > 0 && l + v.length > 1 && y.uniqueSort(n)
					}
					return s && (S = p, k = d), c
				};
			return b ? i(t) : t
		}
		var e, g, w, o, X, m, Z, Q, k, l, h, C, D, r, M, v, a, c, b, T = "sizzle" + 1 * new Date,
			_ = R.document,
			S = 0,
			J = 0,
			tt = F(),
			et = F(),
			P = F(),
			it = function (t, e) {
				return t === e && (h = !0), 0
			},
			nt = 1 << 31,
			st = {}.hasOwnProperty,
			n = [],
			ot = n.pop,
			rt = n.push,
			I = n.push,
			at = n.slice,
			E = function (t, e) {
				for (var i = 0, n = t.length; n > i; i++)
					if (t[i] === e) return i;
				return -1
			},
			lt = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
			u = "[\\x20\\t\\r\\n\\f]",
			d = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
			ht = "\\[" + u + "*(" + d + ")(?:" + u + "*([*^$|!~]?=)" + u + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + d + "))|)" + u + "*\\]",
			ct = ":(" + d + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ht + ")*)|.*)\\)|)",
			ut = new RegExp(u + "+", "g"),
			O = new RegExp("^" + u + "+|((?:^|[^\\\\])(?:\\\\.)*)" + u + "+$", "g"),
			dt = new RegExp("^" + u + "*," + u + "*"),
			ft = new RegExp("^" + u + "*([>+~]|" + u + ")" + u + "*"),
			pt = new RegExp("=" + u + "*([^\\]'\"]*?)" + u + "*\\]", "g"),
			gt = new RegExp(ct),
			mt = new RegExp("^" + d + "$"),
			f = {
				ID: new RegExp("^#(" + d + ")"),
				CLASS: new RegExp("^\\.(" + d + ")"),
				TAG: new RegExp("^(" + d + "|[*])"),
				ATTR: new RegExp("^" + ht),
				PSEUDO: new RegExp("^" + ct),
				CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + u + "*(even|odd|(([+-]|)(\\d*)n|)" + u + "*(?:([+-]|)" + u + "*(\\d+)|))" + u + "*\\)|)", "i"),
				bool: new RegExp("^(?:" + lt + ")$", "i"),
				needsContext: new RegExp("^" + u + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + u + "*((?:-\\d)?\\d*)" + u + "*\\)|)(?=[^-]|$)", "i")
			},
			vt = /^(?:input|select|textarea|button)$/i,
			bt = /^h\d$/i,
			A = /^[^{]+\{\s*\[native \w/,
			_t = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
			yt = /[+~]/,
			xt = /'|\\/g,
			L = new RegExp("\\\\([\\da-f]{1,6}" + u + "?|(" + u + ")|.)", "ig"),
			N = function (t, e, i) {
				var n = "0x" + e - 65536;
				return n !== n || i ? e : 0 > n ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)
			},
			wt = function () {
				C()
			};
		try {
			I.apply(n = at.call(_.childNodes), _.childNodes), n[_.childNodes.length].nodeType
		} catch (t) {
			I = {
				apply: n.length ? function (t, e) {
					rt.apply(t, at.call(e))
				} : function (t, e) {
					for (var i = t.length, n = 0; t[i++] = e[n++];);
					t.length = i - 1
				}
			}
		}
		g = y.support = {}, X = y.isXML = function (t) {
			var e = t && (t.ownerDocument || t).documentElement;
			return e ? "HTML" !== e.nodeName : !1
		}, C = y.setDocument = function (t) {
			var e, i, n = t ? t.ownerDocument || t : _;
			return n !== D && 9 === n.nodeType && n.documentElement ? (D = n, r = D.documentElement, M = !X(D), (i = D.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", wt, !1) : i.attachEvent && i.attachEvent("onunload", wt)), g.attributes = s(function (t) {
				return t.className = "i", !t.getAttribute("className")
			}), g.getElementsByTagName = s(function (t) {
				return t.appendChild(D.createComment("")), !t.getElementsByTagName("*").length
			}), g.getElementsByClassName = A.test(D.getElementsByClassName), g.getById = s(function (t) {
				return r.appendChild(t).id = T, !D.getElementsByName || !D.getElementsByName(T).length
			}), g.getById ? (w.find.ID = function (t, e) {
				if ("undefined" != typeof e.getElementById && M) {
					var i = e.getElementById(t);
					return i ? [i] : []
				}
			}, w.filter.ID = function (t) {
				var e = t.replace(L, N);
				return function (t) {
					return t.getAttribute("id") === e
				}
			}) : (delete w.find.ID, w.filter.ID = function (t) {
				var i = t.replace(L, N);
				return function (t) {
					var e = "undefined" != typeof t.getAttributeNode && t.getAttributeNode("id");
					return e && e.value === i
				}
			}), w.find.TAG = g.getElementsByTagName ? function (t, e) {
				return "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t) : g.qsa ? e.querySelectorAll(t) : void 0
			} : function (t, e) {
				var i, n = [],
					s = 0,
					o = e.getElementsByTagName(t);
				if ("*" === t) {
					for (; i = o[s++];) 1 === i.nodeType && n.push(i);
					return n
				}
				return o
			}, w.find.CLASS = g.getElementsByClassName && function (t, e) {
				return "undefined" != typeof e.getElementsByClassName && M ? e.getElementsByClassName(t) : void 0
			}, a = [], v = [], (g.qsa = A.test(D.querySelectorAll)) && (s(function (t) {
				r.appendChild(t).innerHTML = "<a id='" + T + "'></a><select id='" + T + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + u + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || v.push("\\[" + u + "*(?:value|" + lt + ")"), t.querySelectorAll("[id~=" + T + "-]").length || v.push("~="), t.querySelectorAll(":checked").length || v.push(":checked"), t.querySelectorAll("a#" + T + "+*").length || v.push(".#.+[+~]")
			}), s(function (t) {
				var e = D.createElement("input");
				e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && v.push("name" + u + "*[*^$|!~]?="), t.querySelectorAll(":enabled").length || v.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), v.push(",.*:")
			})), (g.matchesSelector = A.test(c = r.matches || r.webkitMatchesSelector || r.mozMatchesSelector || r.oMatchesSelector || r.msMatchesSelector)) && s(function (t) {
				g.disconnectedMatch = c.call(t, "div"), c.call(t, "[s!='']:x"), a.push("!=", ct)
			}), v = v.length && new RegExp(v.join("|")), a = a.length && new RegExp(a.join("|")), e = A.test(r.compareDocumentPosition), b = e || A.test(r.contains) ? function (t, e) {
				var i = 9 === t.nodeType ? t.documentElement : t,
					n = e && e.parentNode;
				return t === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(n)))
			} : function (t, e) {
				if (e)
					for (; e = e.parentNode;)
						if (e === t) return !0;
				return !1
			}, it = e ? function (t, e) {
				if (t === e) return h = !0, 0;
				var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
				return i ? i : (i = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1, 1 & i || !g.sortDetached && e.compareDocumentPosition(t) === i ? t === D || t.ownerDocument === _ && b(_, t) ? -1 : e === D || e.ownerDocument === _ && b(_, e) ? 1 : l ? E(l, t) - E(l, e) : 0 : 4 & i ? -1 : 1)
			} : function (t, e) {
				if (t === e) return h = !0, 0;
				var i, n = 0,
					s = t.parentNode,
					o = e.parentNode,
					r = [t],
					a = [e];
				if (!s || !o) return t === D ? -1 : e === D ? 1 : s ? -1 : o ? 1 : l ? E(l, t) - E(l, e) : 0;
				if (s === o) return z(t, e);
				for (i = t; i = i.parentNode;) r.unshift(i);
				for (i = e; i = i.parentNode;) a.unshift(i);
				for (; r[n] === a[n];) n++;
				return n ? z(r[n], a[n]) : r[n] === _ ? -1 : a[n] === _ ? 1 : 0
			}, D) : D
		}, y.matches = function (t, e) {
			return y(t, null, null, e)
		}, y.matchesSelector = function (t, e) {
			if ((t.ownerDocument || t) !== D && C(t), e = e.replace(pt, "='$1']"), g.matchesSelector && M && !P[e + " "] && (!a || !a.test(e)) && (!v || !v.test(e))) try {
				var i = c.call(t, e);
				if (i || g.disconnectedMatch || t.document && 11 !== t.document.nodeType) return i
			} catch (t) { }
			return y(e, D, null, [t]).length > 0
		}, y.contains = function (t, e) {
			return (t.ownerDocument || t) !== D && C(t), b(t, e)
		}, y.attr = function (t, e) {
			(t.ownerDocument || t) !== D && C(t);
			var i = w.attrHandle[e.toLowerCase()],
				n = i && st.call(w.attrHandle, e.toLowerCase()) ? i(t, e, !M) : void 0;
			return void 0 !== n ? n : g.attributes || !M ? t.getAttribute(e) : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
		}, y.error = function (t) {
			throw new Error("Syntax error, unrecognized expression: " + t)
		}, y.uniqueSort = function (t) {
			var e, i = [],
				n = 0,
				s = 0;
			if (h = !g.detectDuplicates, l = !g.sortStable && t.slice(0), t.sort(it), h) {
				for (; e = t[s++];) e === t[s] && (n = i.push(s));
				for (; n--;) t.splice(i[n], 1)
			}
			return l = null, t
		}, o = y.getText = function (t) {
			var e, i = "",
				n = 0,
				s = t.nodeType;
			if (s) {
				if (1 === s || 9 === s || 11 === s) {
					if ("string" == typeof t.textContent) return t.textContent;
					for (t = t.firstChild; t; t = t.nextSibling) i += o(t)
				} else if (3 === s || 4 === s) return t.nodeValue
			} else
				for (; e = t[n++];) i += o(e);
			return i
		}, w = y.selectors = {
			cacheLength: 50,
			createPseudo: i,
			match: f,
			attrHandle: {},
			find: {},
			relative: {
				">": {
					dir: "parentNode",
					first: !0
				},
				" ": {
					dir: "parentNode"
				},
				"+": {
					dir: "previousSibling",
					first: !0
				},
				"~": {
					dir: "previousSibling"
				}
			},
			preFilter: {
				ATTR: function (t) {
					return t[1] = t[1].replace(L, N), t[3] = (t[3] || t[4] || t[5] || "").replace(L, N), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
				},
				CHILD: function (t) {
					return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || y.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && y.error(t[0]), t
				},
				PSEUDO: function (t) {
					var e, i = !t[6] && t[2];
					return f.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : i && gt.test(i) && (e = m(i, !0)) && (e = i.indexOf(")", i.length - e) - i.length) && (t[0] = t[0].slice(0, e), t[2] = i.slice(0, e)), t.slice(0, 3))
				}
			},
			filter: {
				TAG: function (t) {
					var e = t.replace(L, N).toLowerCase();
					return "*" === t ? function () {
						return !0
					} : function (t) {
						return t.nodeName && t.nodeName.toLowerCase() === e
					}
				},
				CLASS: function (t) {
					var e = tt[t + " "];
					return e || (e = new RegExp("(^|" + u + ")" + t + "(" + u + "|$)")) && tt(t, function (t) {
						return e.test("string" == typeof t.className && t.className || "undefined" != typeof t.getAttribute && t.getAttribute("class") || "")
					})
				},
				ATTR: function (i, n, s) {
					return function (t) {
						var e = y.attr(t, i);
						return null == e ? "!=" === n : n ? (e += "", "=" === n ? e === s : "!=" === n ? e !== s : "^=" === n ? s && 0 === e.indexOf(s) : "*=" === n ? s && e.indexOf(s) > -1 : "$=" === n ? s && e.slice(-s.length) === s : "~=" === n ? (" " + e.replace(ut, " ") + " ").indexOf(s) > -1 : "|=" === n ? e === s || e.slice(0, s.length + 1) === s + "-" : !1) : !0
					}
				},
				CHILD: function (p, t, e, g, m) {
					var v = "nth" !== p.slice(0, 3),
						b = "last" !== p.slice(-4),
						_ = "of-type" === t;
					return 1 === g && 0 === m ? function (t) {
						return !!t.parentNode
					} : function (t, e, i) {
						var n, s, o, r, a, l, h = v !== b ? "nextSibling" : "previousSibling",
							c = t.parentNode,
							u = _ && t.nodeName.toLowerCase(),
							d = !i && !_,
							f = !1;
						if (c) {
							if (v) {
								for (; h;) {
									for (r = t; r = r[h];)
										if (_ ? r.nodeName.toLowerCase() === u : 1 === r.nodeType) return !1;
									l = h = "only" === p && !l && "nextSibling"
								}
								return !0
							}
							if (l = [b ? c.firstChild : c.lastChild], b && d) {
								for (r = c, o = r[T] || (r[T] = {}), s = o[r.uniqueID] || (o[r.uniqueID] = {}), n = s[p] || [], a = n[0] === S && n[1], f = a && n[2], r = a && c.childNodes[a]; r = ++a && r && r[h] || (f = a = 0) || l.pop();)
									if (1 === r.nodeType && ++f && r === t) {
										s[p] = [S, a, f];
										break
									}
							} else if (d && (r = t, o = r[T] || (r[T] = {}), s = o[r.uniqueID] || (o[r.uniqueID] = {}), n = s[p] || [], a = n[0] === S && n[1], f = a), f === !1)
								for (;
									(r = ++a && r && r[h] || (f = a = 0) || l.pop()) && ((_ ? r.nodeName.toLowerCase() !== u : 1 !== r.nodeType) || !++f || (d && (o = r[T] || (r[T] = {}), s = o[r.uniqueID] || (o[r.uniqueID] = {}), s[p] = [S, f]), r !== t)););
							return f -= m, f === g || f % g === 0 && f / g >= 0
						}
					}
				},
				PSEUDO: function (t, o) {
					var e, r = w.pseudos[t] || w.setFilters[t.toLowerCase()] || y.error("unsupported pseudo: " + t);
					return r[T] ? r(o) : r.length > 1 ? (e = [t, t, "", o], w.setFilters.hasOwnProperty(t.toLowerCase()) ? i(function (t, e) {
						for (var i, n = r(t, o), s = n.length; s--;) i = E(t, n[s]), t[i] = !(e[i] = n[s])
					}) : function (t) {
						return r(t, 0, e)
					}) : r
				}
			},
			pseudos: {
				not: i(function (t) {
					var n = [],
						s = [],
						a = Z(t.replace(O, "$1"));
					return a[T] ? i(function (t, e, i, n) {
						for (var s, o = a(t, null, n, []), r = t.length; r--;)(s = o[r]) && (t[r] = !(e[r] = s))
					}) : function (t, e, i) {
						return n[0] = t, a(n, null, i, s), n[0] = null, !s.pop()
					}
				}),
				has: i(function (e) {
					return function (t) {
						return y(e, t).length > 0
					}
				}),
				contains: i(function (e) {
					return e = e.replace(L, N),
						function (t) {
							return (t.textContent || t.innerText || o(t)).indexOf(e) > -1
						}
				}),
				lang: i(function (i) {
					return mt.test(i || "") || y.error("unsupported lang: " + i), i = i.replace(L, N).toLowerCase(),
						function (t) {
							var e;
							do {
								if (e = M ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return e = e.toLowerCase(), e === i || 0 === e.indexOf(i + "-")
							} while ((t = t.parentNode) && 1 === t.nodeType);
							return !1
						}
				}),
				target: function (t) {
					var e = R.location && R.location.hash;
					return e && e.slice(1) === t.id
				},
				root: function (t) {
					return t === r
				},
				focus: function (t) {
					return t === D.activeElement && (!D.hasFocus || D.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
				},
				enabled: function (t) {
					return t.disabled === !1
				},
				disabled: function (t) {
					return t.disabled === !0
				},
				checked: function (t) {
					var e = t.nodeName.toLowerCase();
					return "input" === e && !!t.checked || "option" === e && !!t.selected
				},
				selected: function (t) {
					return t.parentNode && t.parentNode.selectedIndex, t.selected === !0
				},
				empty: function (t) {
					for (t = t.firstChild; t; t = t.nextSibling)
						if (t.nodeType < 6) return !1;
					return !0
				},
				parent: function (t) {
					return !w.pseudos.empty(t)
				},
				header: function (t) {
					return bt.test(t.nodeName)
				},
				input: function (t) {
					return vt.test(t.nodeName)
				},
				button: function (t) {
					var e = t.nodeName.toLowerCase();
					return "input" === e && "button" === t.type || "button" === e
				},
				text: function (t) {
					var e;
					return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
				},
				first: t(function () {
					return [0]
				}),
				last: t(function (t, e) {
					return [e - 1]
				}),
				eq: t(function (t, e, i) {
					return [0 > i ? i + e : i]
				}),
				even: t(function (t, e) {
					for (var i = 0; e > i; i += 2) t.push(i);
					return t
				}),
				odd: t(function (t, e) {
					for (var i = 1; e > i; i += 2) t.push(i);
					return t
				}),
				lt: t(function (t, e, i) {
					for (var n = 0 > i ? i + e : i; --n >= 0;) t.push(n);
					return t
				}),
				gt: t(function (t, e, i) {
					for (var n = 0 > i ? i + e : i; ++n < e;) t.push(n);
					return t
				})
			}
		}, w.pseudos.nth = w.pseudos.eq;
		for (e in {
			radio: !0,
			checkbox: !0,
			file: !0,
			password: !0,
			image: !0
		}) w.pseudos[e] = W(e);
		for (e in {
			submit: !0,
			reset: !0
		}) w.pseudos[e] = B(e);
		return Y.prototype = w.filters = w.pseudos, w.setFilters = new Y, m = y.tokenize = function (t, e) {
			var i, n, s, o, r, a, l, h = et[t + " "];
			if (h) return e ? 0 : h.slice(0);
			for (r = t, a = [], l = w.preFilter; r;) {
				i && !(n = dt.exec(r)) || (n && (r = r.slice(n[0].length) || r), a.push(s = [])), i = !1, (n = ft.exec(r)) && (i = n.shift(), s.push({
					value: i,
					type: n[0].replace(O, " ")
				}), r = r.slice(i.length));
				for (o in w.filter) !(n = f[o].exec(r)) || l[o] && !(n = l[o](n)) || (i = n.shift(), s.push({
					value: i,
					type: o,
					matches: n
				}), r = r.slice(i.length));
				if (!i) break
			}
			return e ? r.length : r ? y.error(t) : et(t, a).slice(0)
		}, Z = y.compile = function (t, e) {
			var i, n = [],
				s = [],
				o = P[t + " "];
			if (!o) {
				for (e || (e = m(t)), i = e.length; i--;) o = G(e[i]), o[T] ? n.push(o) : s.push(o);
				o = P(t, K(s, n)), o.selector = t
			}
			return o
		}, Q = y.select = function (t, e, i, n) {
			var s, o, r, a, l, h = "function" == typeof t && t,
				c = !n && m(t = h.selector || t);
			if (i = i || [], 1 === c.length) {
				if (o = c[0] = c[0].slice(0), o.length > 2 && "ID" === (r = o[0]).type && g.getById && 9 === e.nodeType && M && w.relative[o[1].type]) {
					if (e = (w.find.ID(r.matches[0].replace(L, N), e) || [])[0], !e) return i;
					h && (e = e.parentNode), t = t.slice(o.shift().value.length)
				}
				for (s = f.needsContext.test(t) ? 0 : o.length; s-- && (r = o[s], !w.relative[a = r.type]);)
					if ((l = w.find[a]) && (n = l(r.matches[0].replace(L, N), yt.test(o[0].type) && j(e.parentNode) || e))) {
						if (o.splice(s, 1), t = n.length && p(o), !t) return I.apply(i, n), i;
						break
					}
			}
			return (h || Z(t, c))(n, e, !M, i, !e || yt.test(t) && j(e.parentNode) || e), i
		}, g.sortStable = T.split("").sort(it).join("") === T, g.detectDuplicates = !!h, C(), g.sortDetached = s(function (t) {
			return 1 & t.compareDocumentPosition(D.createElement("div"))
		}), s(function (t) {
			return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
		}) || H("type|href|height|width", function (t, e, i) {
			return i ? void 0 : t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
		}), g.attributes && s(function (t) {
			return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
		}) || H("value", function (t, e, i) {
			return i || "input" !== t.nodeName.toLowerCase() ? void 0 : t.defaultValue
		}), s(function (t) {
			return null == t.getAttribute("disabled")
		}) || H(lt, function (t, e, i) {
			var n;
			return i ? void 0 : t[e] === !0 ? e.toLowerCase() : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
		}), y
	}(k);
	C.find = t, C.expr = t.selectors, C.expr[":"] = C.expr.pseudos, C.uniqueSort = C.unique = t.uniqueSort, C.text = t.getText, C.isXMLDoc = t.isXML, C.contains = t.contains;
	var s = function (t, e, i) {
		for (var n = [], s = void 0 !== i;
			(t = t[e]) && 9 !== t.nodeType;)
			if (1 === t.nodeType) {
				if (s && C(t).is(i)) break;
				n.push(t)
			}
		return n
	},
		Rt = function (t, e) {
			for (var i = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && i.push(t);
			return i
		},
		Ft = C.expr.match.needsContext,
		Ht = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,
		zt = /^.[^:#\[\.,]*$/;
	C.filter = function (t, e, i) {
		var n = e[0];
		return i && (t = ":not(" + t + ")"), 1 === e.length && 1 === n.nodeType ? C.find.matchesSelector(n, t) ? [n] : [] : C.find.matches(t, C.grep(e, function (t) {
			return 1 === t.nodeType
		}))
	}, C.fn.extend({
		find: function (t) {
			var e, i = [],
				n = this,
				s = n.length;
			if ("string" != typeof t) return this.pushStack(C(t).filter(function () {
				for (e = 0; s > e; e++)
					if (C.contains(n[e], this)) return !0
			}));
			for (e = 0; s > e; e++) C.find(t, n[e], i);
			return i = this.pushStack(s > 1 ? C.unique(i) : i), i.selector = this.selector ? this.selector + " " + t : t, i
		},
		filter: function (t) {
			return this.pushStack(H(this, t || [], !1))
		},
		not: function (t) {
			return this.pushStack(H(this, t || [], !0))
		},
		is: function (t) {
			return !!H(this, "string" == typeof t && Ft.test(t) ? C(t) : t || [], !1).length
		}
	});
	var Wt, Bt = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
		jt = C.fn.init = function (t, e, i) {
			var n, s;
			if (!t) return this;
			if (i = i || Wt, "string" == typeof t) {
				if (n = "<" === t.charAt(0) && ">" === t.charAt(t.length - 1) && t.length >= 3 ? [null, t, null] : Bt.exec(t), !n || !n[1] && e) return !e || e.jquery ? (e || i).find(t) : this.constructor(e).find(t);
				if (n[1]) {
					if (e = e instanceof C ? e[0] : e, C.merge(this, C.parseHTML(n[1], e && e.nodeType ? e.ownerDocument || e : p, !0)), Ht.test(n[1]) && C.isPlainObject(e))
						for (n in e) C.isFunction(this[n]) ? this[n](e[n]) : this.attr(n, e[n]);
					return this
				}
				if (s = p.getElementById(n[2]), s && s.parentNode) {
					if (s.id !== n[2]) return Wt.find(t);
					this.length = 1, this[0] = s
				}
				return this.context = p, this.selector = t, this
			}
			return t.nodeType ? (this.context = this[0] = t, this.length = 1, this) : C.isFunction(t) ? "undefined" != typeof i.ready ? i.ready(t) : t(C) : (void 0 !== t.selector && (this.selector = t.selector, this.context = t.context), C.makeArray(t, this))
		};
	jt.prototype = C.fn, Wt = C(p);
	var Yt = /^(?:parents|prev(?:Until|All))/,
		Vt = {
			children: !0,
			contents: !0,
			next: !0,
			prev: !0
		};
	C.fn.extend({
		has: function (t) {
			var e, i = C(t, this),
				n = i.length;
			return this.filter(function () {
				for (e = 0; n > e; e++)
					if (C.contains(this, i[e])) return !0
			})
		},
		closest: function (t, e) {
			for (var i, n = 0, s = this.length, o = [], r = Ft.test(t) || "string" != typeof t ? C(t, e || this.context) : 0; s > n; n++)
				for (i = this[n]; i && i !== e; i = i.parentNode)
					if (i.nodeType < 11 && (r ? r.index(i) > -1 : 1 === i.nodeType && C.find.matchesSelector(i, t))) {
						o.push(i);
						break
					}
			return this.pushStack(o.length > 1 ? C.uniqueSort(o) : o)
		},
		index: function (t) {
			return t ? "string" == typeof t ? C.inArray(this[0], C(t)) : C.inArray(t.jquery ? t[0] : t, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
		},
		add: function (t, e) {
			return this.pushStack(C.uniqueSort(C.merge(this.get(), C(t, e))))
		},
		addBack: function (t) {
			return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
		}
	}), C.each({
		parent: function (t) {
			var e = t.parentNode;
			return e && 11 !== e.nodeType ? e : null
		},
		parents: function (t) {
			return s(t, "parentNode")
		},
		parentsUntil: function (t, e, i) {
			return s(t, "parentNode", i)
		},
		next: function (t) {
			return z(t, "nextSibling")
		},
		prev: function (t) {
			return z(t, "previousSibling")
		},
		nextAll: function (t) {
			return s(t, "nextSibling")
		},
		prevAll: function (t) {
			return s(t, "previousSibling")
		},
		nextUntil: function (t, e, i) {
			return s(t, "nextSibling", i)
		},
		prevUntil: function (t, e, i) {
			return s(t, "previousSibling", i)
		},
		siblings: function (t) {
			return Rt((t.parentNode || {}).firstChild, t)
		},
		children: function (t) {
			return Rt(t.firstChild)
		},
		contents: function (t) {
			return C.nodeName(t, "iframe") ? t.contentDocument || t.contentWindow.document : C.merge([], t.childNodes)
		}
	}, function (n, s) {
		C.fn[n] = function (t, e) {
			var i = C.map(this, s, t);
			return "Until" !== n.slice(-5) && (e = t), e && "string" == typeof e && (i = C.filter(e, i)), this.length > 1 && (Vt[n] || (i = C.uniqueSort(i)), Yt.test(n) && (i = i.reverse())), this.pushStack(i)
		}
	});
	var D = /\S+/g;
	C.Callbacks = function (n) {
		n = "string" == typeof n ? W(n) : C.extend({}, n);
		var i, t, e, s, o = [],
			r = [],
			a = -1,
			l = function () {
				for (s = n.once, e = i = !0; r.length; a = -1)
					for (t = r.shift(); ++a < o.length;) o[a].apply(t[0], t[1]) === !1 && n.stopOnFalse && (a = o.length, t = !1);
				n.memory || (t = !1), i = !1, s && (o = t ? [] : "")
			},
			h = {
				add: function () {
					return o && (t && !i && (a = o.length - 1, r.push(t)), function i(t) {
						C.each(t, function (t, e) {
							C.isFunction(e) ? n.unique && h.has(e) || o.push(e) : e && e.length && "string" !== C.type(e) && i(e)
						})
					}(arguments), t && !i && l()), this
				},
				remove: function () {
					return C.each(arguments, function (t, e) {
						for (var i;
							(i = C.inArray(e, o, i)) > -1;) o.splice(i, 1), a >= i && a--
					}), this
				},
				has: function (t) {
					return t ? C.inArray(t, o) > -1 : o.length > 0
				},
				empty: function () {
					return o && (o = []), this
				},
				disable: function () {
					return s = r = [], o = t = "", this
				},
				disabled: function () {
					return !o
				},
				lock: function () {
					return s = !0, t || h.disable(), this
				},
				locked: function () {
					return !!s
				},
				fireWith: function (t, e) {
					return s || (e = e || [], e = [t, e.slice ? e.slice() : e], r.push(e), i || l()), this
				},
				fire: function () {
					return h.fireWith(this, arguments), this
				},
				fired: function () {
					return !!e
				}
			};
		return h
	}, C.extend({
		Deferred: function (t) {
			var o = [
				["resolve", "done", C.Callbacks("once memory"), "resolved"],
				["reject", "fail", C.Callbacks("once memory"), "rejected"],
				["notify", "progress", C.Callbacks("memory")]
			],
				s = "pending",
				r = {
					state: function () {
						return s
					},
					always: function () {
						return a.done(arguments).fail(arguments), this
					},
					then: function () {
						var s = arguments;
						return C.Deferred(function (n) {
							C.each(o, function (t, e) {
								var i = C.isFunction(s[t]) && s[t];
								a[e[1]](function () {
									var t = i && i.apply(this, arguments);
									t && C.isFunction(t.promise) ? t.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[e[0] + "With"](this === r ? n.promise() : this, i ? [t] : arguments)
								})
							}), s = null
						}).promise()
					},
					promise: function (t) {
						return null != t ? C.extend(t, r) : r
					}
				},
				a = {};
			return r.pipe = r.then, C.each(o, function (t, e) {
				var i = e[2],
					n = e[3];
				r[e[1]] = i.add, n && i.add(function () {
					s = n
				}, o[1 ^ t][2].disable, o[2][2].lock), a[e[0]] = function () {
					return a[e[0] + "With"](this === a ? r : this, arguments), this
				}, a[e[0] + "With"] = i.fireWith
			}), r.promise(a), t && t.call(a, a), a
		},
		when: function (t) {
			var s, e, i, n = 0,
				o = c.call(arguments),
				r = o.length,
				a = 1 !== r || t && C.isFunction(t.promise) ? r : 0,
				l = 1 === a ? t : C.Deferred(),
				h = function (e, i, n) {
					return function (t) {
						i[e] = this, n[e] = arguments.length > 1 ? c.call(arguments) : t, n === s ? l.notifyWith(i, n) : --a || l.resolveWith(i, n)
					}
				};
			if (r > 1)
				for (s = new Array(r), e = new Array(r), i = new Array(r); r > n; n++) o[n] && C.isFunction(o[n].promise) ? o[n].promise().progress(h(n, e, s)).done(h(n, i, o)).fail(l.reject) : --a;
			return a || l.resolveWith(i, o), l.promise()
		}
	});
	var a;
	C.fn.ready = function (t) {
		return C.ready.promise().done(t), this
	}, C.extend({
		isReady: !1,
		readyWait: 1,
		holdReady: function (t) {
			t ? C.readyWait++ : C.ready(!0)
		},
		ready: function (t) {
			(t === !0 ? --C.readyWait : C.isReady) || (C.isReady = !0, t !== !0 && --C.readyWait > 0 || (a.resolveWith(p, [C]), C.fn.triggerHandler && (C(p).triggerHandler("ready"), C(p).off("ready"))))
		}
	}), C.ready.promise = function (t) {
		if (!a)
			if (a = C.Deferred(), "complete" === p.readyState || "loading" !== p.readyState && !p.documentElement.doScroll) k.setTimeout(C.ready);
			else if (p.addEventListener) p.addEventListener("DOMContentLoaded", e), k.addEventListener("load", e);
			else {
				p.attachEvent("onreadystatechange", e), k.attachEvent("onload", e);
				var i = !1;
				try {
					i = null == k.frameElement && p.documentElement
				} catch (t) { }
				i && i.doScroll && ! function e() {
					if (!C.isReady) {
						try {
							i.doScroll("left")
						} catch (t) {
							return k.setTimeout(e, 50)
						}
						B(), C.ready()
					}
				}()
			}
		return a.promise(t)
	}, C.ready.promise();
	var $t;
	for ($t in C(_)) break;
	_.ownFirst = "0" === $t, _.inlineBlockNeedsLayout = !1, C(function () {
		var t, e, i, n;
		i = p.getElementsByTagName("body")[0], i && i.style && (e = p.createElement("div"), n = p.createElement("div"), n.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", i.appendChild(n).appendChild(e), "undefined" != typeof e.style.zoom && (e.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", _.inlineBlockNeedsLayout = t = 3 === e.offsetWidth, t && (i.style.zoom = 1)), i.removeChild(n))
	}),
		function () {
			var t = p.createElement("div");
			_.deleteExpando = !0;
			try {
				delete t.test
			} catch (t) {
				_.deleteExpando = !1
			}
			t = null
		}();
	var y = function (t) {
		var e = C.noData[(t.nodeName + " ").toLowerCase()],
			i = +t.nodeType || 1;
		return 1 !== i && 9 !== i ? !1 : !e || e !== !0 && t.getAttribute("classid") === e
	},
		Ut = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		qt = /([A-Z])/g;
	C.extend({
		cache: {},
		noData: {
			"applet ": !0,
			"embed ": !0,
			"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
		},
		hasData: function (t) {
			return t = t.nodeType ? C.cache[t[C.expando]] : t[C.expando], !!t && !Y(t)
		},
		data: function (t, e, i) {
			return V(t, e, i)
		},
		removeData: function (t, e) {
			return $(t, e)
		},
		_data: function (t, e, i) {
			return V(t, e, i, !0)
		},
		_removeData: function (t, e) {
			return $(t, e, !0)
		}
	}), C.fn.extend({
		data: function (t, e) {
			var i, n, s, o = this[0],
				r = o && o.attributes;
			if (void 0 === t) {
				if (this.length && (s = C.data(o), 1 === o.nodeType && !C._data(o, "parsedAttrs"))) {
					for (i = r.length; i--;) r[i] && (n = r[i].name, 0 === n.indexOf("data-") && (n = C.camelCase(n.slice(5)), j(o, n, s[n])));
					C._data(o, "parsedAttrs", !0)
				}
				return s
			}
			return "object" == typeof t ? this.each(function () {
				C.data(this, t)
			}) : arguments.length > 1 ? this.each(function () {
				C.data(this, t, e)
			}) : o ? j(o, t, C.data(o, t)) : void 0
		},
		removeData: function (t) {
			return this.each(function () {
				C.removeData(this, t)
			})
		}
	}), C.extend({
		queue: function (t, e, i) {
			var n;
			return t ? (e = (e || "fx") + "queue", n = C._data(t, e), i && (!n || C.isArray(i) ? n = C._data(t, e, C.makeArray(i)) : n.push(i)), n || []) : void 0
		},
		dequeue: function (t, e) {
			e = e || "fx";
			var i = C.queue(t, e),
				n = i.length,
				s = i.shift(),
				o = C._queueHooks(t, e),
				r = function () {
					C.dequeue(t, e)
				};
			"inprogress" === s && (s = i.shift(), n--), s && ("fx" === e && i.unshift("inprogress"), delete o.stop, s.call(t, r, o)), !n && o && o.empty.fire()
		},
		_queueHooks: function (t, e) {
			var i = e + "queueHooks";
			return C._data(t, i) || C._data(t, i, {
				empty: C.Callbacks("once memory").add(function () {
					C._removeData(t, e + "queue"), C._removeData(t, i)
				})
			})
		}
	}), C.fn.extend({
		queue: function (e, i) {
			var t = 2;
			return "string" != typeof e && (i = e, e = "fx", t--), arguments.length < t ? C.queue(this[0], e) : void 0 === i ? this : this.each(function () {
				var t = C.queue(this, e, i);
				C._queueHooks(this, e), "fx" === e && "inprogress" !== t[0] && C.dequeue(this, e)
			})
		},
		dequeue: function (t) {
			return this.each(function () {
				C.dequeue(this, t)
			})
		},
		clearQueue: function (t) {
			return this.queue(t || "fx", [])
		},
		promise: function (t, e) {
			var i, n = 1,
				s = C.Deferred(),
				o = this,
				r = this.length,
				a = function () {
					--n || s.resolveWith(o, [o])
				};
			for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; r--;) i = C._data(o[r], t + "queueHooks"), i && i.empty && (n++, i.empty.add(a));
			return a(), s.promise(e)
		}
	}),
		function () {
			var n;
			_.shrinkWrapBlocks = function () {
				if (null != n) return n;
				n = !1;
				var t, e, i;
				return e = p.getElementsByTagName("body")[0], e && e.style ? (t = p.createElement("div"), i = p.createElement("div"), i.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", e.appendChild(i).appendChild(t), "undefined" != typeof t.style.zoom && (t.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", t.appendChild(p.createElement("div")).style.width = "5px", n = 3 !== t.offsetWidth), e.removeChild(i), n) : void 0
			}
		}();
	var Gt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
		Kt = new RegExp("^(?:([+-])=|)(" + Gt + ")([a-z%]*)$", "i"),
		f = ["Top", "Right", "Bottom", "Left"],
		x = function (t, e) {
			return t = e || t, "none" === C.css(t, "display") || !C.contains(t.ownerDocument, t)
		},
		w = function (t, e, i, n, s, o, r) {
			var a = 0,
				l = t.length,
				h = null == i;
			if ("object" === C.type(i)) {
				s = !0;
				for (a in i) w(t, e, a, i[a], !0, o, r)
			} else if (void 0 !== n && (s = !0, C.isFunction(n) || (r = !0), h && (r ? (e.call(t, n), e = null) : (h = e, e = function (t, e, i) {
				return h.call(C(t), i)
			})), e))
				for (; l > a; a++) e(t[a], i, r ? n : n.call(t[a], a, e(t[a], i)));
			return s ? t : h ? e.call(t) : l ? e(t[0], i) : o
		},
		Xt = /^(?:checkbox|radio)$/i,
		Zt = /<([\w:-]+)/,
		Qt = /^$|\/(?:java|ecma)script/i,
		Jt = /^\s+/,
		te = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|dialog|figcaption|figure|footer|header|hgroup|main|mark|meter|nav|output|picture|progress|section|summary|template|time|video";
	! function () {
		var t = p.createElement("div"),
			e = p.createDocumentFragment(),
			i = p.createElement("input");
		t.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", _.leadingWhitespace = 3 === t.firstChild.nodeType, _.tbody = !t.getElementsByTagName("tbody").length, _.htmlSerialize = !!t.getElementsByTagName("link").length, _.html5Clone = "<:nav></:nav>" !== p.createElement("nav").cloneNode(!0).outerHTML, i.type = "checkbox", i.checked = !0, e.appendChild(i), _.appendChecked = i.checked, t.innerHTML = "<textarea>x</textarea>", _.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue, e.appendChild(t), i = p.createElement("input"), i.setAttribute("type", "radio"), i.setAttribute("checked", "checked"), i.setAttribute("name", "t"), t.appendChild(i), _.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, _.noCloneEvent = !!t.addEventListener, t[C.expando] = 1, _.attributes = !t.getAttribute(C.expando)
	}();
	var M = {
		option: [1, "<select multiple='multiple'>", "</select>"],
		legend: [1, "<fieldset>", "</fieldset>"],
		area: [1, "<map>", "</map>"],
		param: [1, "<object>", "</object>"],
		thead: [1, "<table>", "</table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
		_default: _.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
	};
	M.optgroup = M.option, M.tbody = M.tfoot = M.colgroup = M.caption = M.thead, M.th = M.td;
	var ee = /<|&#?\w+;/,
		ie = /<tbody/i;
	! function () {
		var t, e, i = p.createElement("div");
		for (t in {
			submit: !0,
			change: !0,
			focusin: !0
		}) e = "on" + t, (_[t] = e in k) || (i.setAttribute(e, "t"), _[t] = i.attributes[e].expando === !1);
		i = null
	}();
	var ne = /^(?:input|select|textarea)$/i,
		se = /^key/,
		oe = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		re = /^(?:focusinfocus|focusoutblur)$/,
		ae = /^([^.]*)(?:\.(.+)|)/;
	C.event = {
		global: {},
		add: function (t, e, i, n, s) {
			var o, r, a, l, h, c, u, d, f, p, g, m = C._data(t);
			if (m) {
				for (i.handler && (l = i, i = l.handler, s = l.selector), i.guid || (i.guid = C.guid++), (r = m.events) || (r = m.events = {}), (c = m.handle) || (c = m.handle = function (t) {
					return "undefined" == typeof C || t && C.event.triggered === t.type ? void 0 : C.event.dispatch.apply(c.elem, arguments)
				}, c.elem = t), e = (e || "").match(D) || [""], a = e.length; a--;) o = ae.exec(e[a]) || [], f = g = o[1], p = (o[2] || "").split(".").sort(), f && (h = C.event.special[f] || {}, f = (s ? h.delegateType : h.bindType) || f, h = C.event.special[f] || {}, u = C.extend({
					type: f,
					origType: g,
					data: n,
					handler: i,
					guid: i.guid,
					selector: s,
					needsContext: s && C.expr.match.needsContext.test(s),
					namespace: p.join(".")
				}, l), (d = r[f]) || (d = r[f] = [], d.delegateCount = 0, h.setup && h.setup.call(t, n, p, c) !== !1 || (t.addEventListener ? t.addEventListener(f, c, !1) : t.attachEvent && t.attachEvent("on" + f, c))), h.add && (h.add.call(t, u), u.handler.guid || (u.handler.guid = i.guid)), s ? d.splice(d.delegateCount++, 0, u) : d.push(u), C.event.global[f] = !0);
				t = null
			}
		},
		remove: function (t, e, i, n, s) {
			var o, r, a, l, h, c, u, d, f, p, g, m = C.hasData(t) && C._data(t);
			if (m && (c = m.events)) {
				for (e = (e || "").match(D) || [""], h = e.length; h--;)
					if (a = ae.exec(e[h]) || [], f = g = a[1], p = (a[2] || "").split(".").sort(), f) {
						for (u = C.event.special[f] || {}, f = (n ? u.delegateType : u.bindType) || f, d = c[f] || [], a = a[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), l = o = d.length; o--;) r = d[o], !s && g !== r.origType || i && i.guid !== r.guid || a && !a.test(r.namespace) || n && n !== r.selector && ("**" !== n || !r.selector) || (d.splice(o, 1), r.selector && d.delegateCount--, u.remove && u.remove.call(t, r));
						l && !d.length && (u.teardown && u.teardown.call(t, p, m.handle) !== !1 || C.removeEvent(t, f, m.handle), delete c[f])
					} else
						for (f in c) C.event.remove(t, f + e[h], i, n, !0);
				C.isEmptyObject(c) && (delete m.handle, C._removeData(t, "events"))
			}
		},
		trigger: function (t, e, i, n) {
			var s, o, r, a, l, h, c, u = [i || p],
				d = b.call(t, "type") ? t.type : t,
				f = b.call(t, "namespace") ? t.namespace.split(".") : [];
			if (r = h = i = i || p, 3 !== i.nodeType && 8 !== i.nodeType && !re.test(d + C.event.triggered) && (d.indexOf(".") > -1 && (f = d.split("."), d = f.shift(), f.sort()), o = d.indexOf(":") < 0 && "on" + d, t = t[C.expando] ? t : new C.Event(d, "object" == typeof t && t), t.isTrigger = n ? 2 : 3, t.namespace = f.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), e = null == e ? [t] : C.makeArray(e, [t]), l = C.event.special[d] || {}, n || !l.trigger || l.trigger.apply(i, e) !== !1)) {
				if (!n && !l.noBubble && !C.isWindow(i)) {
					for (a = l.delegateType || d, re.test(a + d) || (r = r.parentNode); r; r = r.parentNode) u.push(r), h = r;
					h === (i.ownerDocument || p) && u.push(h.defaultView || h.parentWindow || k)
				}
				for (c = 0;
					(r = u[c++]) && !t.isPropagationStopped();) t.type = c > 1 ? a : l.bindType || d, s = (C._data(r, "events") || {})[t.type] && C._data(r, "handle"), s && s.apply(r, e), s = o && r[o], s && s.apply && y(r) && (t.result = s.apply(r, e), t.result === !1 && t.preventDefault());
				if (t.type = d, !n && !t.isDefaultPrevented() && (!l._default || l._default.apply(u.pop(), e) === !1) && y(i) && o && i[d] && !C.isWindow(i)) {
					h = i[o], h && (i[o] = null), C.event.triggered = d;
					try {
						i[d]()
					} catch (t) { }
					C.event.triggered = void 0, h && (i[o] = h)
				}
				return t.result
			}
		},
		dispatch: function (t) {
			t = C.event.fix(t);
			var e, i, n, s, o, r = [],
				a = c.call(arguments),
				l = (C._data(this, "events") || {})[t.type] || [],
				h = C.event.special[t.type] || {};
			if (a[0] = t, t.delegateTarget = this, !h.preDispatch || h.preDispatch.call(this, t) !== !1) {
				for (r = C.event.handlers.call(this, t, l), e = 0;
					(s = r[e++]) && !t.isPropagationStopped();)
					for (t.currentTarget = s.elem, i = 0;
						(o = s.handlers[i++]) && !t.isImmediatePropagationStopped();) t.rnamespace && !t.rnamespace.test(o.namespace) || (t.handleObj = o, t.data = o.data, n = ((C.event.special[o.origType] || {}).handle || o.handler).apply(s.elem, a), void 0 !== n && (t.result = n) === !1 && (t.preventDefault(), t.stopPropagation()));
				return h.postDispatch && h.postDispatch.call(this, t), t.result
			}
		},
		handlers: function (t, e) {
			var i, n, s, o, r = [],
				a = e.delegateCount,
				l = t.target;
			if (a && l.nodeType && ("click" !== t.type || isNaN(t.button) || t.button < 1))
				for (; l != this; l = l.parentNode || this)
					if (1 === l.nodeType && (l.disabled !== !0 || "click" !== t.type)) {
						for (n = [], i = 0; a > i; i++) o = e[i], s = o.selector + " ", void 0 === n[s] && (n[s] = o.needsContext ? C(s, this).index(l) > -1 : C.find(s, this, null, [l]).length), n[s] && n.push(o);
						n.length && r.push({
							elem: l,
							handlers: n
						})
					}
			return a < e.length && r.push({
				elem: this,
				handlers: e.slice(a)
			}), r
		},
		fix: function (t) {
			if (t[C.expando]) return t;
			var e, i, n, s = t.type,
				o = t,
				r = this.fixHooks[s];
			for (r || (this.fixHooks[s] = r = oe.test(s) ? this.mouseHooks : se.test(s) ? this.keyHooks : {}), n = r.props ? this.props.concat(r.props) : this.props, t = new C.Event(o), e = n.length; e--;) i = n[e], t[i] = o[i];
			return t.target || (t.target = o.srcElement || p), 3 === t.target.nodeType && (t.target = t.target.parentNode), t.metaKey = !!t.metaKey, r.filter ? r.filter(t, o) : t
		},
		props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
		fixHooks: {},
		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function (t, e) {
				return null == t.which && (t.which = null != e.charCode ? e.charCode : e.keyCode), t
			}
		},
		mouseHooks: {
			props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function (t, e) {
				var i, n, s, o = e.button,
					r = e.fromElement;
				return null == t.pageX && null != e.clientX && (n = t.target.ownerDocument || p, s = n.documentElement, i = n.body, t.pageX = e.clientX + (s && s.scrollLeft || i && i.scrollLeft || 0) - (s && s.clientLeft || i && i.clientLeft || 0), t.pageY = e.clientY + (s && s.scrollTop || i && i.scrollTop || 0) - (s && s.clientTop || i && i.clientTop || 0)), !t.relatedTarget && r && (t.relatedTarget = r === t.target ? e.toElement : r), t.which || void 0 === o || (t.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), t
			}
		},
		special: {
			load: {
				noBubble: !0
			},
			focus: {
				trigger: function () {
					if (this !== Z() && this.focus) try {
						return this.focus(), !1
					} catch (t) { }
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function () {
					return this === Z() && this.blur ? (this.blur(), !1) : void 0
				},
				delegateType: "focusout"
			},
			click: {
				trigger: function () {
					return C.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0
				},
				_default: function (t) {
					return C.nodeName(t.target, "a")
				}
			},
			beforeunload: {
				postDispatch: function (t) {
					void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
				}
			}
		},
		simulate: function (t, e, i) {
			var n = C.extend(new C.Event, i, {
				type: t,
				isSimulated: !0
			});
			C.event.trigger(n, null, e), n.isDefaultPrevented() && i.preventDefault()
		}
	}, C.removeEvent = p.removeEventListener ? function (t, e, i) {
		t.removeEventListener && t.removeEventListener(e, i)
	} : function (t, e, i) {
		var n = "on" + e;
		t.detachEvent && ("undefined" == typeof t[n] && (t[n] = null), t.detachEvent(n, i))
	}, C.Event = function (t, e) {
		return this instanceof C.Event ? (t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && t.returnValue === !1 ? i : l) : this.type = t, e && C.extend(this, e), this.timeStamp = t && t.timeStamp || C.now(), void (this[C.expando] = !0)) : new C.Event(t, e)
	}, C.Event.prototype = {
		constructor: C.Event,
		isDefaultPrevented: l,
		isPropagationStopped: l,
		isImmediatePropagationStopped: l,
		preventDefault: function () {
			var t = this.originalEvent;
			this.isDefaultPrevented = i, t && (t.preventDefault ? t.preventDefault() : t.returnValue = !1)
		},
		stopPropagation: function () {
			var t = this.originalEvent;
			this.isPropagationStopped = i, t && !this.isSimulated && (t.stopPropagation && t.stopPropagation(), t.cancelBubble = !0)
		},
		stopImmediatePropagation: function () {
			var t = this.originalEvent;
			this.isImmediatePropagationStopped = i, t && t.stopImmediatePropagation && t.stopImmediatePropagation(), this.stopPropagation()
		}
	}, C.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (t, o) {
		C.event.special[t] = {
			delegateType: o,
			bindType: o,
			handle: function (t) {
				var e, i = this,
					n = t.relatedTarget,
					s = t.handleObj;
				return n && (n === i || C.contains(i, n)) || (t.type = s.origType, e = s.handler.apply(this, arguments), t.type = o), e
			}
		}
	}), _.submit || (C.event.special.submit = {
		setup: function () {
			return C.nodeName(this, "form") ? !1 : void C.event.add(this, "click._submit keypress._submit", function (t) {
				var e = t.target,
					i = C.nodeName(e, "input") || C.nodeName(e, "button") ? C.prop(e, "form") : void 0;
				i && !C._data(i, "submit") && (C.event.add(i, "submit._submit", function (t) {
					t._submitBubble = !0
				}), C._data(i, "submit", !0))
			})
		},
		postDispatch: function (t) {
			t._submitBubble && (delete t._submitBubble, this.parentNode && !t.isTrigger && C.event.simulate("submit", this.parentNode, t))
		},
		teardown: function () {
			return C.nodeName(this, "form") ? !1 : void C.event.remove(this, "._submit")
		}
	}), _.change || (C.event.special.change = {
		setup: function () {
			return ne.test(this.nodeName) ? ("checkbox" !== this.type && "radio" !== this.type || (C.event.add(this, "propertychange._change", function (t) {
				"checked" === t.originalEvent.propertyName && (this._justChanged = !0)
			}), C.event.add(this, "click._change", function (t) {
				this._justChanged && !t.isTrigger && (this._justChanged = !1), C.event.simulate("change", this, t)
			})), !1) : void C.event.add(this, "beforeactivate._change", function (t) {
				var e = t.target;
				ne.test(e.nodeName) && !C._data(e, "change") && (C.event.add(e, "change._change", function (t) {
					!this.parentNode || t.isSimulated || t.isTrigger || C.event.simulate("change", this.parentNode, t)
				}), C._data(e, "change", !0))
			})
		},
		handle: function (t) {
			var e = t.target;
			return this !== e || t.isSimulated || t.isTrigger || "radio" !== e.type && "checkbox" !== e.type ? t.handleObj.handler.apply(this, arguments) : void 0
		},
		teardown: function () {
			return C.event.remove(this, "._change"), !ne.test(this.nodeName)
		}
	}), _.focusin || C.each({
		focus: "focusin",
		blur: "focusout"
	}, function (i, n) {
		var s = function (t) {
			C.event.simulate(n, t.target, C.event.fix(t))
		};
		C.event.special[n] = {
			setup: function () {
				var t = this.ownerDocument || this,
					e = C._data(t, n);
				e || t.addEventListener(i, s, !0), C._data(t, n, (e || 0) + 1)
			},
			teardown: function () {
				var t = this.ownerDocument || this,
					e = C._data(t, n) - 1;
				e ? C._data(t, n, e) : (t.removeEventListener(i, s, !0), C._removeData(t, n))
			}
		}
	}), C.fn.extend({
		on: function (t, e, i, n) {
			return Q(this, t, e, i, n)
		},
		one: function (t, e, i, n) {
			return Q(this, t, e, i, n, 1)
		},
		off: function (t, e, i) {
			var n, s;
			if (t && t.preventDefault && t.handleObj) return n = t.handleObj, C(t.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this;
			if ("object" == typeof t) {
				for (s in t) this.off(s, e, t[s]);
				return this
			}
			return e !== !1 && "function" != typeof e || (i = e, e = void 0), i === !1 && (i = l), this.each(function () {
				C.event.remove(this, t, i, e)
			})
		},
		trigger: function (t, e) {
			return this.each(function () {
				C.event.trigger(t, e, this)
			})
		},
		triggerHandler: function (t, e) {
			var i = this[0];
			return i ? C.event.trigger(t, e, i, !0) : void 0
		}
	});
	var le = / jQuery\d+="(?:null|\d+)"/g,
		he = new RegExp("<(?:" + te + ")[\\s/>]", "i"),
		ce = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
		ue = /<script|<style|<link/i,
		de = /checked\s*(?:[^=]|=\s*.checked.)/i,
		fe = /^true\/(.*)/,
		pe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
		ge = q(p),
		me = ge.appendChild(p.createElement("div"));
	C.extend({
		htmlPrefilter: function (t) {
			return t.replace(ce, "<$1></$2>")
		},
		clone: function (t, e, i) {
			var n, s, o, r, a, l = C.contains(t.ownerDocument, t);
			if (_.html5Clone || C.isXMLDoc(t) || !he.test("<" + t.nodeName + ">") ? o = t.cloneNode(!0) : (me.innerHTML = t.outerHTML, me.removeChild(o = me.firstChild)), !(_.noCloneEvent && _.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || C.isXMLDoc(t)))
				for (n = m(o), a = m(t), r = 0; null != (s = a[r]); ++r) n[r] && nt(s, n[r]);
			if (e)
				if (i)
					for (a = a || m(t), n = n || m(o), r = 0; null != (s = a[r]); r++) it(s, n[r]);
				else it(t, o);
			return n = m(o, "script"), n.length > 0 && G(n, !l && m(t, "script")), n = a = s = null, o
		},
		cleanData: function (t, e) {
			for (var i, n, s, o, r = 0, a = C.expando, l = C.cache, h = _.attributes, c = C.event.special; null != (i = t[r]); r++)
				if ((e || y(i)) && (s = i[a], o = s && l[s])) {
					if (o.events)
						for (n in o.events) c[n] ? C.event.remove(i, n) : C.removeEvent(i, n, o.handle);
					l[s] && (delete l[s], h || "undefined" == typeof i.removeAttribute ? i[a] = void 0 : i.removeAttribute(a), d.push(s))
				}
		}
	}), C.fn.extend({
		domManip: g,
		detach: function (t) {
			return st(this, t, !0)
		},
		remove: function (t) {
			return st(this, t)
		},
		text: function (t) {
			return w(this, function (t) {
				return void 0 === t ? C.text(this) : this.empty().append((this[0] && this[0].ownerDocument || p).createTextNode(t))
			}, null, t, arguments.length)
		},
		append: function () {
			return g(this, arguments, function (t) {
				if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
					var e = J(this, t);
					e.appendChild(t)
				}
			})
		},
		prepend: function () {
			return g(this, arguments, function (t) {
				if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
					var e = J(this, t);
					e.insertBefore(t, e.firstChild)
				}
			})
		},
		before: function () {
			return g(this, arguments, function (t) {
				this.parentNode && this.parentNode.insertBefore(t, this)
			})
		},
		after: function () {
			return g(this, arguments, function (t) {
				this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
			})
		},
		empty: function () {
			for (var t, e = 0; null != (t = this[e]); e++) {
				for (1 === t.nodeType && C.cleanData(m(t, !1)); t.firstChild;) t.removeChild(t.firstChild);
				t.options && C.nodeName(t, "select") && (t.options.length = 0)
			}
			return this
		},
		clone: function (t, e) {
			return t = null == t ? !1 : t, e = null == e ? t : e, this.map(function () {
				return C.clone(this, t, e)
			})
		},
		html: function (t) {
			return w(this, function (t) {
				var e = this[0] || {},
					i = 0,
					n = this.length;
				if (void 0 === t) return 1 === e.nodeType ? e.innerHTML.replace(le, "") : void 0;
				if ("string" == typeof t && !ue.test(t) && (_.htmlSerialize || !he.test(t)) && (_.leadingWhitespace || !Jt.test(t)) && !M[(Zt.exec(t) || ["", ""])[1].toLowerCase()]) {
					t = C.htmlPrefilter(t);
					try {
						for (; n > i; i++) e = this[i] || {}, 1 === e.nodeType && (C.cleanData(m(e, !1)), e.innerHTML = t);
						e = 0
					} catch (t) { }
				}
				e && this.empty().append(t)
			}, null, t, arguments.length)
		},
		replaceWith: function () {
			var i = [];
			return g(this, arguments, function (t) {
				var e = this.parentNode;
				C.inArray(this, i) < 0 && (C.cleanData(m(this)), e && e.replaceChild(t, this))
			}, i)
		}
	}), C.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (t, r) {
		C.fn[t] = function (t) {
			for (var e, i = 0, n = [], s = C(t), o = s.length - 1; o >= i; i++) e = i === o ? this : this.clone(!0), C(s[i])[r](e), St.apply(n, e.get());
			return this.pushStack(n)
		}
	});
	var T, ve = {
		HTML: "block",
		BODY: "block"
	},
		be = /^margin/,
		_e = new RegExp("^(" + Gt + ")(?!px)[a-z%]+$", "i"),
		ye = function (t, e, i, n) {
			var s, o, r = {};
			for (o in e) r[o] = t.style[o], t.style[o] = e[o];
			s = i.apply(t, n || []);
			for (o in e) t.style[o] = r[o];
			return s
		},
		xe = p.documentElement;
	! function () {
		function t() {
			var t, e, i = p.documentElement;
			i.appendChild(h), c.style.cssText = "-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", n = o = l = !1, s = a = !0, k.getComputedStyle && (e = k.getComputedStyle(c), n = "1%" !== (e || {}).top, l = "2px" === (e || {}).marginLeft, o = "4px" === (e || {
				width: "4px"
			}).width, c.style.marginRight = "50%", s = "4px" === (e || {
				marginRight: "4px"
			}).marginRight, t = c.appendChild(p.createElement("div")), t.style.cssText = c.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", t.style.marginRight = t.style.width = "0", c.style.width = "1px", a = !parseFloat((k.getComputedStyle(t) || {}).marginRight), c.removeChild(t)), c.style.display = "none", r = 0 === c.getClientRects().length, r && (c.style.display = "", c.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", c.childNodes[0].style.borderCollapse = "separate", t = c.getElementsByTagName("td"), t[0].style.cssText = "margin:0;border:0;padding:0;display:none", r = 0 === t[0].offsetHeight, r && (t[0].style.display = "", t[1].style.display = "none", r = 0 === t[0].offsetHeight)), i.removeChild(h)
		}
		var n, s, o, r, a, l, h = p.createElement("div"),
			c = p.createElement("div");
		c.style && (c.style.cssText = "float:left;opacity:.5", _.opacity = "0.5" === c.style.opacity, _.cssFloat = !!c.style.cssFloat, c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", _.clearCloneStyle = "content-box" === c.style.backgroundClip, h = p.createElement("div"), h.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", c.innerHTML = "", h.appendChild(c), _.boxSizing = "" === c.style.boxSizing || "" === c.style.MozBoxSizing || "" === c.style.WebkitBoxSizing, C.extend(_, {
			reliableHiddenOffsets: function () {
				return null == n && t(), r
			},
			boxSizingReliable: function () {
				return null == n && t(), o
			},
			pixelMarginRight: function () {
				return null == n && t(), s
			},
			pixelPosition: function () {
				return null == n && t(), n
			},
			reliableMarginRight: function () {
				return null == n && t(), a
			},
			reliableMarginLeft: function () {
				return null == n && t(), l
			}
		}))
	}();
	var S, P, we = /^(top|right|bottom|left)$/;
	k.getComputedStyle ? (S = function (t) {
		var e = t.ownerDocument.defaultView;
		return e && e.opener || (e = k), e.getComputedStyle(t)
	}, P = function (t, e, i) {
		var n, s, o, r, a = t.style;
		return i = i || S(t), r = i ? i.getPropertyValue(e) || i[e] : void 0, "" !== r && void 0 !== r || C.contains(t.ownerDocument, t) || (r = C.style(t, e)), i && !_.pixelMarginRight() && _e.test(r) && be.test(e) && (n = a.width, s = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = r, r = i.width, a.width = n, a.minWidth = s, a.maxWidth = o), void 0 === r ? r : r + ""
	}) : xe.currentStyle && (S = function (t) {
		return t.currentStyle
	}, P = function (t, e, i) {
		var n, s, o, r, a = t.style;
		return i = i || S(t), r = i ? i[e] : void 0, null == r && a && a[e] && (r = a[e]), _e.test(r) && !we.test(e) && (n = a.left, s = t.runtimeStyle, o = s && s.left, o && (s.left = t.currentStyle.left), a.left = "fontSize" === e ? "1em" : r, r = a.pixelLeft + "px", a.left = n, o && (s.left = o)), void 0 === r ? r : r + "" || "auto"
	});
	var ke = /alpha\([^)]*\)/i,
		Ce = /opacity\s*=\s*([^)]*)/i,
		De = /^(none|table(?!-c[ea]).+)/,
		Me = new RegExp("^(" + Gt + ")(.*)$", "i"),
		Te = {
			position: "absolute",
			visibility: "hidden",
			display: "block"
		},
		Se = {
			letterSpacing: "0",
			fontWeight: "400"
		},
		Pe = ["Webkit", "O", "Moz", "ms"],
		Ie = p.createElement("div").style;
	C.extend({
		cssHooks: {
			opacity: {
				get: function (t, e) {
					if (e) {
						var i = P(t, "opacity");
						return "" === i ? "1" : i
					}
				}
			}
		},
		cssNumber: {
			animationIterationCount: !0,
			columnCount: !0,
			fillOpacity: !0,
			flexGrow: !0,
			flexShrink: !0,
			fontWeight: !0,
			lineHeight: !0,
			opacity: !0,
			order: !0,
			orphans: !0,
			widows: !0,
			zIndex: !0,
			zoom: !0
		},
		cssProps: {
			float: _.cssFloat ? "cssFloat" : "styleFloat"
		},
		style: function (t, e, i, n) {
			if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
				var s, o, r, a = C.camelCase(e),
					l = t.style;
				if (e = C.cssProps[a] || (C.cssProps[a] = at(a) || a), r = C.cssHooks[e] || C.cssHooks[a], void 0 === i) return r && "get" in r && void 0 !== (s = r.get(t, !1, n)) ? s : l[e];
				if (o = typeof i, "string" === o && (s = Kt.exec(i)) && s[1] && (i = U(t, e, s), o = "number"), null != i && i === i && ("number" === o && (i += s && s[3] || (C.cssNumber[a] ? "" : "px")), _.clearCloneStyle || "" !== i || 0 !== e.indexOf("background") || (l[e] = "inherit"), !(r && "set" in r && void 0 === (i = r.set(t, i, n))))) try {
					l[e] = i
				} catch (t) { }
			}
		},
		css: function (t, e, i, n) {
			var s, o, r, a = C.camelCase(e);
			return e = C.cssProps[a] || (C.cssProps[a] = at(a) || a), r = C.cssHooks[e] || C.cssHooks[a], r && "get" in r && (o = r.get(t, !0, i)), void 0 === o && (o = P(t, e, n)), "normal" === o && e in Se && (o = Se[e]), "" === i || i ? (s = parseFloat(o), i === !0 || isFinite(s) ? s || 0 : o) : o
		}
	}), C.each(["height", "width"], function (t, s) {
		C.cssHooks[s] = {
			get: function (t, e, i) {
				return e ? De.test(C.css(t, "display")) && 0 === t.offsetWidth ? ye(t, Te, function () {
					return ut(t, s, i)
				}) : ut(t, s, i) : void 0
			},
			set: function (t, e, i) {
				var n = i && S(t);
				return ht(t, e, i ? ct(t, s, i, _.boxSizing && "border-box" === C.css(t, "boxSizing", !1, n), n) : 0)
			}
		}
	}), _.opacity || (C.cssHooks.opacity = {
		get: function (t, e) {
			return Ce.test((e && t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : e ? "1" : ""
		},
		set: function (t, e) {
			var i = t.style,
				n = t.currentStyle,
				s = C.isNumeric(e) ? "alpha(opacity=" + 100 * e + ")" : "",
				o = n && n.filter || i.filter || "";
			i.zoom = 1, (e >= 1 || "" === e) && "" === C.trim(o.replace(ke, "")) && i.removeAttribute && (i.removeAttribute("filter"), "" === e || n && !n.filter) || (i.filter = ke.test(o) ? o.replace(ke, s) : o + " " + s)
		}
	}), C.cssHooks.marginRight = rt(_.reliableMarginRight, function (t, e) {
		return e ? ye(t, {
			display: "inline-block"
		}, P, [t, "marginRight"]) : void 0
	}), C.cssHooks.marginLeft = rt(_.reliableMarginLeft, function (t, e) {
		return e ? (parseFloat(P(t, "marginLeft")) || (C.contains(t.ownerDocument, t) ? t.getBoundingClientRect().left - ye(t, {
			marginLeft: 0
		}, function () {
			return t.getBoundingClientRect().left
		}) : 0)) + "px" : void 0
	}), C.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (s, o) {
		C.cssHooks[s + o] = {
			expand: function (t) {
				for (var e = 0, i = {}, n = "string" == typeof t ? t.split(" ") : [t]; 4 > e; e++) i[s + f[e] + o] = n[e] || n[e - 2] || n[0];
				return i
			}
		}, be.test(s) || (C.cssHooks[s + o].set = ht)
	}), C.fn.extend({
		css: function (t, e) {
			return w(this, function (t, e, i) {
				var n, s, o = {},
					r = 0;
				if (C.isArray(e)) {
					for (n = S(t), s = e.length; s > r; r++) o[e[r]] = C.css(t, e[r], !1, n);
					return o
				}
				return void 0 !== i ? C.style(t, e, i) : C.css(t, e)
			}, t, e, arguments.length > 1)
		},
		show: function () {
			return lt(this, !0)
		},
		hide: function () {
			return lt(this)
		},
		toggle: function (t) {
			return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function () {
				x(this) ? C(this).show() : C(this).hide()
			})
		}
	}), C.Tween = o, o.prototype = {
		constructor: o,
		init: function (t, e, i, n, s, o) {
			this.elem = t, this.prop = i, this.easing = s || C.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = n, this.unit = o || (C.cssNumber[i] ? "" : "px")
		},
		cur: function () {
			var t = o.propHooks[this.prop];
			return t && t.get ? t.get(this) : o.propHooks._default.get(this)
		},
		run: function (t) {
			var e, i = o.propHooks[this.prop];
			return this.options.duration ? this.pos = e = C.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : o.propHooks._default.set(this), this
		}
	}, o.prototype.init.prototype = o.prototype, o.propHooks = {
		_default: {
			get: function (t) {
				var e;
				return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = C.css(t.elem, t.prop, ""), e && "auto" !== e ? e : 0)
			},
			set: function (t) {
				C.fx.step[t.prop] ? C.fx.step[t.prop](t) : 1 !== t.elem.nodeType || null == t.elem.style[C.cssProps[t.prop]] && !C.cssHooks[t.prop] ? t.elem[t.prop] = t.now : C.style(t.elem, t.prop, t.now + t.unit)
			}
		}
	}, o.propHooks.scrollTop = o.propHooks.scrollLeft = {
		set: function (t) {
			t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
		}
	}, C.easing = {
		linear: function (t) {
			return t
		},
		swing: function (t) {
			return .5 - Math.cos(t * Math.PI) / 2
		},
		_default: "swing"
	}, C.fx = o.prototype.init, C.fx.step = {};
	var I, Ee, Oe = /^(?:toggle|show|hide)$/,
		Ae = /queueHooks$/;
	C.Animation = C.extend(u, {
		tweeners: {
			"*": [function (t, e) {
				var i = this.createTween(t, e);
				return U(i.elem, t, Kt.exec(e), i), i
			}]
		},
		tweener: function (t, e) {
			C.isFunction(t) ? (e = t, t = ["*"]) : t = t.match(D);
			for (var i, n = 0, s = t.length; s > n; n++) i = t[n], u.tweeners[i] = u.tweeners[i] || [], u.tweeners[i].unshift(e)
		},
		prefilters: [pt],
		prefilter: function (t, e) {
			e ? u.prefilters.unshift(t) : u.prefilters.push(t)
		}
	}), C.speed = function (t, e, i) {
		var n = t && "object" == typeof t ? C.extend({}, t) : {
			complete: i || !i && e || C.isFunction(t) && t,
			duration: t,
			easing: i && e || e && !C.isFunction(e) && e
		};
		return n.duration = C.fx.off ? 0 : "number" == typeof n.duration ? n.duration : n.duration in C.fx.speeds ? C.fx.speeds[n.duration] : C.fx.speeds._default, null != n.queue && n.queue !== !0 || (n.queue = "fx"), n.old = n.complete, n.complete = function () {
			C.isFunction(n.old) && n.old.call(this), n.queue && C.dequeue(this, n.queue)
		}, n
	}, C.fn.extend({
		fadeTo: function (t, e, i, n) {
			return this.filter(x).css("opacity", 0).show().end().animate({
				opacity: e
			}, t, i, n)
		},
		animate: function (e, t, i, n) {
			var s = C.isEmptyObject(e),
				o = C.speed(t, i, n),
				r = function () {
					var t = u(this, C.extend({}, e), o);
					(s || C._data(this, "finish")) && t.stop(!0)
				};
			return r.finish = r, s || o.queue === !1 ? this.each(r) : this.queue(o.queue, r)
		},
		stop: function (s, t, o) {
			var r = function (t) {
				var e = t.stop;
				delete t.stop, e(o)
			};
			return "string" != typeof s && (o = t, t = s, s = void 0), t && s !== !1 && this.queue(s || "fx", []), this.each(function () {
				var t = !0,
					e = null != s && s + "queueHooks",
					i = C.timers,
					n = C._data(this);
				if (e) n[e] && n[e].stop && r(n[e]);
				else
					for (e in n) n[e] && n[e].stop && Ae.test(e) && r(n[e]);
				for (e = i.length; e--;) i[e].elem !== this || null != s && i[e].queue !== s || (i[e].anim.stop(o), t = !1, i.splice(e, 1));
				!t && o || C.dequeue(this, s)
			})
		},
		finish: function (r) {
			return r !== !1 && (r = r || "fx"), this.each(function () {
				var t, e = C._data(this),
					i = e[r + "queue"],
					n = e[r + "queueHooks"],
					s = C.timers,
					o = i ? i.length : 0;
				for (e.finish = !0, C.queue(this, r, []), n && n.stop && n.stop.call(this, !0), t = s.length; t--;) s[t].elem === this && s[t].queue === r && (s[t].anim.stop(!0), s.splice(t, 1));
				for (t = 0; o > t; t++) i[t] && i[t].finish && i[t].finish.call(this);
				delete e.finish
			})
		}
	}), C.each(["toggle", "show", "hide"], function (t, n) {
		var s = C.fn[n];
		C.fn[n] = function (t, e, i) {
			return null == t || "boolean" == typeof t ? s.apply(this, arguments) : this.animate(r(n, !0), t, e, i)
		}
	}), C.each({
		slideDown: r("show"),
		slideUp: r("hide"),
		slideToggle: r("toggle"),
		fadeIn: {
			opacity: "show"
		},
		fadeOut: {
			opacity: "hide"
		},
		fadeToggle: {
			opacity: "toggle"
		}
	}, function (t, n) {
		C.fn[t] = function (t, e, i) {
			return this.animate(n, t, e, i)
		}
	}), C.timers = [], C.fx.tick = function () {
		var t, e = C.timers,
			i = 0;
		for (I = C.now(); i < e.length; i++) t = e[i], t() || e[i] !== t || e.splice(i--, 1);
		e.length || C.fx.stop(), I = void 0
	}, C.fx.timer = function (t) {
		C.timers.push(t), t() ? C.fx.start() : C.timers.pop()
	}, C.fx.interval = 13, C.fx.start = function () {
		Ee || (Ee = k.setInterval(C.fx.tick, C.fx.interval))
	}, C.fx.stop = function () {
		k.clearInterval(Ee), Ee = null
	}, C.fx.speeds = {
		slow: 600,
		fast: 200,
		_default: 400
	}, C.fn.delay = function (n, t) {
		return n = C.fx ? C.fx.speeds[n] || n : n, t = t || "fx", this.queue(t, function (t, e) {
			var i = k.setTimeout(t, n);
			e.stop = function () {
				k.clearTimeout(i)
			}
		})
	},
		function () {
			var t, e = p.createElement("input"),
				i = p.createElement("div"),
				n = p.createElement("select"),
				s = n.appendChild(p.createElement("option"));
			i = p.createElement("div"), i.setAttribute("className", "t"), i.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", t = i.getElementsByTagName("a")[0], e.setAttribute("type", "checkbox"), i.appendChild(e), t = i.getElementsByTagName("a")[0], t.style.cssText = "top:1px", _.getSetAttribute = "t" !== i.className, _.style = /top/.test(t.getAttribute("style")), _.hrefNormalized = "/a" === t.getAttribute("href"), _.checkOn = !!e.value, _.optSelected = s.selected, _.enctype = !!p.createElement("form").enctype, n.disabled = !0, _.optDisabled = !s.disabled, e = p.createElement("input"), e.setAttribute("value", ""), _.input = "" === e.getAttribute("value"), e.value = "t", e.setAttribute("type", "radio"), _.radioValue = "t" === e.value
		}();
	var Le = /\r/g,
		Ne = /[\x20\t\r\n\f]+/g;
	C.fn.extend({
		val: function (i) {
			var n, t, s, e = this[0];
			return arguments.length ? (s = C.isFunction(i), this.each(function (t) {
				var e;
				1 === this.nodeType && (e = s ? i.call(this, t, C(this).val()) : i, null == e ? e = "" : "number" == typeof e ? e += "" : C.isArray(e) && (e = C.map(e, function (t) {
					return null == t ? "" : t + ""
				})), n = C.valHooks[this.type] || C.valHooks[this.nodeName.toLowerCase()], n && "set" in n && void 0 !== n.set(this, e, "value") || (this.value = e))
			})) : e ? (n = C.valHooks[e.type] || C.valHooks[e.nodeName.toLowerCase()], n && "get" in n && void 0 !== (t = n.get(e, "value")) ? t : (t = e.value, "string" == typeof t ? t.replace(Le, "") : null == t ? "" : t)) : void 0
		}
	}), C.extend({
		valHooks: {
			option: {
				get: function (t) {
					var e = C.find.attr(t, "value");
					return null != e ? e : C.trim(C.text(t)).replace(Ne, " ")
				}
			},
			select: {
				get: function (t) {
					for (var e, i, n = t.options, s = t.selectedIndex, o = "select-one" === t.type || 0 > s, r = o ? null : [], a = o ? s + 1 : n.length, l = 0 > s ? a : o ? s : 0; a > l; l++)
						if (i = n[l], (i.selected || l === s) && (_.optDisabled ? !i.disabled : null === i.getAttribute("disabled")) && (!i.parentNode.disabled || !C.nodeName(i.parentNode, "optgroup"))) {
							if (e = C(i).val(), o) return e;
							r.push(e)
						}
					return r
				},
				set: function (t, e) {
					for (var i, n, s = t.options, o = C.makeArray(e), r = s.length; r--;)
						if (n = s[r], C.inArray(C.valHooks.option.get(n), o) > -1) try {
							n.selected = i = !0
						} catch (t) {
							n.scrollHeight
						} else n.selected = !1;
					return i || (t.selectedIndex = -1), s
				}
			}
		}
	}), C.each(["radio", "checkbox"], function () {
		C.valHooks[this] = {
			set: function (t, e) {
				return C.isArray(e) ? t.checked = C.inArray(C(t).val(), e) > -1 : void 0
			}
		}, _.checkOn || (C.valHooks[this].get = function (t) {
			return null === t.getAttribute("value") ? "on" : t.value
		})
	});
	var E, Re, O = C.expr.attrHandle,
		Fe = /^(?:checked|selected)$/i,
		A = _.getSetAttribute,
		He = _.input;
	C.fn.extend({
		attr: function (t, e) {
			return w(this, C.attr, t, e, arguments.length > 1)
		},
		removeAttr: function (t) {
			return this.each(function () {
				C.removeAttr(this, t)
			})
		}
	}), C.extend({
		attr: function (t, e, i) {
			var n, s, o = t.nodeType;
			return 3 !== o && 8 !== o && 2 !== o ? "undefined" == typeof t.getAttribute ? C.prop(t, e, i) : (1 === o && C.isXMLDoc(t) || (e = e.toLowerCase(), s = C.attrHooks[e] || (C.expr.match.bool.test(e) ? Re : E)), void 0 !== i ? null === i ? void C.removeAttr(t, e) : s && "set" in s && void 0 !== (n = s.set(t, i, e)) ? n : (t.setAttribute(e, i + ""), i) : s && "get" in s && null !== (n = s.get(t, e)) ? n : (n = C.find.attr(t, e), null == n ? void 0 : n)) : void 0
		},
		attrHooks: {
			type: {
				set: function (t, e) {
					if (!_.radioValue && "radio" === e && C.nodeName(t, "input")) {
						var i = t.value;
						return t.setAttribute("type", e), i && (t.value = i), e
					}
				}
			}
		},
		removeAttr: function (t, e) {
			var i, n, s = 0,
				o = e && e.match(D);
			if (o && 1 === t.nodeType)
				for (; i = o[s++];) n = C.propFix[i] || i, C.expr.match.bool.test(i) ? He && A || !Fe.test(i) ? t[n] = !1 : t[C.camelCase("default-" + i)] = t[n] = !1 : C.attr(t, i, ""), t.removeAttribute(A ? i : n)
		}
	}), Re = {
		set: function (t, e, i) {
			return e === !1 ? C.removeAttr(t, i) : He && A || !Fe.test(i) ? t.setAttribute(!A && C.propFix[i] || i, i) : t[C.camelCase("default-" + i)] = t[i] = !0, i
		}
	}, C.each(C.expr.match.bool.source.match(/\w+/g), function (t, e) {
		var o = O[e] || C.find.attr;
		He && A || !Fe.test(e) ? O[e] = function (t, e, i) {
			var n, s;
			return i || (s = O[e], O[e] = n, n = null != o(t, e, i) ? e.toLowerCase() : null, O[e] = s), n
		} : O[e] = function (t, e, i) {
			return i ? void 0 : t[C.camelCase("default-" + e)] ? e.toLowerCase() : null
		}
	}), He && A || (C.attrHooks.value = {
		set: function (t, e, i) {
			return C.nodeName(t, "input") ? void (t.defaultValue = e) : E && E.set(t, e, i)
		}
	}), A || (E = {
		set: function (t, e, i) {
			var n = t.getAttributeNode(i);
			return n || t.setAttributeNode(n = t.ownerDocument.createAttribute(i)), n.value = e += "", "value" === i || e === t.getAttribute(i) ? e : void 0
		}
	}, O.id = O.name = O.coords = function (t, e, i) {
		var n;
		return i ? void 0 : (n = t.getAttributeNode(e)) && "" !== n.value ? n.value : null
	}, C.valHooks.button = {
		get: function (t, e) {
			var i = t.getAttributeNode(e);
			return i && i.specified ? i.value : void 0
		},
		set: E.set
	}, C.attrHooks.contenteditable = {
		set: function (t, e, i) {
			E.set(t, "" === e ? !1 : e, i)
		}
	}, C.each(["width", "height"], function (t, i) {
		C.attrHooks[i] = {
			set: function (t, e) {
				return "" === e ? (t.setAttribute(i, "auto"), e) : void 0
			}
		}
	})), _.style || (C.attrHooks.style = {
		get: function (t) {
			return t.style.cssText || void 0
		},
		set: function (t, e) {
			return t.style.cssText = e + ""
		}
	});
	var ze = /^(?:input|select|textarea|button|object)$/i,
		We = /^(?:a|area)$/i;
	C.fn.extend({
		prop: function (t, e) {
			return w(this, C.prop, t, e, arguments.length > 1)
		},
		removeProp: function (t) {
			return t = C.propFix[t] || t, this.each(function () {
				try {
					this[t] = void 0, delete this[t]
				} catch (t) { }
			})
		}
	}), C.extend({
		prop: function (t, e, i) {
			var n, s, o = t.nodeType;
			return 3 !== o && 8 !== o && 2 !== o ? (1 === o && C.isXMLDoc(t) || (e = C.propFix[e] || e, s = C.propHooks[e]), void 0 !== i ? s && "set" in s && void 0 !== (n = s.set(t, i, e)) ? n : t[e] = i : s && "get" in s && null !== (n = s.get(t, e)) ? n : t[e]) : void 0
		},
		propHooks: {
			tabIndex: {
				get: function (t) {
					var e = C.find.attr(t, "tabindex");
					return e ? parseInt(e, 10) : ze.test(t.nodeName) || We.test(t.nodeName) && t.href ? 0 : -1
				}
			}
		},
		propFix: {
			for: "htmlFor",
			class: "className"
		}
	}), _.hrefNormalized || C.each(["href", "src"], function (t, e) {
		C.propHooks[e] = {
			get: function (t) {
				return t.getAttribute(e, 4)
			}
		}
	}), _.optSelected || (C.propHooks.selected = {
		get: function (t) {
			var e = t.parentNode;
			return e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex), null
		},
		set: function (t) {
			var e = t.parentNode;
			e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
		}
	}), C.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		C.propFix[this.toLowerCase()] = this
	}), _.enctype || (C.propFix.enctype = "encoding");
	var Be = /[\t\r\n\f]/g;
	C.fn.extend({
		addClass: function (e) {
			var t, i, n, s, o, r, a, l = 0;
			if (C.isFunction(e)) return this.each(function (t) {
				C(this).addClass(e.call(this, t, h(this)))
			});
			if ("string" == typeof e && e)
				for (t = e.match(D) || []; i = this[l++];)
					if (s = h(i), n = 1 === i.nodeType && (" " + s + " ").replace(Be, " ")) {
						for (r = 0; o = t[r++];) n.indexOf(" " + o + " ") < 0 && (n += o + " ");
						a = C.trim(n), s !== a && C.attr(i, "class", a)
					}
			return this
		},
		removeClass: function (e) {
			var t, i, n, s, o, r, a, l = 0;
			if (C.isFunction(e)) return this.each(function (t) {
				C(this).removeClass(e.call(this, t, h(this)))
			});
			if (!arguments.length) return this.attr("class", "");
			if ("string" == typeof e && e)
				for (t = e.match(D) || []; i = this[l++];)
					if (s = h(i), n = 1 === i.nodeType && (" " + s + " ").replace(Be, " ")) {
						for (r = 0; o = t[r++];)
							for (; n.indexOf(" " + o + " ") > -1;) n = n.replace(" " + o + " ", " ");
						a = C.trim(n), s !== a && C.attr(i, "class", a)
					}
			return this
		},
		toggleClass: function (s, e) {
			var o = typeof s;
			return "boolean" == typeof e && "string" === o ? e ? this.addClass(s) : this.removeClass(s) : C.isFunction(s) ? this.each(function (t) {
				C(this).toggleClass(s.call(this, t, h(this), e), e)
			}) : this.each(function () {
				var t, e, i, n;
				if ("string" === o)
					for (e = 0, i = C(this), n = s.match(D) || []; t = n[e++];) i.hasClass(t) ? i.removeClass(t) : i.addClass(t);
				else void 0 !== s && "boolean" !== o || (t = h(this), t && C._data(this, "__className__", t), C.attr(this, "class", t || s === !1 ? "" : C._data(this, "__className__") || ""))
			})
		},
		hasClass: function (t) {
			var e, i, n = 0;
			for (e = " " + t + " "; i = this[n++];)
				if (1 === i.nodeType && (" " + h(i) + " ").replace(Be, " ").indexOf(e) > -1) return !0;
			return !1
		}
	}), C.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (t, i) {
		C.fn[i] = function (t, e) {
			return arguments.length > 0 ? this.on(i, null, t, e) : this.trigger(i)
		}
	}), C.fn.extend({
		hover: function (t, e) {
			return this.mouseenter(t).mouseleave(e || t)
		}
	});
	var je = k.location,
		Ye = C.now(),
		Ve = /\?/,
		$e = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
	C.parseJSON = function (t) {
		if (k.JSON && k.JSON.parse) return k.JSON.parse(t + "");
		var s, o = null,
			e = C.trim(t + "");
		return e && !C.trim(e.replace($e, function (t, e, i, n) {
			return s && e && (o = 0), 0 === o ? t : (s = i || e, o += !n - !i, "")
		})) ? Function("return " + e)() : C.error("Invalid JSON: " + t)
	}, C.parseXML = function (t) {
		var e, i;
		if (!t || "string" != typeof t) return null;
		try {
			k.DOMParser ? (i = new k.DOMParser, e = i.parseFromString(t, "text/xml")) : (e = new k.ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(t))
		} catch (t) {
			e = void 0
		}
		return e && e.documentElement && !e.getElementsByTagName("parsererror").length || C.error("Invalid XML: " + t), e
	};
	var Ue = /#.*$/,
		qe = /([?&])_=[^&]*/,
		Ge = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
		Ke = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		Xe = /^(?:GET|HEAD)$/,
		Ze = /^\/\//,
		Qe = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
		Je = {},
		ti = {},
		ei = "*/".concat("*"),
		ii = je.href,
		L = Qe.exec(ii.toLowerCase()) || [];
	C.extend({
		active: 0,
		lastModified: {},
		etag: {},
		ajaxSettings: {
			url: ii,
			type: "GET",
			isLocal: Ke.test(L[1]),
			global: !0,
			processData: !0,
			async: !0,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			accepts: {
				"*": ei,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
			converters: {
				"* text": String,
				"text html": !0,
				"text json": C.parseJSON,
				"text xml": C.parseXML
			},
			flatOptions: {
				url: !0,
				context: !0
			}
		},
		ajaxSetup: function (t, e) {
			return e ? bt(bt(t, C.ajaxSettings), e) : bt(C.ajaxSettings, t)
		},
		ajaxPrefilter: mt(Je),
		ajaxTransport: mt(ti),
		ajax: function (t, e) {
			function i(t, e, i, n) {
				var s, o, r, a, l, h = e;
				2 !== x && (x = 2, d && k.clearTimeout(d), p = void 0, u = n || "", w.readyState = t > 0 ? 4 : 0, s = t >= 200 && 300 > t || 304 === t, i && (a = _t(g, w, i)), a = yt(g, a, w, s), s ? (g.ifModified && (l = w.getResponseHeader("Last-Modified"), l && (C.lastModified[c] = l), l = w.getResponseHeader("etag"), l && (C.etag[c] = l)), 204 === t || "HEAD" === g.type ? h = "nocontent" : 304 === t ? h = "notmodified" : (h = a.state, o = a.data, r = a.error, s = !r)) : (r = h, !t && h || (h = "error", 0 > t && (t = 0))), w.status = t, w.statusText = (e || h) + "", s ? b.resolveWith(m, [o, h, w]) : b.rejectWith(m, [w, h, r]), w.statusCode(y), y = void 0, f && v.trigger(s ? "ajaxSuccess" : "ajaxError", [w, g, s ? o : r]), _.fireWith(m, [w, h]), f && (v.trigger("ajaxComplete", [w, g]), --C.active || C.event.trigger("ajaxStop")))
			}
			"object" == typeof t && (e = t, t = void 0), e = e || {};
			var n, s, c, u, d, f, p, o, g = C.ajaxSetup({}, e),
				m = g.context || g,
				v = g.context && (m.nodeType || m.jquery) ? C(m) : C.event,
				b = C.Deferred(),
				_ = C.Callbacks("once memory"),
				y = g.statusCode || {},
				r = {},
				a = {},
				x = 0,
				l = "canceled",
				w = {
					readyState: 0,
					getResponseHeader: function (t) {
						var e;
						if (2 === x) {
							if (!o)
								for (o = {}; e = Ge.exec(u);) o[e[1].toLowerCase()] = e[2];
							e = o[t.toLowerCase()]
						}
						return null == e ? null : e
					},
					getAllResponseHeaders: function () {
						return 2 === x ? u : null
					},
					setRequestHeader: function (t, e) {
						var i = t.toLowerCase();
						return x || (t = a[i] = a[i] || t, r[t] = e), this
					},
					overrideMimeType: function (t) {
						return x || (g.mimeType = t), this
					},
					statusCode: function (t) {
						var e;
						if (t)
							if (2 > x)
								for (e in t) y[e] = [y[e], t[e]];
							else w.always(t[w.status]);
						return this
					},
					abort: function (t) {
						var e = t || l;
						return p && p.abort(e), i(0, e), this
					}
				};
			if (b.promise(w).complete = _.add, w.success = w.done, w.error = w.fail, g.url = ((t || g.url || ii) + "").replace(Ue, "").replace(Ze, L[1] + "//"), g.type = e.method || e.type || g.method || g.type, g.dataTypes = C.trim(g.dataType || "*").toLowerCase().match(D) || [""], null == g.crossDomain && (n = Qe.exec(g.url.toLowerCase()), g.crossDomain = !(!n || n[1] === L[1] && n[2] === L[2] && (n[3] || ("http:" === n[1] ? "80" : "443")) === (L[3] || ("http:" === L[1] ? "80" : "443")))), g.data && g.processData && "string" != typeof g.data && (g.data = C.param(g.data, g.traditional)), vt(Je, g, e, w), 2 === x) return w;
			f = C.event && g.global, f && 0 === C.active++ && C.event.trigger("ajaxStart"), g.type = g.type.toUpperCase(), g.hasContent = !Xe.test(g.type), c = g.url, g.hasContent || (g.data && (c = g.url += (Ve.test(c) ? "&" : "?") + g.data, delete g.data), g.cache === !1 && (g.url = qe.test(c) ? c.replace(qe, "$1_=" + Ye++) : c + (Ve.test(c) ? "&" : "?") + "_=" + Ye++)), g.ifModified && (C.lastModified[c] && w.setRequestHeader("If-Modified-Since", C.lastModified[c]), C.etag[c] && w.setRequestHeader("If-None-Match", C.etag[c])), (g.data && g.hasContent && g.contentType !== !1 || e.contentType) && w.setRequestHeader("Content-Type", g.contentType), w.setRequestHeader("Accept", g.dataTypes[0] && g.accepts[g.dataTypes[0]] ? g.accepts[g.dataTypes[0]] + ("*" !== g.dataTypes[0] ? ", " + ei + "; q=0.01" : "") : g.accepts["*"]);
			for (s in g.headers) w.setRequestHeader(s, g.headers[s]);
			if (g.beforeSend && (g.beforeSend.call(m, w, g) === !1 || 2 === x)) return w.abort();
			l = "abort";
			for (s in {
				success: 1,
				error: 1,
				complete: 1
			}) w[s](g[s]);
			if (p = vt(ti, g, e, w)) {
				if (w.readyState = 1, f && v.trigger("ajaxSend", [w, g]), 2 === x) return w;
				g.async && g.timeout > 0 && (d = k.setTimeout(function () {
					w.abort("timeout")
				}, g.timeout));
				try {
					x = 1, p.send(r, i)
				} catch (t) {
					if (!(2 > x)) throw t;
					i(-1, t)
				}
			} else i(-1, "No Transport");
			return w
		},
		getJSON: function (t, e, i) {
			return C.get(t, e, i, "json")
		},
		getScript: function (t, e) {
			return C.get(t, void 0, e, "script")
		}
	}), C.each(["get", "post"], function (t, s) {
		C[s] = function (t, e, i, n) {
			return C.isFunction(e) && (n = n || i, i = e, e = void 0), C.ajax(C.extend({
				url: t,
				type: s,
				dataType: n,
				data: e,
				success: i
			}, C.isPlainObject(t) && t))
		}
	}), C._evalUrl = function (t) {
		return C.ajax({
			url: t,
			type: "GET",
			dataType: "script",
			cache: !0,
			async: !1,
			global: !1,
			throws: !0
		})
	}, C.fn.extend({
		wrapAll: function (e) {
			if (C.isFunction(e)) return this.each(function (t) {
				C(this).wrapAll(e.call(this, t))
			});
			if (this[0]) {
				var t = C(e, this[0].ownerDocument).eq(0).clone(!0);
				this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
					for (var t = this; t.firstChild && 1 === t.firstChild.nodeType;) t = t.firstChild;
					return t
				}).append(this)
			}
			return this
		},
		wrapInner: function (i) {
			return C.isFunction(i) ? this.each(function (t) {
				C(this).wrapInner(i.call(this, t))
			}) : this.each(function () {
				var t = C(this),
					e = t.contents();
				e.length ? e.wrapAll(i) : t.append(i)
			})
		},
		wrap: function (e) {
			var i = C.isFunction(e);
			return this.each(function (t) {
				C(this).wrapAll(i ? e.call(this, t) : e)
			})
		},
		unwrap: function () {
			return this.parent().each(function () {
				C.nodeName(this, "body") || C(this).replaceWith(this.childNodes)
			}).end()
		}
	}), C.expr.filters.hidden = function (t) {
		return _.reliableHiddenOffsets() ? t.offsetWidth <= 0 && t.offsetHeight <= 0 && !t.getClientRects().length : wt(t)
	}, C.expr.filters.visible = function (t) {
		return !C.expr.filters.hidden(t)
	};
	var ni = /%20/g,
		si = /\[\]$/,
		oi = /\r?\n/g,
		ri = /^(?:submit|button|image|reset|file)$/i,
		ai = /^(?:input|select|textarea|keygen)/i;
	C.param = function (t, e) {
		var i, n = [],
			s = function (t, e) {
				e = C.isFunction(e) ? e() : null == e ? "" : e, n[n.length] = encodeURIComponent(t) + "=" + encodeURIComponent(e)
			};
		if (void 0 === e && (e = C.ajaxSettings && C.ajaxSettings.traditional), C.isArray(t) || t.jquery && !C.isPlainObject(t)) C.each(t, function () {
			s(this.name, this.value)
		});
		else
			for (i in t) kt(i, t[i], e, s);
		return n.join("&").replace(ni, "+")
	}, C.fn.extend({
		serialize: function () {
			return C.param(this.serializeArray())
		},
		serializeArray: function () {
			return this.map(function () {
				var t = C.prop(this, "elements");
				return t ? C.makeArray(t) : this
			}).filter(function () {
				var t = this.type;
				return this.name && !C(this).is(":disabled") && ai.test(this.nodeName) && !ri.test(t) && (this.checked || !Xt.test(t))
			}).map(function (t, e) {
				var i = C(this).val();
				return null == i ? null : C.isArray(i) ? C.map(i, function (t) {
					return {
						name: e.name,
						value: t.replace(oi, "\r\n")
					}
				}) : {
					name: e.name,
					value: i.replace(oi, "\r\n")
				}
			}).get()
		}
	}), C.ajaxSettings.xhr = void 0 !== k.ActiveXObject ? function () {
		return this.isLocal ? Dt() : p.documentMode > 8 ? Ct() : /^(get|post|head|put|delete|options)$/i.test(this.type) && Ct() || Dt()
	} : Ct;
	var li = 0,
		hi = {},
		N = C.ajaxSettings.xhr();
	k.attachEvent && k.attachEvent("onunload", function () {
		for (var t in hi) hi[t](void 0, !0)
	}), _.cors = !!N && "withCredentials" in N, N = _.ajax = !!N, N && C.ajaxTransport(function (l) {
		if (!l.crossDomain || _.cors) {
			var h;
			return {
				send: function (t, o) {
					var e, r = l.xhr(),
						a = ++li;
					if (r.open(l.type, l.url, l.async, l.username, l.password), l.xhrFields)
						for (e in l.xhrFields) r[e] = l.xhrFields[e];
					l.mimeType && r.overrideMimeType && r.overrideMimeType(l.mimeType), l.crossDomain || t["X-Requested-With"] || (t["X-Requested-With"] = "XMLHttpRequest");
					for (e in t) void 0 !== t[e] && r.setRequestHeader(e, t[e] + "");
					r.send(l.hasContent && l.data || null), h = function (t, e) {
						var i, n, s;
						if (h && (e || 4 === r.readyState))
							if (delete hi[a], h = void 0, r.onreadystatechange = C.noop, e) 4 !== r.readyState && r.abort();
							else {
								s = {}, i = r.status, "string" == typeof r.responseText && (s.text = r.responseText);
								try {
									n = r.statusText
								} catch (t) {
									n = ""
								}
								i || !l.isLocal || l.crossDomain ? 1223 === i && (i = 204) : i = s.text ? 200 : 404
							}
						s && o(i, n, s, r.getAllResponseHeaders())
					}, l.async ? 4 === r.readyState ? k.setTimeout(h) : r.onreadystatechange = hi[a] = h : h()
				},
				abort: function () {
					h && h(void 0, !0)
				}
			}
		}
	}), C.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function (t) {
				return C.globalEval(t), t
			}
		}
	}), C.ajaxPrefilter("script", function (t) {
		void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET", t.global = !1)
	}), C.ajaxTransport("script", function (e) {
		if (e.crossDomain) {
			var n, s = p.head || C("head")[0] || p.documentElement;
			return {
				send: function (t, i) {
					n = p.createElement("script"), n.async = !0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (t, e) {
						(e || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), n = null, e || i(200, "success"))
					}, s.insertBefore(n, s.firstChild)
				},
				abort: function () {
					n && n.onload(void 0, !0)
				}
			}
		}
	});
	var ci = [],
		ui = /(=)\?(?=&|$)|\?\?/;
	C.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var t = ci.pop() || C.expando + "_" + Ye++;
			return this[t] = !0, t
		}
	}), C.ajaxPrefilter("json jsonp", function (t, e, i) {
		var n, s, o, r = t.jsonp !== !1 && (ui.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && ui.test(t.data) && "data");
		return r || "jsonp" === t.dataTypes[0] ? (n = t.jsonpCallback = C.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, r ? t[r] = t[r].replace(ui, "$1" + n) : t.jsonp !== !1 && (t.url += (Ve.test(t.url) ? "&" : "?") + t.jsonp + "=" + n), t.converters["script json"] = function () {
			return o || C.error(n + " was not called"), o[0]
		}, t.dataTypes[0] = "json", s = k[n], k[n] = function () {
			o = arguments
		}, i.always(function () {
			void 0 === s ? C(k).removeProp(n) : k[n] = s, t[n] && (t.jsonpCallback = e.jsonpCallback, ci.push(n)), o && C.isFunction(s) && s(o[0]), o = s = void 0
		}), "script") : void 0
	}), C.parseHTML = function (t, e, i) {
		if (!t || "string" != typeof t) return null;
		"boolean" == typeof e && (i = e, e = !1), e = e || p;
		var n = Ht.exec(t),
			s = !i && [];
		return n ? [e.createElement(n[1])] : (n = X([t], e, s), s && s.length && C(s).remove(), C.merge([], n.childNodes))
	};
	var di = C.fn.load;
	C.fn.load = function (t, e, i) {
		if ("string" != typeof t && di) return di.apply(this, arguments);
		var n, s, o, r = this,
			a = t.indexOf(" ");
		return a > -1 && (n = C.trim(t.slice(a, t.length)), t = t.slice(0, a)), C.isFunction(e) ? (i = e, e = void 0) : e && "object" == typeof e && (s = "POST"), r.length > 0 && C.ajax({
			url: t,
			type: s || "GET",
			dataType: "html",
			data: e
		}).done(function (t) {
			o = arguments, r.html(n ? C("<div>").append(C.parseHTML(t)).find(n) : t)
		}).always(i && function (t, e) {
			r.each(function () {
				i.apply(this, o || [t.responseText, e, t])
			})
		}), this
	}, C.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (t, e) {
		C.fn[e] = function (t) {
			return this.on(e, t)
		}
	}), C.expr.filters.animated = function (e) {
		return C.grep(C.timers, function (t) {
			return e === t.elem
		}).length
	}, C.offset = {
		setOffset: function (t, e, i) {
			var n, s, o, r, a, l, h, c = C.css(t, "position"),
				u = C(t),
				d = {};
			"static" === c && (t.style.position = "relative"), a = u.offset(), o = C.css(t, "top"), l = C.css(t, "left"), h = ("absolute" === c || "fixed" === c) && C.inArray("auto", [o, l]) > -1, h ? (n = u.position(), r = n.top, s = n.left) : (r = parseFloat(o) || 0, s = parseFloat(l) || 0), C.isFunction(e) && (e = e.call(t, i, C.extend({}, a))), null != e.top && (d.top = e.top - a.top + r), null != e.left && (d.left = e.left - a.left + s), "using" in e ? e.using.call(t, d) : u.css(d)
		}
	}, C.fn.extend({
		offset: function (e) {
			if (arguments.length) return void 0 === e ? this : this.each(function (t) {
				C.offset.setOffset(this, e, t)
			});
			var t, i, n = {
				top: 0,
				left: 0
			},
				s = this[0],
				o = s && s.ownerDocument;
			return o ? (t = o.documentElement, C.contains(t, s) ? ("undefined" != typeof s.getBoundingClientRect && (n = s.getBoundingClientRect()), i = Mt(o), {
				top: n.top + (i.pageYOffset || t.scrollTop) - (t.clientTop || 0),
				left: n.left + (i.pageXOffset || t.scrollLeft) - (t.clientLeft || 0)
			}) : n) : void 0
		},
		position: function () {
			if (this[0]) {
				var t, e, i = {
					top: 0,
					left: 0
				},
					n = this[0];
				return "fixed" === C.css(n, "position") ? e = n.getBoundingClientRect() : (t = this.offsetParent(), e = this.offset(), C.nodeName(t[0], "html") || (i = t.offset()), i.top += C.css(t[0], "borderTopWidth", !0), i.left += C.css(t[0], "borderLeftWidth", !0)), {
					top: e.top - i.top - C.css(n, "marginTop", !0),
					left: e.left - i.left - C.css(n, "marginLeft", !0)
				}
			}
		},
		offsetParent: function () {
			return this.map(function () {
				for (var t = this.offsetParent; t && !C.nodeName(t, "html") && "static" === C.css(t, "position");) t = t.offsetParent;
				return t || xe
			})
		}
	}), C.each({
		scrollLeft: "pageXOffset",
		scrollTop: "pageYOffset"
	}, function (e, s) {
		var o = /Y/.test(s);
		C.fn[e] = function (t) {
			return w(this, function (t, e, i) {
				var n = Mt(t);
				return void 0 === i ? n ? s in n ? n[s] : n.document.documentElement[e] : t[e] : void (n ? n.scrollTo(o ? C(n).scrollLeft() : i, o ? i : C(n).scrollTop()) : t[e] = i)
			}, e, t, arguments.length, null)
		}
	}), C.each(["top", "left"], function (t, i) {
		C.cssHooks[i] = rt(_.pixelPosition, function (t, e) {
			return e ? (e = P(t, i), _e.test(e) ? C(t).position()[i] + "px" : e) : void 0
		})
	}), C.each({
		Height: "height",
		Width: "width"
	}, function (o, r) {
		C.each({
			padding: "inner" + o,
			content: r,
			"": "outer" + o
		}, function (n, t) {
			C.fn[t] = function (t, e) {
				var i = arguments.length && (n || "boolean" != typeof t),
					s = n || (t === !0 || e === !0 ? "margin" : "border");
				return w(this, function (t, e, i) {
					var n;
					return C.isWindow(t) ? t.document.documentElement["client" + o] : 9 === t.nodeType ? (n = t.documentElement, Math.max(t.body["scroll" + o], n["scroll" + o], t.body["offset" + o], n["offset" + o], n["client" + o])) : void 0 === i ? C.css(t, e, s) : C.style(t, e, i, s)
				}, r, i ? t : void 0, i, null)
			}
		})
	}), C.fn.extend({
		bind: function (t, e, i) {
			return this.on(t, null, e, i)
		},
		unbind: function (t, e) {
			return this.off(t, null, e)
		},
		delegate: function (t, e, i, n) {
			return this.on(e, t, i, n)
		},
		undelegate: function (t, e, i) {
			return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", i)
		}
	}), C.fn.size = function () {
		return this.length
	}, C.fn.andSelf = C.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
		return C
	});
	var fi = k.jQuery,
		pi = k.$;
	return C.noConflict = function (t) {
		return k.$ === C && (k.$ = pi), t && k.jQuery === C && (k.jQuery = fi), C
	}, R || (k.jQuery = k.$ = C), C
});
! function (t) {
	"use strict";
	"function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery)
}(function (q) {
	"use strict";

	function w(t, e, i) {
		return [parseFloat(t[0]) * (f.test(t[0]) ? e / 100 : 1), parseFloat(t[1]) * (f.test(t[1]) ? i / 100 : 1)]
	}

	function k(t, e) {
		return parseInt(q.css(t, e), 10) || 0
	}

	function s(t) {
		return null != t && t === t.window
	}

	function h(t) {
		return null == t ? t + "" : "object" == typeof t ? g[$.call(t)] || "object" : typeof t
	}

	function c(t, e, i) {
		var n = K[e.type] || {};
		return null == t ? i || !e.def ? null : e.def : (t = n.floor ? ~~t : parseFloat(t), isNaN(t) ? e.def : n.mod ? (t + n.mod) % n.mod : Math.min(n.max, Math.max(0, t)))
	}

	function a(n) {
		var s = m(),
			o = s._rgba = [];
		return n = n.toLowerCase(), b(G, function (t, e) {
			var i = e.re.exec(n),
				i = i && e.parse(i),
				e = e.space || "rgba";
			if (i) return i = s[e](i), s[v[e].cache] = i[v[e].cache], o = s._rgba = i._rgba, !1
		}), o.length ? ("0,0,0,0" === o.join() && p.extend(o, y.transparent), s) : y[n]
	}

	function o(t, e, i) {
		return 6 * (i = (i + 1) % 1) < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
	}

	function r(t) {
		var e, i, n = t.ownerDocument.defaultView ? t.ownerDocument.defaultView.getComputedStyle(t, null) : t.currentStyle,
			s = {};
		if (n && n.length && n[0] && n[n[0]])
			for (i = n.length; i--;) "string" == typeof n[e = n[i]] && (s[e.replace(/-([\da-z])/gi, function (t, e) {
				return e.toUpperCase()
			})] = n[e]);
		else
			for (e in n) "string" == typeof n[e] && (s[e] = n[e]);
		return s
	}

	function u(t, e, i, n) {
		return t = {
			effect: t = q.isPlainObject(t) ? (e = t).effect : t
		}, "function" == typeof (e = null == e ? {} : e) && (n = e, i = null, e = {}), "number" != typeof e && !q.fx.speeds[e] || (n = i, i = e, e = {}), "function" == typeof i && (n = i, i = null), e && q.extend(t, e), i = i || e.duration, t.duration = q.fx.off ? 0 : "number" == typeof i ? i : i in q.fx.speeds ? q.fx.speeds[i] : q.fx.speeds._default, t.complete = n || e.complete, t
	}

	function e(t) {
		return !t || "number" == typeof t || q.fx.speeds[t] || "string" == typeof t && !q.effects.effect[t] || "function" == typeof t || "object" == typeof t && !t.effect
	}

	function i(t, e) {
		var i = e.outerWidth(),
			e = e.outerHeight(),
			t = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/.exec(t) || ["", 0, i, e, 0];
		return {
			top: parseFloat(t[1]) || 0,
			right: "auto" === t[2] ? i : parseFloat(t[2]),
			bottom: "auto" === t[3] ? e : parseFloat(t[3]),
			left: parseFloat(t[4]) || 0
		}
	}

	function N() {
		this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
			closeText: "Done",
			prevText: "Prev",
			nextText: "Next",
			currentText: "Today",
			monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
			weekHeader: "Wk",
			dateFormat: "mm/dd/yy",
			firstDay: 0,
			isRTL: !1,
			showMonthAfterYear: !1,
			yearSuffix: "",
			selectMonthLabel: "Select month",
			selectYearLabel: "Select year"
		}, this._defaults = {
			showOn: "focus",
			showAnim: "fadeIn",
			showOptions: {},
			defaultDate: null,
			appendText: "",
			buttonText: "...",
			buttonImage: "",
			buttonImageOnly: !1,
			hideIfNoPrevNext: !1,
			navigationAsDateFormat: !1,
			gotoCurrent: !1,
			changeMonth: !1,
			changeYear: !1,
			yearRange: "c-10:c+10",
			showOtherMonths: !1,
			selectOtherMonths: !1,
			showWeek: !1,
			calculateWeek: this.iso8601Week,
			shortYearCutoff: "+10",
			minDate: null,
			maxDate: null,
			duration: "fast",
			beforeShowDay: null,
			beforeShow: null,
			onSelect: null,
			onChangeMonthYear: null,
			onClose: null,
			onUpdateDatepicker: null,
			numberOfMonths: 1,
			showCurrentAtPos: 0,
			stepMonths: 1,
			stepBigMonths: 12,
			altField: "",
			altFormat: "",
			constrainInput: !0,
			showButtonPanel: !1,
			autoSize: !1,
			disabled: !1
		}, q.extend(this._defaults, this.regional[""]), this.regional.en = q.extend(!0, {}, this.regional[""]), this.regional["en-US"] = q.extend(!0, {}, this.regional.en), this.dpDiv = R(q("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
	}

	function R(t) {
		var e = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
		return t.on("mouseout", e, function () {
			q(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && q(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && q(this).removeClass("ui-datepicker-next-hover")
		}).on("mouseover", e, F)
	}

	function F() {
		q.datepicker._isDisabledDatepicker((O.inline ? O.dpDiv.parent() : O.input)[0]) || (q(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), q(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && q(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && q(this).addClass("ui-datepicker-next-hover"))
	}

	function l(t, e) {
		for (var i in q.extend(t, e), e) null == e[i] && (t[i] = e[i]);
		return t
	}

	function H(t, e, i) {
		return e <= t && t < e + i
	}

	function n(e) {
		return function () {
			var t = this.element.val();
			e.apply(this, arguments), this._refresh(), t !== this.element.val() && this._trigger("change")
		}
	}
	q.ui = q.ui || {}, q.ui.version = "1.13.2";
	var z, W = 0,
		B = Array.prototype.hasOwnProperty,
		j = Array.prototype.slice;
	q.cleanData = (z = q.cleanData, function (t) {
		for (var e, i, n = 0; null != (i = t[n]); n++)(e = q._data(i, "events")) && e.remove && q(i).triggerHandler("remove");
		z(t)
	}), q.widget = function (t, i, e) {
		var n, s, o, r = {},
			a = t.split(".")[0],
			l = a + "-" + (t = t.split(".")[1]);
		return e || (e = i, i = q.Widget), Array.isArray(e) && (e = q.extend.apply(null, [{}].concat(e))), q.expr.pseudos[l.toLowerCase()] = function (t) {
			return !!q.data(t, l)
		}, q[a] = q[a] || {}, n = q[a][t], s = q[a][t] = function (t, e) {
			if (!this || !this._createWidget) return new s(t, e);
			arguments.length && this._createWidget(t, e)
		}, q.extend(s, n, {
			version: e.version,
			_proto: q.extend({}, e),
			_childConstructors: []
		}), (o = new i).options = q.widget.extend({}, o.options), q.each(e, function (e, n) {
			function s() {
				return i.prototype[e].apply(this, arguments)
			}

			function o(t) {
				return i.prototype[e].apply(this, t)
			}
			r[e] = "function" == typeof n ? function () {
				var t, e = this._super,
					i = this._superApply;
				return this._super = s, this._superApply = o, t = n.apply(this, arguments), this._super = e, this._superApply = i, t
			} : n
		}), s.prototype = q.widget.extend(o, {
			widgetEventPrefix: n && o.widgetEventPrefix || t
		}, r, {
			constructor: s,
			namespace: a,
			widgetName: t,
			widgetFullName: l
		}), n ? (q.each(n._childConstructors, function (t, e) {
			var i = e.prototype;
			q.widget(i.namespace + "." + i.widgetName, s, e._proto)
		}), delete n._childConstructors) : i._childConstructors.push(s), q.widget.bridge(t, s), s
	}, q.widget.extend = function (t) {
		for (var e, i, n = j.call(arguments, 1), s = 0, o = n.length; s < o; s++)
			for (e in n[s]) i = n[s][e], B.call(n[s], e) && void 0 !== i && (q.isPlainObject(i) ? t[e] = q.isPlainObject(t[e]) ? q.widget.extend({}, t[e], i) : q.widget.extend({}, i) : t[e] = i);
		return t
	}, q.widget.bridge = function (o, e) {
		var r = e.prototype.widgetFullName || o;
		q.fn[o] = function (i) {
			var t = "string" == typeof i,
				n = j.call(arguments, 1),
				s = this;
			return t ? this.length || "instance" !== i ? this.each(function () {
				var t, e = q.data(this, r);
				return "instance" === i ? (s = e, !1) : e ? "function" != typeof e[i] || "_" === i.charAt(0) ? q.error("no such method '" + i + "' for " + o + " widget instance") : (t = e[i].apply(e, n)) !== e && void 0 !== t ? (s = t && t.jquery ? s.pushStack(t.get()) : t, !1) : void 0 : q.error("cannot call methods on " + o + " prior to initialization; attempted to call method '" + i + "'")
			}) : s = void 0 : (n.length && (i = q.widget.extend.apply(null, [i].concat(n))), this.each(function () {
				var t = q.data(this, r);
				t ? (t.option(i || {}), t._init && t._init()) : q.data(this, r, new e(i, this))
			})), s
		}
	}, q.Widget = function () { }, q.Widget._childConstructors = [], q.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",
		options: {
			classes: {},
			disabled: !1,
			create: null
		},
		_createWidget: function (t, e) {
			e = q(e || this.defaultElement || this)[0], this.element = q(e), this.uuid = W++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = q(), this.hoverable = q(), this.focusable = q(), this.classesElementLookup = {}, e !== this && (q.data(e, this.widgetFullName, this), this._on(!0, this.element, {
				remove: function (t) {
					t.target === e && this.destroy()
				}
			}), this.document = q(e.style ? e.ownerDocument : e.document || e), this.window = q(this.document[0].defaultView || this.document[0].parentWindow)), this.options = q.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init()
		},
		_getCreateOptions: function () {
			return {}
		},
		_getCreateEventData: q.noop,
		_create: q.noop,
		_init: q.noop,
		destroy: function () {
			var i = this;
			this._destroy(), q.each(this.classesElementLookup, function (t, e) {
				i._removeClass(e, t)
			}), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace)
		},
		_destroy: q.noop,
		widget: function () {
			return this.element
		},
		option: function (t, e) {
			var i, n, s, o = t;
			if (0 === arguments.length) return q.widget.extend({}, this.options);
			if ("string" == typeof t)
				if (o = {}, t = (i = t.split(".")).shift(), i.length) {
					for (n = o[t] = q.widget.extend({}, this.options[t]), s = 0; s < i.length - 1; s++) n[i[s]] = n[i[s]] || {}, n = n[i[s]];
					if (t = i.pop(), 1 === arguments.length) return void 0 === n[t] ? null : n[t];
					n[t] = e
				} else {
					if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
					o[t] = e
				}
			return this._setOptions(o), this
		},
		_setOptions: function (t) {
			for (var e in t) this._setOption(e, t[e]);
			return this
		},
		_setOption: function (t, e) {
			return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this
		},
		_setOptionClasses: function (t) {
			var e, i, n;
			for (e in t) n = this.classesElementLookup[e], t[e] !== this.options.classes[e] && n && n.length && (i = q(n.get()), this._removeClass(n, e), i.addClass(this._classes({
				element: i,
				keys: e,
				classes: t,
				add: !0
			})))
		},
		_setOptionDisabled: function (t) {
			this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"))
		},
		enable: function () {
			return this._setOptions({
				disabled: !1
			})
		},
		disable: function () {
			return this._setOptions({
				disabled: !0
			})
		},
		_classes: function (s) {
			function t(t, e) {
				for (var i, n = 0; n < t.length; n++) i = r.classesElementLookup[t[n]] || q(), i = s.add ? (function () {
					var i = [];
					s.element.each(function (t, e) {
						q.map(r.classesElementLookup, function (t) {
							return t
						}).some(function (t) {
							return t.is(e)
						}) || i.push(e)
					}), r._on(q(i), {
						remove: "_untrackClassesElement"
					})
				}(), q(q.uniqueSort(i.get().concat(s.element.get())))) : q(i.not(s.element).get()), r.classesElementLookup[t[n]] = i, o.push(t[n]), e && s.classes[t[n]] && o.push(s.classes[t[n]])
			}
			var o = [],
				r = this;
			return (s = q.extend({
				element: this.element,
				classes: this.options.classes || {}
			}, s)).keys && t(s.keys.match(/\S+/g) || [], !0), s.extra && t(s.extra.match(/\S+/g) || []), o.join(" ")
		},
		_untrackClassesElement: function (i) {
			var n = this;
			q.each(n.classesElementLookup, function (t, e) {
				-1 !== q.inArray(i.target, e) && (n.classesElementLookup[t] = q(e.not(i.target).get()))
			}), this._off(q(i.target))
		},
		_removeClass: function (t, e, i) {
			return this._toggleClass(t, e, i, !1)
		},
		_addClass: function (t, e, i) {
			return this._toggleClass(t, e, i, !0)
		},
		_toggleClass: function (t, e, i, n) {
			var s = "string" == typeof t || null === t,
				i = {
					extra: s ? e : i,
					keys: s ? t : e,
					element: s ? this.element : t,
					add: n = "boolean" == typeof n ? n : i
				};
			return i.element.toggleClass(this._classes(i), n), this
		},
		_on: function (s, o, t) {
			var r, a = this;
			"boolean" != typeof s && (t = o, o = s, s = !1), t ? (o = r = q(o), this.bindings = this.bindings.add(o)) : (t = o, o = this.element, r = this.widget()), q.each(t, function (t, e) {
				function i() {
					if (s || !0 !== a.options.disabled && !q(this).hasClass("ui-state-disabled")) return ("string" == typeof e ? a[e] : e).apply(a, arguments)
				}
				"string" != typeof e && (i.guid = e.guid = e.guid || i.guid || q.guid++);
				var n = t.match(/^([\w:-]*)\s*(.*)$/),
					t = n[1] + a.eventNamespace,
					n = n[2];
				n ? r.on(t, n, i) : o.on(t, i)
			})
		},
		_off: function (t, e) {
			e = (e || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.off(e), this.bindings = q(this.bindings.not(t).get()), this.focusable = q(this.focusable.not(t).get()), this.hoverable = q(this.hoverable.not(t).get())
		},
		_delay: function (t, e) {
			var i = this;
			return setTimeout(function () {
				return ("string" == typeof t ? i[t] : t).apply(i, arguments)
			}, e || 0)
		},
		_hoverable: function (t) {
			this.hoverable = this.hoverable.add(t), this._on(t, {
				mouseenter: function (t) {
					this._addClass(q(t.currentTarget), null, "ui-state-hover")
				},
				mouseleave: function (t) {
					this._removeClass(q(t.currentTarget), null, "ui-state-hover")
				}
			})
		},
		_focusable: function (t) {
			this.focusable = this.focusable.add(t), this._on(t, {
				focusin: function (t) {
					this._addClass(q(t.currentTarget), null, "ui-state-focus")
				},
				focusout: function (t) {
					this._removeClass(q(t.currentTarget), null, "ui-state-focus")
				}
			})
		},
		_trigger: function (t, e, i) {
			var n, s, o = this.options[t];
			if (i = i || {}, (e = q.Event(e)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), e.target = this.element[0], s = e.originalEvent)
				for (n in s) n in e || (e[n] = s[n]);
			return this.element.trigger(e, i), !("function" == typeof o && !1 === o.apply(this.element[0], [e].concat(i)) || e.isDefaultPrevented())
		}
	}, q.each({
		show: "fadeIn",
		hide: "fadeOut"
	}, function (o, r) {
		q.Widget.prototype["_" + o] = function (e, t, i) {
			var n, s = (t = "string" == typeof t ? {
				effect: t
			} : t) ? !0 !== t && "number" != typeof t && t.effect || r : o;
			"number" == typeof (t = t || {}) ? t = {
				duration: t
			} : !0 === t && (t = {}), n = !q.isEmptyObject(t), t.complete = i, t.delay && e.delay(t.delay), n && q.effects && q.effects.effect[s] ? e[o](t) : s !== o && e[s] ? e[s](t.duration, t.easing, i) : e.queue(function (t) {
				q(this)[o](), i && i.call(e[0]), t()
			})
		}
	});
	var d, C, D, M, T, S, P, f, Y;
	q.widget, C = Math.max, D = Math.abs, M = /left|center|right/, T = /top|center|bottom/, S = /[\+\-]\d+(\.[\d]+)?%?/, P = /^\w+/, f = /%$/, Y = q.fn.position, q.position = {
		scrollbarWidth: function () {
			if (void 0 !== d) return d;
			var t, e = q("<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'></div></div>"),
				i = e.children()[0];
			return q("body").append(e), t = i.offsetWidth, e.css("overflow", "scroll"), t === (i = i.offsetWidth) && (i = e[0].clientWidth), e.remove(), d = t - i
		},
		getScrollInfo: function (t) {
			var e = t.isWindow || t.isDocument ? "" : t.element.css("overflow-x"),
				i = t.isWindow || t.isDocument ? "" : t.element.css("overflow-y"),
				e = "scroll" === e || "auto" === e && t.width < t.element[0].scrollWidth;
			return {
				width: "scroll" === i || "auto" === i && t.height < t.element[0].scrollHeight ? q.position.scrollbarWidth() : 0,
				height: e ? q.position.scrollbarWidth() : 0
			}
		},
		getWithinInfo: function (t) {
			var e = q(t || window),
				i = s(e[0]),
				n = !!e[0] && 9 === e[0].nodeType;
			return {
				element: e,
				isWindow: i,
				isDocument: n,
				offset: i || n ? {
					left: 0,
					top: 0
				} : q(t).offset(),
				scrollLeft: e.scrollLeft(),
				scrollTop: e.scrollTop(),
				width: e.outerWidth(),
				height: e.outerHeight()
			}
		}
	}, q.fn.position = function (u) {
		if (!u || !u.of) return Y.apply(this, arguments);
		var d, f, p, g, m, t, v = "string" == typeof (u = q.extend({}, u)).of ? q(document).find(u.of) : q(u.of),
			b = q.position.getWithinInfo(u.within),
			_ = q.position.getScrollInfo(b),
			y = (u.collision || "flip").split(" "),
			x = {},
			e = 9 === (t = (e = v)[0]).nodeType ? {
				width: e.width(),
				height: e.height(),
				offset: {
					top: 0,
					left: 0
				}
			} : s(t) ? {
				width: e.width(),
				height: e.height(),
				offset: {
					top: e.scrollTop(),
					left: e.scrollLeft()
				}
			} : t.preventDefault ? {
				width: 0,
				height: 0,
				offset: {
					top: t.pageY,
					left: t.pageX
				}
			} : {
				width: e.outerWidth(),
				height: e.outerHeight(),
				offset: e.offset()
			};
		return v[0].preventDefault && (u.at = "left top"), f = e.width, p = e.height, m = q.extend({}, g = e.offset), q.each(["my", "at"], function () {
			var t, e, i = (u[this] || "").split(" ");
			(i = 1 === i.length ? M.test(i[0]) ? i.concat(["center"]) : T.test(i[0]) ? ["center"].concat(i) : ["center", "center"] : i)[0] = M.test(i[0]) ? i[0] : "center", i[1] = T.test(i[1]) ? i[1] : "center", t = S.exec(i[0]), e = S.exec(i[1]), x[this] = [t ? t[0] : 0, e ? e[0] : 0], u[this] = [P.exec(i[0])[0], P.exec(i[1])[0]]
		}), 1 === y.length && (y[1] = y[0]), "right" === u.at[0] ? m.left += f : "center" === u.at[0] && (m.left += f / 2), "bottom" === u.at[1] ? m.top += p : "center" === u.at[1] && (m.top += p / 2), d = w(x.at, f, p), m.left += d[0], m.top += d[1], this.each(function () {
			var i, t, r = q(this),
				a = r.outerWidth(),
				l = r.outerHeight(),
				e = k(this, "marginLeft"),
				n = k(this, "marginTop"),
				s = a + e + k(this, "marginRight") + _.width,
				o = l + n + k(this, "marginBottom") + _.height,
				h = q.extend({}, m),
				c = w(x.my, r.outerWidth(), r.outerHeight());
			"right" === u.my[0] ? h.left -= a : "center" === u.my[0] && (h.left -= a / 2), "bottom" === u.my[1] ? h.top -= l : "center" === u.my[1] && (h.top -= l / 2), h.left += c[0], h.top += c[1], i = {
				marginLeft: e,
				marginTop: n
			}, q.each(["left", "top"], function (t, e) {
				q.ui.position[y[t]] && q.ui.position[y[t]][e](h, {
					targetWidth: f,
					targetHeight: p,
					elemWidth: a,
					elemHeight: l,
					collisionPosition: i,
					collisionWidth: s,
					collisionHeight: o,
					offset: [d[0] + c[0], d[1] + c[1]],
					my: u.my,
					at: u.at,
					within: b,
					elem: r
				})
			}), u.using && (t = function (t) {
				var e = g.left - h.left,
					i = e + f - a,
					n = g.top - h.top,
					s = n + p - l,
					o = {
						target: {
							element: v,
							left: g.left,
							top: g.top,
							width: f,
							height: p
						},
						element: {
							element: r,
							left: h.left,
							top: h.top,
							width: a,
							height: l
						},
						horizontal: i < 0 ? "left" : 0 < e ? "right" : "center",
						vertical: s < 0 ? "top" : 0 < n ? "bottom" : "middle"
					};
				f < a && D(e + i) < f && (o.horizontal = "center"), p < l && D(n + s) < p && (o.vertical = "middle"), C(D(e), D(i)) > C(D(n), D(s)) ? o.important = "horizontal" : o.important = "vertical", u.using.call(this, t, o)
			}), r.offset(q.extend(h, {
				using: t
			}))
		})
	}, q.ui.position = {
		fit: {
			left: function (t, e) {
				var i = e.within,
					n = i.isWindow ? i.scrollLeft : i.offset.left,
					s = i.width,
					o = t.left - e.collisionPosition.marginLeft,
					r = n - o,
					a = o + e.collisionWidth - s - n;
				e.collisionWidth > s ? 0 < r && a <= 0 ? (i = t.left + r + e.collisionWidth - s - n, t.left += r - i) : t.left = !(0 < a && r <= 0) && a < r ? n + s - e.collisionWidth : n : 0 < r ? t.left += r : 0 < a ? t.left -= a : t.left = C(t.left - o, t.left)
			},
			top: function (t, e) {
				var i = e.within,
					n = i.isWindow ? i.scrollTop : i.offset.top,
					s = e.within.height,
					o = t.top - e.collisionPosition.marginTop,
					r = n - o,
					a = o + e.collisionHeight - s - n;
				e.collisionHeight > s ? 0 < r && a <= 0 ? (i = t.top + r + e.collisionHeight - s - n, t.top += r - i) : t.top = !(0 < a && r <= 0) && a < r ? n + s - e.collisionHeight : n : 0 < r ? t.top += r : 0 < a ? t.top -= a : t.top = C(t.top - o, t.top)
			}
		},
		flip: {
			left: function (t, e) {
				var i = e.within,
					n = i.offset.left + i.scrollLeft,
					s = i.width,
					o = i.isWindow ? i.scrollLeft : i.offset.left,
					r = t.left - e.collisionPosition.marginLeft,
					a = r - o,
					l = r + e.collisionWidth - s - o,
					h = "left" === e.my[0] ? -e.elemWidth : "right" === e.my[0] ? e.elemWidth : 0,
					i = "left" === e.at[0] ? e.targetWidth : "right" === e.at[0] ? -e.targetWidth : 0,
					r = -2 * e.offset[0];
				a < 0 ? ((n = t.left + h + i + r + e.collisionWidth - s - n) < 0 || n < D(a)) && (t.left += h + i + r) : 0 < l && (0 < (o = t.left - e.collisionPosition.marginLeft + h + i + r - o) || D(o) < l) && (t.left += h + i + r)
			},
			top: function (t, e) {
				var i = e.within,
					n = i.offset.top + i.scrollTop,
					s = i.height,
					o = i.isWindow ? i.scrollTop : i.offset.top,
					r = t.top - e.collisionPosition.marginTop,
					a = r - o,
					l = r + e.collisionHeight - s - o,
					h = "top" === e.my[1] ? -e.elemHeight : "bottom" === e.my[1] ? e.elemHeight : 0,
					i = "top" === e.at[1] ? e.targetHeight : "bottom" === e.at[1] ? -e.targetHeight : 0,
					r = -2 * e.offset[1];
				a < 0 ? ((n = t.top + h + i + r + e.collisionHeight - s - n) < 0 || n < D(a)) && (t.top += h + i + r) : 0 < l && (0 < (o = t.top - e.collisionPosition.marginTop + h + i + r - o) || D(o) < l) && (t.top += h + i + r)
			}
		},
		flipfit: {
			left: function () {
				q.ui.position.flip.left.apply(this, arguments), q.ui.position.fit.left.apply(this, arguments)
			},
			top: function () {
				q.ui.position.flip.top.apply(this, arguments), q.ui.position.fit.top.apply(this, arguments)
			}
		}
	}, q.ui.position, q.extend(q.expr.pseudos, {
		data: q.expr.createPseudo ? q.expr.createPseudo(function (e) {
			return function (t) {
				return !!q.data(t, e)
			}
		}) : function (t, e, i) {
			return !!q.data(t, i[3])
		}
	}), q.fn.extend({
		disableSelection: (V = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown", function () {
			return this.on(V + ".ui-disableSelection", function (t) {
				t.preventDefault()
			})
		}),
		enableSelection: function () {
			return this.off(".ui-disableSelection")
		}
	});
	var V, p = q,
		g = {},
		$ = g.toString,
		U = /^([\-+])=\s*(\d+\.?\d*)/,
		G = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function (t) {
				return [t[1], t[2], t[3], t[4]]
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function (t) {
				return [2.55 * t[1], 2.55 * t[2], 2.55 * t[3], t[4]]
			}
		}, {
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/,
			parse: function (t) {
				return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16), t[4] ? (parseInt(t[4], 16) / 255).toFixed(2) : 1]
			}
		}, {
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/,
			parse: function (t) {
				return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16), t[4] ? (parseInt(t[4] + t[4], 16) / 255).toFixed(2) : 1]
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function (t) {
				return [t[1], t[2] / 100, t[3] / 100, t[4]]
			}
		}],
		m = p.Color = function (t, e, i, n) {
			return new p.Color.fn.parse(t, e, i, n)
		},
		v = {
			rgba: {
				props: {
					red: {
						idx: 0,
						type: "byte"
					},
					green: {
						idx: 1,
						type: "byte"
					},
					blue: {
						idx: 2,
						type: "byte"
					}
				}
			},
			hsla: {
				props: {
					hue: {
						idx: 0,
						type: "degrees"
					},
					saturation: {
						idx: 1,
						type: "percent"
					},
					lightness: {
						idx: 2,
						type: "percent"
					}
				}
			}
		},
		K = {
			byte: {
				floor: !0,
				max: 255
			},
			percent: {
				max: 1
			},
			degrees: {
				mod: 360,
				floor: !0
			}
		},
		X = m.support = {},
		t = p("<p>")[0],
		b = p.each;
	t.style.cssText = "background-color:rgba(1,1,1,.5)", X.rgba = -1 < t.style.backgroundColor.indexOf("rgba"), b(v, function (t, e) {
		e.cache = "_" + t, e.props.alpha = {
			idx: 3,
			type: "percent",
			def: 1
		}
	}), p.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (t, e) {
		g["[object " + e + "]"] = e.toLowerCase()
	}), (m.fn = p.extend(m.prototype, {
		parse: function (s, t, e, i) {
			if (void 0 === s) return this._rgba = [null, null, null, null], this;
			(s.jquery || s.nodeType) && (s = p(s).css(t), t = void 0);
			var o = this,
				n = h(s),
				r = this._rgba = [];
			return void 0 !== t && (s = [s, t, e, i], n = "array"), "string" === n ? this.parse(a(s) || y._default) : "array" === n ? (b(v.rgba.props, function (t, e) {
				r[e.idx] = c(s[e.idx], e)
			}), this) : "object" === n ? (b(v, s instanceof m ? function (t, e) {
				s[e.cache] && (o[e.cache] = s[e.cache].slice())
			} : function (t, i) {
				var n = i.cache;
				b(i.props, function (t, e) {
					if (!o[n] && i.to) {
						if ("alpha" === t || null == s[t]) return;
						o[n] = i.to(o._rgba)
					}
					o[n][e.idx] = c(s[t], e, !0)
				}), o[n] && p.inArray(null, o[n].slice(0, 3)) < 0 && (null == o[n][3] && (o[n][3] = 1), i.from && (o._rgba = i.from(o[n])))
			}), this) : void 0
		},
		is: function (t) {
			var s = m(t),
				o = !0,
				r = this;
			return b(v, function (t, e) {
				var i, n = s[e.cache];
				return n && (i = r[e.cache] || e.to && e.to(r._rgba) || [], b(e.props, function (t, e) {
					if (null != n[e.idx]) return o = n[e.idx] === i[e.idx]
				})), o
			}), o
		},
		_space: function () {
			var i = [],
				n = this;
			return b(v, function (t, e) {
				n[e.cache] && i.push(t)
			}), i.pop()
		},
		transition: function (t, r) {
			var e = (h = m(t))._space(),
				i = v[e],
				t = 0 === this.alpha() ? m("transparent") : this,
				a = t[i.cache] || i.to(t._rgba),
				l = a.slice(),
				h = h[i.cache];
			return b(i.props, function (t, e) {
				var i = e.idx,
					n = a[i],
					s = h[i],
					o = K[e.type] || {};
				null !== s && (null === n ? l[i] = s : (o.mod && (s - n > o.mod / 2 ? n += o.mod : n - s > o.mod / 2 && (n -= o.mod)), l[i] = c((s - n) * r + n, e)))
			}), this[e](l)
		},
		blend: function (t) {
			if (1 === this._rgba[3]) return this;
			var e = this._rgba.slice(),
				i = e.pop(),
				n = m(t)._rgba;
			return m(p.map(e, function (t, e) {
				return (1 - i) * n[e] + i * t
			}))
		},
		toRgbaString: function () {
			var t = "rgba(",
				e = p.map(this._rgba, function (t, e) {
					return null != t ? t : 2 < e ? 1 : 0
				});
			return 1 === e[3] && (e.pop(), t = "rgb("), t + e.join() + ")"
		},
		toHslaString: function () {
			var t = "hsla(",
				e = p.map(this.hsla(), function (t, e) {
					return null == t && (t = 2 < e ? 1 : 0), t = e && e < 3 ? Math.round(100 * t) + "%" : t
				});
			return 1 === e[3] && (e.pop(), t = "hsl("), t + e.join() + ")"
		},
		toHexString: function (t) {
			var e = this._rgba.slice(),
				i = e.pop();
			return t && e.push(~~(255 * i)), "#" + p.map(e, function (t) {
				return 1 === (t = (t || 0).toString(16)).length ? "0" + t : t
			}).join("")
		},
		toString: function () {
			return 0 === this._rgba[3] ? "transparent" : this.toRgbaString()
		}
	})).parse.prototype = m.fn, v.hsla.to = function (t) {
		if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
		var e = t[0] / 255,
			i = t[1] / 255,
			n = t[2] / 255,
			s = t[3],
			o = Math.max(e, i, n),
			r = Math.min(e, i, n),
			a = o - r,
			l = o + r,
			t = .5 * l,
			i = r === o ? 0 : e === o ? 60 * (i - n) / a + 360 : i === o ? 60 * (n - e) / a + 120 : 60 * (e - i) / a + 240,
			l = 0 == a ? 0 : t <= .5 ? a / l : a / (2 - l);
		return [Math.round(i) % 360, l, t, null == s ? 1 : s]
	}, v.hsla.from = function (t) {
		if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
		var e = t[0] / 360,
			i = t[1],
			n = t[2],
			t = t[3],
			i = n <= .5 ? n * (1 + i) : n + i - n * i,
			n = 2 * n - i;
		return [Math.round(255 * o(n, i, e + 1 / 3)), Math.round(255 * o(n, i, e)), Math.round(255 * o(n, i, e - 1 / 3)), t]
	}, b(v, function (l, t) {
		var e = t.props,
			o = t.cache,
			r = t.to,
			a = t.from;
		m.fn[l] = function (t) {
			if (r && !this[o] && (this[o] = r(this._rgba)), void 0 === t) return this[o].slice();
			var i = h(t),
				n = "array" === i || "object" === i ? t : arguments,
				s = this[o].slice();
			return b(e, function (t, e) {
				t = n["object" === i ? t : e.idx], null == t && (t = s[e.idx]), s[e.idx] = c(t, e)
			}), a ? ((t = m(a(s)))[o] = s, t) : m(s)
		}, b(e, function (r, a) {
			m.fn[r] || (m.fn[r] = function (t) {
				var e, i = h(t),
					n = "alpha" === r ? this._hsla ? "hsla" : "rgba" : l,
					s = this[n](),
					o = s[a.idx];
				return "undefined" === i ? o : ("function" === i && (i = h(t = t.call(this, o))), null == t && a.empty ? this : ("string" === i && (e = U.exec(t)) && (t = o + parseFloat(e[2]) * ("+" === e[1] ? 1 : -1)), s[a.idx] = t, this[n](s)))
			})
		})
	}), (m.hook = function (t) {
		t = t.split(" "), b(t, function (t, o) {
			p.cssHooks[o] = {
				set: function (t, e) {
					var i, n, s = "";
					if ("transparent" !== e && ("string" !== h(e) || (i = a(e)))) {
						if (e = m(i || e), !X.rgba && 1 !== e._rgba[3]) {
							for (n = "backgroundColor" === o ? t.parentNode : t;
								("" === s || "transparent" === s) && n && n.style;) try {
									s = p.css(n, "backgroundColor"), n = n.parentNode
								} catch (t) { }
							e = e.blend(s && "transparent" !== s ? s : "_default")
						}
						e = e.toRgbaString()
					}
					try {
						t.style[o] = e
					} catch (t) { }
				}
			}, p.fx.step[o] = function (t) {
				t.colorInit || (t.start = m(t.elem, o), t.end = m(t.end), t.colorInit = !0), p.cssHooks[o].set(t.elem, t.start.transition(t.end, t.pos))
			}
		})
	})("backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor"), p.cssHooks.borderColor = {
		expand: function (i) {
			var n = {};
			return b(["Top", "Right", "Bottom", "Left"], function (t, e) {
				n["border" + e + "Color"] = i
			}), n
		}
	};
	var Z, Q, J, tt, et, it, nt, st, ot, _, y = p.Color.names = {
		aqua: "#00ffff",
		black: "#000000",
		blue: "#0000ff",
		fuchsia: "#ff00ff",
		gray: "#808080",
		green: "#008000",
		lime: "#00ff00",
		maroon: "#800000",
		navy: "#000080",
		olive: "#808000",
		purple: "#800080",
		red: "#ff0000",
		silver: "#c0c0c0",
		teal: "#008080",
		white: "#ffffff",
		yellow: "#ffff00",
		transparent: [null, null, null, 0],
		_default: "#ffffff"
	},
		x = "ui-effects-",
		I = "ui-effects-style",
		E = "ui-effects-animated";
	q.effects = {
		effect: {}
	}, tt = ["add", "remove", "toggle"], et = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	}, q.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (t, e) {
		q.fx.step[e] = function (t) {
			("none" !== t.end && !t.setAttr || 1 === t.pos && !t.setAttr) && (p.style(t.elem, e, t.end), t.setAttr = !0)
		}
	}), q.fn.addBack || (q.fn.addBack = function (t) {
		return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
	}), q.effects.animateClass = function (s, t, e, i) {
		var o = q.speed(t, e, i);
		return this.queue(function () {
			var i = q(this),
				t = i.attr("class") || "",
				e = (e = o.children ? i.find("*").addBack() : i).map(function () {
					return {
						el: q(this),
						start: r(this)
					}
				}),
				n = function () {
					q.each(tt, function (t, e) {
						s[e] && i[e + "Class"](s[e])
					})
				};
			n(), e = e.map(function () {
				return this.end = r(this.el[0]), this.diff = function (t, e) {
					var i, n, s = {};
					for (i in e) n = e[i], t[i] !== n && (et[i] || !q.fx.step[i] && isNaN(parseFloat(n)) || (s[i] = n));
					return s
				}(this.start, this.end), this
			}), i.attr("class", t), e = e.map(function () {
				var t = this,
					e = q.Deferred(),
					i = q.extend({}, o, {
						queue: !1,
						complete: function () {
							e.resolve(t)
						}
					});
				return this.el.animate(this.diff, i), e.promise()
			}), q.when.apply(q, e.get()).done(function () {
				n(), q.each(arguments, function () {
					var e = this.el;
					q.each(this.diff, function (t) {
						e.css(t, "")
					})
				}), o.complete.call(i[0])
			})
		})
	}, q.fn.extend({
		addClass: (J = q.fn.addClass, function (t, e, i, n) {
			return e ? q.effects.animateClass.call(this, {
				add: t
			}, e, i, n) : J.apply(this, arguments)
		}),
		removeClass: (Q = q.fn.removeClass, function (t, e, i, n) {
			return 1 < arguments.length ? q.effects.animateClass.call(this, {
				remove: t
			}, e, i, n) : Q.apply(this, arguments)
		}),
		toggleClass: (Z = q.fn.toggleClass, function (t, e, i, n, s) {
			return "boolean" == typeof e || void 0 === e ? i ? q.effects.animateClass.call(this, e ? {
				add: t
			} : {
				remove: t
			}, i, n, s) : Z.apply(this, arguments) : q.effects.animateClass.call(this, {
				toggle: t
			}, e, i, n)
		}),
		switchClass: function (t, e, i, n, s) {
			return q.effects.animateClass.call(this, {
				add: e,
				remove: t
			}, i, n, s)
		}
	}), q.expr && q.expr.pseudos && q.expr.pseudos.animated && (q.expr.pseudos.animated = (it = q.expr.pseudos.animated, function (t) {
		return !!q(t).data(E) || it(t)
	})), !1 !== q.uiBackCompat && q.extend(q.effects, {
		save: function (t, e) {
			for (var i = 0, n = e.length; i < n; i++) null !== e[i] && t.data(x + e[i], t[0].style[e[i]])
		},
		restore: function (t, e) {
			for (var i, n = 0, s = e.length; n < s; n++) null !== e[n] && (i = t.data(x + e[n]), t.css(e[n], i))
		},
		setMode: function (t, e) {
			return e = "toggle" === e ? t.is(":hidden") ? "show" : "hide" : e
		},
		createWrapper: function (i) {
			if (i.parent().is(".ui-effects-wrapper")) return i.parent();
			var n = {
				width: i.outerWidth(!0),
				height: i.outerHeight(!0),
				float: i.css("float")
			},
				t = q("<div></div>").addClass("ui-effects-wrapper").css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
				e = {
					width: i.width(),
					height: i.height()
				},
				s = document.activeElement;
			try {
				s.id
			} catch (t) {
				s = document.body
			}
			return i.wrap(t), i[0] !== s && !q.contains(i[0], s) || q(s).trigger("focus"), t = i.parent(), "static" === i.css("position") ? (t.css({
				position: "relative"
			}), i.css({
				position: "relative"
			})) : (q.extend(n, {
				position: i.css("position"),
				zIndex: i.css("z-index")
			}), q.each(["top", "left", "bottom", "right"], function (t, e) {
				n[e] = i.css(e), isNaN(parseInt(n[e], 10)) && (n[e] = "auto")
			}), i.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			})), i.css(e), t.css(n).show()
		},
		removeWrapper: function (t) {
			var e = document.activeElement;
			return t.parent().is(".ui-effects-wrapper") && (t.parent().replaceWith(t), t[0] !== e && !q.contains(t[0], e) || q(e).trigger("focus")), t
		}
	}), q.extend(q.effects, {
		version: "1.13.2",
		define: function (t, e, i) {
			return i || (i = e, e = "effect"), q.effects.effect[t] = i, q.effects.effect[t].mode = e, i
		},
		scaledDimensions: function (t, e, i) {
			if (0 === e) return {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};
			var n = "horizontal" !== i ? (e || 100) / 100 : 1,
				e = "vertical" !== i ? (e || 100) / 100 : 1;
			return {
				height: t.height() * e,
				width: t.width() * n,
				outerHeight: t.outerHeight() * e,
				outerWidth: t.outerWidth() * n
			}
		},
		clipToBox: function (t) {
			return {
				width: t.clip.right - t.clip.left,
				height: t.clip.bottom - t.clip.top,
				left: t.clip.left,
				top: t.clip.top
			}
		},
		unshift: function (t, e, i) {
			var n = t.queue();
			1 < e && n.splice.apply(n, [1, 0].concat(n.splice(e, i))), t.dequeue()
		},
		saveStyle: function (t) {
			t.data(I, t[0].style.cssText)
		},
		restoreStyle: function (t) {
			t[0].style.cssText = t.data(I) || "", t.removeData(I)
		},
		mode: function (t, e) {
			return t = t.is(":hidden"), "toggle" === e && (e = t ? "show" : "hide"), e = (t ? "hide" === e : "show" === e) ? "none" : e
		},
		getBaseline: function (t, e) {
			var i, n;
			switch (t[0]) {
				case "top":
					i = 0;
					break;
				case "middle":
					i = .5;
					break;
				case "bottom":
					i = 1;
					break;
				default:
					i = t[0] / e.height
			}
			switch (t[1]) {
				case "left":
					n = 0;
					break;
				case "center":
					n = .5;
					break;
				case "right":
					n = 1;
					break;
				default:
					n = t[1] / e.width
			}
			return {
				x: n,
				y: i
			}
		},
		createPlaceholder: function (t) {
			var e, i = t.css("position"),
				n = t.position();
			return t.css({
				marginTop: t.css("marginTop"),
				marginBottom: t.css("marginBottom"),
				marginLeft: t.css("marginLeft"),
				marginRight: t.css("marginRight")
			}).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()), /^(static|relative)/.test(i) && (i = "absolute", e = q("<" + t[0].nodeName + ">").insertAfter(t).css({
				display: /^(inline|ruby)/.test(t.css("display")) ? "inline-block" : "block",
				visibility: "hidden",
				marginTop: t.css("marginTop"),
				marginBottom: t.css("marginBottom"),
				marginLeft: t.css("marginLeft"),
				marginRight: t.css("marginRight"),
				float: t.css("float")
			}).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).addClass("ui-effects-placeholder"), t.data(x + "placeholder", e)), t.css({
				position: i,
				left: n.left,
				top: n.top
			}), e
		},
		removePlaceholder: function (t) {
			var e = x + "placeholder",
				i = t.data(e);
			i && (i.remove(), t.removeData(e))
		},
		cleanUp: function (t) {
			q.effects.restoreStyle(t), q.effects.removePlaceholder(t)
		},
		setTransition: function (n, t, s, o) {
			return o = o || {}, q.each(t, function (t, e) {
				var i = n.cssUnit(e);
				0 < i[0] && (o[e] = i[0] * s + i[1])
			}), o
		}
	}), q.fn.extend({
		effect: function () {
			function t(t) {
				var e = q(this),
					i = q.effects.mode(e, l) || o;
				e.data(E, !0), h.push(i), o && ("show" === i || i === o && "hide" === i) && e.show(), o && "none" === i || q.effects.saveStyle(e), "function" == typeof t && t()
			}

			function e(t) {
				function e() {
					"function" == typeof a && a.call(i[0]), "function" == typeof t && t()
				}
				var i = q(this);
				n.mode = h.shift(), !1 === q.uiBackCompat || o ? "none" === n.mode ? (i[l](), e()) : s.call(i[0], n, function () {
					i.removeData(E), q.effects.cleanUp(i), "hide" === n.mode && i.hide(), e()
				}) : (i.is(":hidden") ? "hide" === l : "show" === l) ? (i[l](), e()) : s.call(i[0], n, e)
			}
			var n = u.apply(this, arguments),
				s = q.effects.effect[n.effect],
				o = s.mode,
				i = n.queue,
				r = i || "fx",
				a = n.complete,
				l = n.mode,
				h = [];
			return q.fx.off || !s ? l ? this[l](n.duration, a) : this.each(function () {
				a && a.call(this)
			}) : !1 === i ? this.each(t).each(e) : this.queue(r, t).queue(r, e)
		},
		show: (ot = q.fn.show, function (t) {
			return e(t) ? ot.apply(this, arguments) : (t = u.apply(this, arguments), t.mode = "show", this.effect.call(this, t))
		}),
		hide: (st = q.fn.hide, function (t) {
			return e(t) ? st.apply(this, arguments) : (t = u.apply(this, arguments), t.mode = "hide", this.effect.call(this, t))
		}),
		toggle: (nt = q.fn.toggle, function (t) {
			return e(t) || "boolean" == typeof t ? nt.apply(this, arguments) : (t = u.apply(this, arguments), t.mode = "toggle", this.effect.call(this, t))
		}),
		cssUnit: function (t) {
			var i = this.css(t),
				n = [];
			return q.each(["em", "px", "%", "pt"], function (t, e) {
				0 < i.indexOf(e) && (n = [parseFloat(i), e])
			}), n
		},
		cssClip: function (t) {
			return t ? this.css("clip", "rect(" + t.top + "px " + t.right + "px " + t.bottom + "px " + t.left + "px)") : i(this.css("clip"), this)
		},
		transfer: function (t, e) {
			var i = q(this),
				n = q(t.to),
				s = "fixed" === n.css("position"),
				o = q("body"),
				r = s ? o.scrollTop() : 0,
				a = s ? o.scrollLeft() : 0,
				o = n.offset(),
				o = {
					top: o.top - r,
					left: o.left - a,
					height: n.innerHeight(),
					width: n.innerWidth()
				},
				n = i.offset(),
				l = q("<div class='ui-effects-transfer'></div>");
			l.appendTo("body").addClass(t.className).css({
				top: n.top - r,
				left: n.left - a,
				height: i.innerHeight(),
				width: i.innerWidth(),
				position: s ? "fixed" : "absolute"
			}).animate(o, t.duration, t.easing, function () {
				l.remove(), "function" == typeof e && e()
			})
		}
	}), q.fx.step.clip = function (t) {
		t.clipInit || (t.start = q(t.elem).cssClip(), "string" == typeof t.end && (t.end = i(t.end, t.elem)), t.clipInit = !0), q(t.elem).cssClip({
			top: t.pos * (t.end.top - t.start.top) + t.start.top,
			right: t.pos * (t.end.right - t.start.right) + t.start.right,
			bottom: t.pos * (t.end.bottom - t.start.bottom) + t.start.bottom,
			left: t.pos * (t.end.left - t.start.left) + t.start.left
		})
	}, _ = {}, q.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (e, t) {
		_[t] = function (t) {
			return Math.pow(t, e + 2)
		}
	}), q.extend(_, {
		Sine: function (t) {
			return 1 - Math.cos(t * Math.PI / 2)
		},
		Circ: function (t) {
			return 1 - Math.sqrt(1 - t * t)
		},
		Elastic: function (t) {
			return 0 === t || 1 === t ? t : -Math.pow(2, 8 * (t - 1)) * Math.sin((80 * (t - 1) - 7.5) * Math.PI / 15)
		},
		Back: function (t) {
			return t * t * (3 * t - 2)
		},
		Bounce: function (t) {
			for (var e, i = 4; t < ((e = Math.pow(2, --i)) - 1) / 11;);
			return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2)
		}
	}), q.each(_, function (t, e) {
		q.easing["easeIn" + t] = e, q.easing["easeOut" + t] = function (t) {
			return 1 - e(1 - t)
		}, q.easing["easeInOut" + t] = function (t) {
			return t < .5 ? e(2 * t) / 2 : 1 - e(-2 * t + 2) / 2
		}
	}), t = q.effects, q.effects.define("blind", "hide", function (t, e) {
		var i = {
			up: ["bottom", "top"],
			vertical: ["bottom", "top"],
			down: ["top", "bottom"],
			left: ["right", "left"],
			horizontal: ["right", "left"],
			right: ["left", "right"]
		},
			n = q(this),
			s = t.direction || "up",
			o = n.cssClip(),
			r = {
				clip: q.extend({}, o)
			},
			a = q.effects.createPlaceholder(n);
		r.clip[i[s][0]] = r.clip[i[s][1]], "show" === t.mode && (n.cssClip(r.clip), a && a.css(q.effects.clipToBox(r)), r.clip = o), a && a.animate(q.effects.clipToBox(r), t.duration, t.easing), n.animate(r, {
			queue: !1,
			duration: t.duration,
			easing: t.easing,
			complete: e
		})
	}), q.effects.define("bounce", function (t, e) {
		var i, n, s = q(this),
			o = t.mode,
			r = "hide" === o,
			a = "show" === o,
			l = t.direction || "up",
			h = t.distance,
			c = t.times || 5,
			o = 2 * c + (a || r ? 1 : 0),
			u = t.duration / o,
			d = t.easing,
			f = "up" === l || "down" === l ? "top" : "left",
			p = "up" === l || "left" === l,
			g = 0,
			t = s.queue().length;
		for (q.effects.createPlaceholder(s), l = s.css(f), h = h || s["top" == f ? "outerHeight" : "outerWidth"]() / 3, a && ((n = {
			opacity: 1
		})[f] = l, s.css("opacity", 0).css(f, p ? 2 * -h : 2 * h).animate(n, u, d)), r && (h /= Math.pow(2, c - 1)), (n = {})[f] = l; g < c; g++)(i = {})[f] = (p ? "-=" : "+=") + h, s.animate(i, u, d).animate(n, u, d), h = r ? 2 * h : h / 2;
		r && ((i = {
			opacity: 0
		})[f] = (p ? "-=" : "+=") + h, s.animate(i, u, d)), s.queue(e), q.effects.unshift(s, t, 1 + o)
	}), q.effects.define("clip", "hide", function (t, e) {
		var i = {},
			n = q(this),
			s = t.direction || "vertical",
			o = "both" === s,
			r = o || "horizontal" === s,
			o = o || "vertical" === s,
			s = n.cssClip();
		i.clip = {
			top: o ? (s.bottom - s.top) / 2 : s.top,
			right: r ? (s.right - s.left) / 2 : s.right,
			bottom: o ? (s.bottom - s.top) / 2 : s.bottom,
			left: r ? (s.right - s.left) / 2 : s.left
		}, q.effects.createPlaceholder(n), "show" === t.mode && (n.cssClip(i.clip), i.clip = s), n.animate(i, {
			queue: !1,
			duration: t.duration,
			easing: t.easing,
			complete: e
		})
	}), q.effects.define("drop", "hide", function (t, e) {
		var i = q(this),
			n = "show" === t.mode,
			s = t.direction || "left",
			o = "up" === s || "down" === s ? "top" : "left",
			r = "up" === s || "left" === s ? "-=" : "+=",
			a = "+=" == r ? "-=" : "+=",
			l = {
				opacity: 0
			};
		q.effects.createPlaceholder(i), s = t.distance || i["top" == o ? "outerHeight" : "outerWidth"](!0) / 2, l[o] = r + s, n && (i.css(l), l[o] = a + s, l.opacity = 1), i.animate(l, {
			queue: !1,
			duration: t.duration,
			easing: t.easing,
			complete: e
		})
	}), q.effects.define("explode", "hide", function (t, e) {
		function i() {
			m.push(this), m.length === h * c && (u.css({
				visibility: "visible"
			}), q(m).remove(), e())
		}
		var n, s, o, r, a, l, h = t.pieces ? Math.round(Math.sqrt(t.pieces)) : 3,
			c = h,
			u = q(this),
			d = "show" === t.mode,
			f = u.show().css("visibility", "hidden").offset(),
			p = Math.ceil(u.outerWidth() / c),
			g = Math.ceil(u.outerHeight() / h),
			m = [];
		for (n = 0; n < h; n++)
			for (r = f.top + n * g, l = n - (h - 1) / 2, s = 0; s < c; s++) o = f.left + s * p, a = s - (c - 1) / 2, u.clone().appendTo("body").wrap("<div></div>").css({
				position: "absolute",
				visibility: "visible",
				left: -s * p,
				top: -n * g
			}).parent().addClass("ui-effects-explode").css({
				position: "absolute",
				overflow: "hidden",
				width: p,
				height: g,
				left: o + (d ? a * p : 0),
				top: r + (d ? l * g : 0),
				opacity: d ? 0 : 1
			}).animate({
				left: o + (d ? 0 : a * p),
				top: r + (d ? 0 : l * g),
				opacity: d ? 1 : 0
			}, t.duration || 500, t.easing, i)
	}), q.effects.define("fade", "toggle", function (t, e) {
		var i = "show" === t.mode;
		q(this).css("opacity", i ? 0 : 1).animate({
			opacity: i ? 1 : 0
		}, {
			queue: !1,
			duration: t.duration,
			easing: t.easing,
			complete: e
		})
	}), q.effects.define("fold", "hide", function (e, t) {
		var i = q(this),
			n = e.mode,
			s = "show" === n,
			o = "hide" === n,
			r = e.size || 15,
			a = /([0-9]+)%/.exec(r),
			l = e.horizFirst ? ["right", "bottom"] : ["bottom", "right"],
			h = e.duration / 2,
			c = q.effects.createPlaceholder(i),
			u = i.cssClip(),
			d = {
				clip: q.extend({}, u)
			},
			f = {
				clip: q.extend({}, u)
			},
			p = [u[l[0]], u[l[1]]],
			n = i.queue().length;
		a && (r = parseInt(a[1], 10) / 100 * p[o ? 0 : 1]), d.clip[l[0]] = r, f.clip[l[0]] = r, f.clip[l[1]] = 0, s && (i.cssClip(f.clip), c && c.css(q.effects.clipToBox(f)), f.clip = u), i.queue(function (t) {
			c && c.animate(q.effects.clipToBox(d), h, e.easing).animate(q.effects.clipToBox(f), h, e.easing), t()
		}).animate(d, h, e.easing).animate(f, h, e.easing).queue(t), q.effects.unshift(i, n, 4)
	}), q.effects.define("highlight", "show", function (t, e) {
		var i = q(this),
			n = {
				backgroundColor: i.css("backgroundColor")
			};
		"hide" === t.mode && (n.opacity = 0), q.effects.saveStyle(i), i.css({
			backgroundImage: "none",
			backgroundColor: t.color || "#ffff99"
		}).animate(n, {
			queue: !1,
			duration: t.duration,
			easing: t.easing,
			complete: e
		})
	}), q.effects.define("size", function (n, e) {
		var s, i = q(this),
			t = ["fontSize"],
			o = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
			r = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
			a = n.mode,
			l = "effect" !== a,
			h = n.scale || "both",
			c = n.origin || ["middle", "center"],
			u = i.css("position"),
			d = i.position(),
			f = q.effects.scaledDimensions(i),
			p = n.from || f,
			g = n.to || q.effects.scaledDimensions(i, 0);
		q.effects.createPlaceholder(i), "show" === a && (a = p, p = g, g = a), s = {
			from: {
				y: p.height / f.height,
				x: p.width / f.width
			},
			to: {
				y: g.height / f.height,
				x: g.width / f.width
			}
		}, "box" !== h && "both" !== h || (s.from.y !== s.to.y && (p = q.effects.setTransition(i, o, s.from.y, p), g = q.effects.setTransition(i, o, s.to.y, g)), s.from.x !== s.to.x && (p = q.effects.setTransition(i, r, s.from.x, p), g = q.effects.setTransition(i, r, s.to.x, g))), "content" !== h && "both" !== h || s.from.y !== s.to.y && (p = q.effects.setTransition(i, t, s.from.y, p), g = q.effects.setTransition(i, t, s.to.y, g)), c && (c = q.effects.getBaseline(c, f), p.top = (f.outerHeight - p.outerHeight) * c.y + d.top, p.left = (f.outerWidth - p.outerWidth) * c.x + d.left, g.top = (f.outerHeight - g.outerHeight) * c.y + d.top, g.left = (f.outerWidth - g.outerWidth) * c.x + d.left), delete p.outerHeight, delete p.outerWidth, i.css(p), "content" !== h && "both" !== h || (o = o.concat(["marginTop", "marginBottom"]).concat(t), r = r.concat(["marginLeft", "marginRight"]), i.find("*[width]").each(function () {
			var t = q(this),
				e = q.effects.scaledDimensions(t),
				i = {
					height: e.height * s.from.y,
					width: e.width * s.from.x,
					outerHeight: e.outerHeight * s.from.y,
					outerWidth: e.outerWidth * s.from.x
				},
				e = {
					height: e.height * s.to.y,
					width: e.width * s.to.x,
					outerHeight: e.height * s.to.y,
					outerWidth: e.width * s.to.x
				};
			s.from.y !== s.to.y && (i = q.effects.setTransition(t, o, s.from.y, i), e = q.effects.setTransition(t, o, s.to.y, e)), s.from.x !== s.to.x && (i = q.effects.setTransition(t, r, s.from.x, i), e = q.effects.setTransition(t, r, s.to.x, e)), l && q.effects.saveStyle(t), t.css(i), t.animate(e, n.duration, n.easing, function () {
				l && q.effects.restoreStyle(t)
			})
		})), i.animate(g, {
			queue: !1,
			duration: n.duration,
			easing: n.easing,
			complete: function () {
				var t = i.offset();
				0 === g.opacity && i.css("opacity", p.opacity), l || (i.css("position", "static" === u ? "relative" : u).offset(t), q.effects.saveStyle(i)), e()
			}
		})
	}), q.effects.define("scale", function (t, e) {
		var i = q(this),
			n = t.mode,
			n = parseInt(t.percent, 10) || (0 === parseInt(t.percent, 10) || "effect" !== n ? 0 : 100),
			n = q.extend(!0, {
				from: q.effects.scaledDimensions(i),
				to: q.effects.scaledDimensions(i, n, t.direction || "both"),
				origin: t.origin || ["middle", "center"]
			}, t);
		t.fade && (n.from.opacity = 1, n.to.opacity = 0), q.effects.effect.size.call(this, n, e)
	}), q.effects.define("puff", "hide", function (t, e) {
		t = q.extend(!0, {}, t, {
			fade: !0,
			percent: parseInt(t.percent, 10) || 150
		}), q.effects.effect.scale.call(this, t, e)
	}), q.effects.define("pulsate", "show", function (t, e) {
		var i = q(this),
			n = t.mode,
			s = "show" === n,
			o = 2 * (t.times || 5) + (s || "hide" === n ? 1 : 0),
			r = t.duration / o,
			a = 0,
			l = 1,
			n = i.queue().length;
		for (!s && i.is(":visible") || (i.css("opacity", 0).show(), a = 1); l < o; l++) i.animate({
			opacity: a
		}, r, t.easing), a = 1 - a;
		i.animate({
			opacity: a
		}, r, t.easing), i.queue(e), q.effects.unshift(i, n, 1 + o)
	}), q.effects.define("shake", function (t, e) {
		var i = 1,
			n = q(this),
			s = t.direction || "left",
			o = t.distance || 20,
			r = t.times || 3,
			a = 2 * r + 1,
			l = Math.round(t.duration / a),
			h = "up" === s || "down" === s ? "top" : "left",
			c = "up" === s || "left" === s,
			u = {},
			d = {},
			f = {},
			s = n.queue().length;
		for (q.effects.createPlaceholder(n), u[h] = (c ? "-=" : "+=") + o, d[h] = (c ? "+=" : "-=") + 2 * o, f[h] = (c ? "-=" : "+=") + 2 * o, n.animate(u, l, t.easing); i < r; i++) n.animate(d, l, t.easing).animate(f, l, t.easing);
		n.animate(d, l, t.easing).animate(u, l / 2, t.easing).queue(e), q.effects.unshift(n, s, 1 + a)
	}), q.effects.define("slide", "show", function (t, e) {
		var i, n, s = q(this),
			o = {
				up: ["bottom", "top"],
				down: ["top", "bottom"],
				left: ["right", "left"],
				right: ["left", "right"]
			},
			r = t.mode,
			a = t.direction || "left",
			l = "up" === a || "down" === a ? "top" : "left",
			h = "up" === a || "left" === a,
			c = t.distance || s["top" == l ? "outerHeight" : "outerWidth"](!0),
			u = {};
		q.effects.createPlaceholder(s), i = s.cssClip(), n = s.position()[l], u[l] = (h ? -1 : 1) * c + n, u.clip = s.cssClip(), u.clip[o[a][1]] = u.clip[o[a][0]], "show" === r && (s.cssClip(u.clip), s.css(l, u[l]), u.clip = i, u[l] = n), s.animate(u, {
			queue: !1,
			duration: t.duration,
			easing: t.easing,
			complete: e
		})
	}), t = !1 !== q.uiBackCompat ? q.effects.define("transfer", function (t, e) {
		q(this).transfer(t, e)
	}) : t, q.ui.focusable = function (t, e) {
		var i, n, s, o, r = t.nodeName.toLowerCase();
		return "area" === r ? (n = (i = t.parentNode).name, !(!t.href || !n || "map" !== i.nodeName.toLowerCase()) && 0 < (n = q("img[usemap='#" + n + "']")).length && n.is(":visible")) : (/^(input|select|textarea|button|object)$/.test(r) ? (s = !t.disabled) && (o = q(t).closest("fieldset")[0]) && (s = !o.disabled) : s = "a" === r && t.href || e, s && q(t).is(":visible") && function (t) {
			for (var e = t.css("visibility");
				"inherit" === e;) t = t.parent(), e = t.css("visibility");
			return "visible" === e
		}(q(t)))
	}, q.extend(q.expr.pseudos, {
		focusable: function (t) {
			return q.ui.focusable(t, null != q.attr(t, "tabindex"))
		}
	});
	var rt, at;
	q.ui.focusable, q.fn._form = function () {
		return "string" == typeof this[0].form ? this.closest("form") : q(this[0].form)
	}, q.ui.formResetMixin = {
		_formResetHandler: function () {
			var e = q(this);
			setTimeout(function () {
				var t = e.data("ui-form-reset-instances");
				q.each(t, function () {
					this.refresh()
				})
			})
		},
		_bindFormResetHandler: function () {
			var t;
			this.form = this.element._form(), this.form.length && ((t = this.form.data("ui-form-reset-instances") || []).length || this.form.on("reset.ui-form-reset", this._formResetHandler), t.push(this), this.form.data("ui-form-reset-instances", t))
		},
		_unbindFormResetHandler: function () {
			var t;
			this.form.length && ((t = this.form.data("ui-form-reset-instances")).splice(q.inArray(this, t), 1), t.length ? this.form.data("ui-form-reset-instances", t) : this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"))
		}
	}, q.expr.pseudos || (q.expr.pseudos = q.expr[":"]), q.uniqueSort || (q.uniqueSort = q.unique), q.escapeSelector || (rt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, at = function (t, e) {
		return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
	}, q.escapeSelector = function (t) {
		return (t + "").replace(rt, at)
	}), q.fn.even && q.fn.odd || q.fn.extend({
		even: function () {
			return this.filter(function (t) {
				return t % 2 == 0
			})
		},
		odd: function () {
			return this.filter(function (t) {
				return t % 2 == 1
			})
		}
	});
	var lt;
	q.ui.keyCode = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}, q.fn.labels = function () {
		var t, e, i;
		return this.length ? this[0].labels && this[0].labels.length ? this.pushStack(this[0].labels) : (e = this.eq(0).parents("label"), (t = this.attr("id")) && (i = (i = this.eq(0).parents().last()).add((i.length ? i : this).siblings()), t = "label[for='" + q.escapeSelector(t) + "']", e = e.add(i.find(t).addBack(t))), this.pushStack(e)) : this.pushStack([])
	}, q.fn.scrollParent = function (t) {
		var e = this.css("position"),
			i = "absolute" === e,
			n = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
			t = this.parents().filter(function () {
				var t = q(this);
				return (!i || "static" !== t.css("position")) && n.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"))
			}).eq(0);
		return "fixed" !== e && t.length ? t : q(this[0].ownerDocument || document)
	}, q.extend(q.expr.pseudos, {
		tabbable: function (t) {
			var e = q.attr(t, "tabindex"),
				i = null != e;
			return (!i || 0 <= e) && q.ui.focusable(t, i)
		}
	}), q.fn.extend({
		uniqueId: (lt = 0, function () {
			return this.each(function () {
				this.id || (this.id = "ui-id-" + ++lt)
			})
		}),
		removeUniqueId: function () {
			return this.each(function () {
				/^ui-id-\d+$/.test(this.id) && q(this).removeAttr("id")
			})
		}
	}), q.widget("ui.accordion", {
		version: "1.13.2",
		options: {
			active: 0,
			animate: {},
			classes: {
				"ui-accordion-header": "ui-corner-top",
				"ui-accordion-header-collapsed": "ui-corner-all",
				"ui-accordion-content": "ui-corner-bottom"
			},
			collapsible: !1,
			event: "click",
			header: function (t) {
				return t.find("> li > :first-child").add(t.find("> :not(li)").even())
			},
			heightStyle: "auto",
			icons: {
				activeHeader: "ui-icon-triangle-1-s",
				header: "ui-icon-triangle-1-e"
			},
			activate: null,
			beforeActivate: null
		},
		hideProps: {
			borderTopWidth: "hide",
			borderBottomWidth: "hide",
			paddingTop: "hide",
			paddingBottom: "hide",
			height: "hide"
		},
		showProps: {
			borderTopWidth: "show",
			borderBottomWidth: "show",
			paddingTop: "show",
			paddingBottom: "show",
			height: "show"
		},
		_create: function () {
			var t = this.options;
			this.prevShow = this.prevHide = q(), this._addClass("ui-accordion", "ui-widget ui-helper-reset"), this.element.attr("role", "tablist"), t.collapsible || !1 !== t.active && null != t.active || (t.active = 0), this._processPanels(), t.active < 0 && (t.active += this.headers.length), this._refresh()
		},
		_getCreateEventData: function () {
			return {
				header: this.active,
				panel: this.active.length ? this.active.next() : q()
			}
		},
		_createIcons: function () {
			var t, e = this.options.icons;
			e && (t = q("<span>"), this._addClass(t, "ui-accordion-header-icon", "ui-icon " + e.header), t.prependTo(this.headers), t = this.active.children(".ui-accordion-header-icon"), this._removeClass(t, e.header)._addClass(t, null, e.activeHeader)._addClass(this.headers, "ui-accordion-icons"))
		},
		_destroyIcons: function () {
			this._removeClass(this.headers, "ui-accordion-icons"), this.headers.children(".ui-accordion-header-icon").remove()
		},
		_destroy: function () {
			var t;
			this.element.removeAttr("role"), this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(), this._destroyIcons(), t = this.headers.next().css("display", "").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(), "content" !== this.options.heightStyle && t.css("height", "")
		},
		_setOption: function (t, e) {
			"active" !== t ? ("event" === t && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(e)), this._super(t, e), "collapsible" !== t || e || !1 !== this.options.active || this._activate(0), "icons" === t && (this._destroyIcons(), e && this._createIcons())) : this._activate(e)
		},
		_setOptionDisabled: function (t) {
			this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t), this._toggleClass(this.headers.add(this.headers.next()), null, "ui-state-disabled", !!t)
		},
		_keydown: function (t) {
			if (!t.altKey && !t.ctrlKey) {
				var e = q.ui.keyCode,
					i = this.headers.length,
					n = this.headers.index(t.target),
					s = !1;
				switch (t.keyCode) {
					case e.RIGHT:
					case e.DOWN:
						s = this.headers[(n + 1) % i];
						break;
					case e.LEFT:
					case e.UP:
						s = this.headers[(n - 1 + i) % i];
						break;
					case e.SPACE:
					case e.ENTER:
						this._eventHandler(t);
						break;
					case e.HOME:
						s = this.headers[0];
						break;
					case e.END:
						s = this.headers[i - 1]
				}
				s && (q(t.target).attr("tabIndex", -1), q(s).attr("tabIndex", 0), q(s).trigger("focus"), t.preventDefault())
			}
		},
		_panelKeyDown: function (t) {
			t.keyCode === q.ui.keyCode.UP && t.ctrlKey && q(t.currentTarget).prev().trigger("focus")
		},
		refresh: function () {
			var t = this.options;
			this._processPanels(), !1 === t.active && !0 === t.collapsible || !this.headers.length ? (t.active = !1, this.active = q()) : !1 === t.active ? this._activate(0) : this.active.length && !q.contains(this.element[0], this.active[0]) ? this.headers.length === this.headers.find(".ui-state-disabled").length ? (t.active = !1, this.active = q()) : this._activate(Math.max(0, t.active - 1)) : t.active = this.headers.index(this.active), this._destroyIcons(), this._refresh()
		},
		_processPanels: function () {
			var t = this.headers,
				e = this.panels;
			"function" == typeof this.options.header ? this.headers = this.options.header(this.element) : this.headers = this.element.find(this.options.header), this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed", "ui-state-default"), this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide(), this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content"), e && (this._off(t.not(this.headers)), this._off(e.not(this.panels)))
		},
		_refresh: function () {
			var i, t = this.options,
				e = t.heightStyle,
				n = this.element.parent();
			this.active = this._findActive(t.active), this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")._removeClass(this.active, "ui-accordion-header-collapsed"), this._addClass(this.active.next(), "ui-accordion-content-active"), this.active.next().show(), this.headers.attr("role", "tab").each(function () {
				var t = q(this),
					e = t.uniqueId().attr("id"),
					i = t.next(),
					n = i.uniqueId().attr("id");
				t.attr("aria-controls", n), i.attr("aria-labelledby", e)
			}).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
				"aria-selected": "false",
				"aria-expanded": "false",
				tabIndex: -1
			}).next().attr({
				"aria-hidden": "true"
			}).hide(), this.active.length ? this.active.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			}).next().attr({
				"aria-hidden": "false"
			}) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(t.event), "fill" === e ? (i = n.height(), this.element.siblings(":visible").each(function () {
				var t = q(this),
					e = t.css("position");
				"absolute" !== e && "fixed" !== e && (i -= t.outerHeight(!0))
			}), this.headers.each(function () {
				i -= q(this).outerHeight(!0)
			}), this.headers.next().each(function () {
				q(this).height(Math.max(0, i - q(this).innerHeight() + q(this).height()))
			}).css("overflow", "auto")) : "auto" === e && (i = 0, this.headers.next().each(function () {
				var t = q(this).is(":visible");
				t || q(this).show(), i = Math.max(i, q(this).css("height", "").height()), t || q(this).hide()
			}).height(i))
		},
		_activate: function (t) {
			(t = this._findActive(t)[0]) !== this.active[0] && (t = t || this.active[0], this._eventHandler({
				target: t,
				currentTarget: t,
				preventDefault: q.noop
			}))
		},
		_findActive: function (t) {
			return "number" == typeof t ? this.headers.eq(t) : q()
		},
		_setupEvents: function (t) {
			var i = {
				keydown: "_keydown"
			};
			t && q.each(t.split(" "), function (t, e) {
				i[e] = "_eventHandler"
			}), this._off(this.headers.add(this.headers.next())), this._on(this.headers, i), this._on(this.headers.next(), {
				keydown: "_panelKeyDown"
			}), this._hoverable(this.headers), this._focusable(this.headers)
		},
		_eventHandler: function (t) {
			var e = this.options,
				i = this.active,
				n = q(t.currentTarget),
				s = n[0] === i[0],
				o = s && e.collapsible,
				r = o ? q() : n.next(),
				a = i.next(),
				r = {
					oldHeader: i,
					oldPanel: a,
					newHeader: o ? q() : n,
					newPanel: r
				};
			t.preventDefault(), s && !e.collapsible || !1 === this._trigger("beforeActivate", t, r) || (e.active = !o && this.headers.index(n), this.active = s ? q() : n, this._toggle(r), this._removeClass(i, "ui-accordion-header-active", "ui-state-active"), e.icons && (i = i.children(".ui-accordion-header-icon"), this._removeClass(i, null, e.icons.activeHeader)._addClass(i, null, e.icons.header)), s || (this._removeClass(n, "ui-accordion-header-collapsed")._addClass(n, "ui-accordion-header-active", "ui-state-active"), e.icons && (s = n.children(".ui-accordion-header-icon"), this._removeClass(s, null, e.icons.header)._addClass(s, null, e.icons.activeHeader)), this._addClass(n.next(), "ui-accordion-content-active")))
		},
		_toggle: function (t) {
			var e = t.newPanel,
				i = this.prevShow.length ? this.prevShow : t.oldPanel;
			this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = e, this.prevHide = i, this.options.animate ? this._animate(e, i, t) : (i.hide(), e.show(), this._toggleComplete(t)), i.attr({
				"aria-hidden": "true"
			}), i.prev().attr({
				"aria-selected": "false",
				"aria-expanded": "false"
			}), e.length && i.length ? i.prev().attr({
				tabIndex: -1,
				"aria-expanded": "false"
			}) : e.length && this.headers.filter(function () {
				return 0 === parseInt(q(this).attr("tabIndex"), 10)
			}).attr("tabIndex", -1), e.attr("aria-hidden", "false").prev().attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			})
		},
		_animate: function (t, i, e) {
			var n, s, o, r = this,
				a = 0,
				l = t.css("box-sizing"),
				h = t.length && (!i.length || t.index() < i.index()),
				c = this.options.animate || {},
				u = h && c.down || c,
				h = function () {
					r._toggleComplete(e)
				};
			return s = (s = "string" == typeof u ? u : s) || u.easing || c.easing, o = (o = "number" == typeof u ? u : o) || u.duration || c.duration, i.length ? t.length ? (n = t.show().outerHeight(), i.animate(this.hideProps, {
				duration: o,
				easing: s,
				step: function (t, e) {
					e.now = Math.round(t)
				}
			}), void t.hide().animate(this.showProps, {
				duration: o,
				easing: s,
				complete: h,
				step: function (t, e) {
					e.now = Math.round(t), "height" !== e.prop ? "content-box" === l && (a += e.now) : "content" !== r.options.heightStyle && (e.now = Math.round(n - i.outerHeight() - a), a = 0)
				}
			})) : i.animate(this.hideProps, o, s, h) : t.animate(this.showProps, o, s, h)
		},
		_toggleComplete: function (t) {
			var e = t.oldPanel,
				i = e.prev();
			this._removeClass(e, "ui-accordion-content-active"), this._removeClass(i, "ui-accordion-header-active")._addClass(i, "ui-accordion-header-collapsed"), e.length && (e.parent()[0].className = e.parent()[0].className), this._trigger("activate", null, t)
		}
	}), q.ui.safeActiveElement = function (e) {
		var i;
		try {
			i = e.activeElement
		} catch (t) {
			i = e.body
		}
		return i = (i = i || e.body).nodeName ? i : e.body
	}, q.widget("ui.menu", {
		version: "1.13.2",
		defaultElement: "<ul>",
		delay: 300,
		options: {
			icons: {
				submenu: "ui-icon-caret-1-e"
			},
			items: "> *",
			menus: "ul",
			position: {
				my: "left top",
				at: "right top"
			},
			role: "menu",
			blur: null,
			focus: null,
			select: null
		},
		_create: function () {
			this.activeMenu = this.element, this.mouseHandled = !1, this.lastMousePosition = {
				x: null,
				y: null
			}, this.element.uniqueId().attr({
				role: this.options.role,
				tabIndex: 0
			}), this._addClass("ui-menu", "ui-widget ui-widget-content"), this._on({
				"mousedown .ui-menu-item": function (t) {
					t.preventDefault(), this._activateItem(t)
				},
				"click .ui-menu-item": function (t) {
					var e = q(t.target),
						i = q(q.ui.safeActiveElement(this.document[0]));
					!this.mouseHandled && e.not(".ui-state-disabled").length && (this.select(t), t.isPropagationStopped() || (this.mouseHandled = !0), e.has(".ui-menu").length ? this.expand(t) : !this.element.is(":focus") && i.closest(".ui-menu").length && (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)))
				},
				"mouseenter .ui-menu-item": "_activateItem",
				"mousemove .ui-menu-item": "_activateItem",
				mouseleave: "collapseAll",
				"mouseleave .ui-menu": "collapseAll",
				focus: function (t, e) {
					var i = this.active || this._menuItems().first();
					e || this.focus(t, i)
				},
				blur: function (t) {
					this._delay(function () {
						q.contains(this.element[0], q.ui.safeActiveElement(this.document[0])) || this.collapseAll(t)
					})
				},
				keydown: "_keydown"
			}), this.refresh(), this._on(this.document, {
				click: function (t) {
					this._closeOnDocumentClick(t) && this.collapseAll(t, !0), this.mouseHandled = !1
				}
			})
		},
		_activateItem: function (t) {
			var e, i;
			this.previousFilter || t.clientX === this.lastMousePosition.x && t.clientY === this.lastMousePosition.y || (this.lastMousePosition = {
				x: t.clientX,
				y: t.clientY
			}, e = q(t.target).closest(".ui-menu-item"), i = q(t.currentTarget), e[0] === i[0] && (i.is(".ui-state-active") || (this._removeClass(i.siblings().children(".ui-state-active"), null, "ui-state-active"), this.focus(t, i))))
		},
		_destroy: function () {
			var t = this.element.find(".ui-menu-item").removeAttr("role aria-disabled").children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
			this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(), t.children().each(function () {
				var t = q(this);
				t.data("ui-menu-submenu-caret") && t.remove()
			})
		},
		_keydown: function (t) {
			var e, i, n, s = !0;
			switch (t.keyCode) {
				case q.ui.keyCode.PAGE_UP:
					this.previousPage(t);
					break;
				case q.ui.keyCode.PAGE_DOWN:
					this.nextPage(t);
					break;
				case q.ui.keyCode.HOME:
					this._move("first", "first", t);
					break;
				case q.ui.keyCode.END:
					this._move("last", "last", t);
					break;
				case q.ui.keyCode.UP:
					this.previous(t);
					break;
				case q.ui.keyCode.DOWN:
					this.next(t);
					break;
				case q.ui.keyCode.LEFT:
					this.collapse(t);
					break;
				case q.ui.keyCode.RIGHT:
					this.active && !this.active.is(".ui-state-disabled") && this.expand(t);
					break;
				case q.ui.keyCode.ENTER:
				case q.ui.keyCode.SPACE:
					this._activate(t);
					break;
				case q.ui.keyCode.ESCAPE:
					this.collapse(t);
					break;
				default:
					e = this.previousFilter || "", n = s = !1, i = 96 <= t.keyCode && t.keyCode <= 105 ? (t.keyCode - 96).toString() : String.fromCharCode(t.keyCode), clearTimeout(this.filterTimer), i === e ? n = !0 : i = e + i, e = this._filterMenuItems(i), (e = n && -1 !== e.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : e).length || (i = String.fromCharCode(t.keyCode), e = this._filterMenuItems(i)), e.length ? (this.focus(t, e), this.previousFilter = i, this.filterTimer = this._delay(function () {
						delete this.previousFilter
					}, 1e3)) : delete this.previousFilter
			}
			s && t.preventDefault()
		},
		_activate: function (t) {
			this.active && !this.active.is(".ui-state-disabled") && (this.active.children("[aria-haspopup='true']").length ? this.expand(t) : this.select(t))
		},
		refresh: function () {
			var t, e, n = this,
				s = this.options.icons.submenu,
				i = this.element.find(this.options.menus);
			this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length), e = i.filter(":not(.ui-menu)").hide().attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			}).each(function () {
				var t = q(this),
					e = t.prev(),
					i = q("<span>").data("ui-menu-submenu-caret", !0);
				n._addClass(i, "ui-menu-icon", "ui-icon " + s), e.attr("aria-haspopup", "true").prepend(i), t.attr("aria-labelledby", e.attr("id"))
			}), this._addClass(e, "ui-menu", "ui-widget ui-widget-content ui-front"), (t = i.add(this.element).find(this.options.items)).not(".ui-menu-item").each(function () {
				var t = q(this);
				n._isDivider(t) && n._addClass(t, "ui-menu-divider", "ui-widget-content")
			}), i = (e = t.not(".ui-menu-item, .ui-menu-divider")).children().not(".ui-menu").uniqueId().attr({
				tabIndex: -1,
				role: this._itemRole()
			}), this._addClass(e, "ui-menu-item")._addClass(i, "ui-menu-item-wrapper"), t.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !q.contains(this.element[0], this.active[0]) && this.blur()
		},
		_itemRole: function () {
			return {
				menu: "menuitem",
				listbox: "option"
			}[this.options.role]
		},
		_setOption: function (t, e) {
			var i;
			"icons" === t && (i = this.element.find(".ui-menu-icon"), this._removeClass(i, null, this.options.icons.submenu)._addClass(i, null, e.submenu)), this._super(t, e)
		},
		_setOptionDisabled: function (t) {
			this._super(t), this.element.attr("aria-disabled", String(t)), this._toggleClass(null, "ui-state-disabled", !!t)
		},
		focus: function (t, e) {
			var i;
			this.blur(t, t && "focus" === t.type), this._scrollIntoView(e), this.active = e.first(), i = this.active.children(".ui-menu-item-wrapper"), this._addClass(i, null, "ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", i.attr("id")), i = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"), this._addClass(i, null, "ui-state-active"), t && "keydown" === t.type ? this._close() : this.timer = this._delay(function () {
				this._close()
			}, this.delay), (i = e.children(".ui-menu")).length && t && /^mouse/.test(t.type) && this._startOpening(i), this.activeMenu = e.parent(), this._trigger("focus", t, {
				item: e
			})
		},
		_scrollIntoView: function (t) {
			var e, i, n;
			this._hasScroll() && (i = parseFloat(q.css(this.activeMenu[0], "borderTopWidth")) || 0, n = parseFloat(q.css(this.activeMenu[0], "paddingTop")) || 0, e = t.offset().top - this.activeMenu.offset().top - i - n, i = this.activeMenu.scrollTop(), n = this.activeMenu.height(), t = t.outerHeight(), e < 0 ? this.activeMenu.scrollTop(i + e) : n < e + t && this.activeMenu.scrollTop(i + e - n + t))
		},
		blur: function (t, e) {
			e || clearTimeout(this.timer), this.active && (this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active"), this._trigger("blur", t, {
				item: this.active
			}), this.active = null)
		},
		_startOpening: function (t) {
			clearTimeout(this.timer), "true" === t.attr("aria-hidden") && (this.timer = this._delay(function () {
				this._close(), this._open(t)
			}, this.delay))
		},
		_open: function (t) {
			var e = q.extend({
				of: this.active
			}, this.options.position);
			clearTimeout(this.timer), this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden", "true"), t.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(e)
		},
		collapseAll: function (e, i) {
			clearTimeout(this.timer), this.timer = this._delay(function () {
				var t = i ? this.element : q(e && e.target).closest(this.element.find(".ui-menu"));
				t.length || (t = this.element), this._close(t), this.blur(e), this._removeClass(t.find(".ui-state-active"), null, "ui-state-active"), this.activeMenu = t
			}, i ? 0 : this.delay)
		},
		_close: function (t) {
			(t = t || (this.active ? this.active.parent() : this.element)).find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false")
		},
		_closeOnDocumentClick: function (t) {
			return !q(t.target).closest(".ui-menu").length
		},
		_isDivider: function (t) {
			return !/[^\-\u2014\u2013\s]/.test(t.text())
		},
		collapse: function (t) {
			var e = this.active && this.active.parent().closest(".ui-menu-item", this.element);
			e && e.length && (this._close(), this.focus(t, e))
		},
		expand: function (t) {
			var e = this.active && this._menuItems(this.active.children(".ui-menu")).first();
			e && e.length && (this._open(e.parent()), this._delay(function () {
				this.focus(t, e)
			}))
		},
		next: function (t) {
			this._move("next", "first", t)
		},
		previous: function (t) {
			this._move("prev", "last", t)
		},
		isFirstItem: function () {
			return this.active && !this.active.prevAll(".ui-menu-item").length
		},
		isLastItem: function () {
			return this.active && !this.active.nextAll(".ui-menu-item").length
		},
		_menuItems: function (t) {
			return (t || this.element).find(this.options.items).filter(".ui-menu-item")
		},
		_move: function (t, e, i) {
			var n;
			(n = this.active ? "first" === t || "last" === t ? this.active["first" === t ? "prevAll" : "nextAll"](".ui-menu-item").last() : this.active[t + "All"](".ui-menu-item").first() : n) && n.length && this.active || (n = this._menuItems(this.activeMenu)[e]()), this.focus(i, n)
		},
		nextPage: function (t) {
			var e, i, n;
			this.active ? this.isLastItem() || (this._hasScroll() ? (i = this.active.offset().top, n = this.element.innerHeight(), 0 === q.fn.jquery.indexOf("3.2.") && (n += this.element[0].offsetHeight - this.element.outerHeight()), this.active.nextAll(".ui-menu-item").each(function () {
				return (e = q(this)).offset().top - i - n < 0
			}), this.focus(t, e)) : this.focus(t, this._menuItems(this.activeMenu)[this.active ? "last" : "first"]())) : this.next(t)
		},
		previousPage: function (t) {
			var e, i, n;
			this.active ? this.isFirstItem() || (this._hasScroll() ? (i = this.active.offset().top, n = this.element.innerHeight(), 0 === q.fn.jquery.indexOf("3.2.") && (n += this.element[0].offsetHeight - this.element.outerHeight()), this.active.prevAll(".ui-menu-item").each(function () {
				return 0 < (e = q(this)).offset().top - i + n
			}), this.focus(t, e)) : this.focus(t, this._menuItems(this.activeMenu).first())) : this.next(t)
		},
		_hasScroll: function () {
			return this.element.outerHeight() < this.element.prop("scrollHeight")
		},
		select: function (t) {
			this.active = this.active || q(t.target).closest(".ui-menu-item");
			var e = {
				item: this.active
			};
			this.active.has(".ui-menu").length || this.collapseAll(t, !0), this._trigger("select", t, e)
		},
		_filterMenuItems: function (t) {
			var t = t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
				e = new RegExp("^" + t, "i");
			return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function () {
				return e.test(String.prototype.trim.call(q(this).children(".ui-menu-item-wrapper").text()))
			})
		}
	}), q.widget("ui.autocomplete", {
		version: "1.13.2",
		defaultElement: "<input>",
		options: {
			appendTo: null,
			autoFocus: !1,
			delay: 300,
			minLength: 1,
			position: {
				my: "left top",
				at: "left bottom",
				collision: "none"
			},
			source: null,
			change: null,
			close: null,
			focus: null,
			open: null,
			response: null,
			search: null,
			select: null
		},
		requestIndex: 0,
		pending: 0,
		liveRegionTimer: null,
		_create: function () {
			var i, n, s, t = this.element[0].nodeName.toLowerCase(),
				e = "textarea" === t,
				t = "input" === t;
			this.isMultiLine = e || !t && this._isContentEditable(this.element), this.valueMethod = this.element[e || t ? "val" : "text"], this.isNewMenu = !0, this._addClass("ui-autocomplete-input"), this.element.attr("autocomplete", "off"), this._on(this.element, {
				keydown: function (t) {
					if (this.element.prop("readOnly")) n = s = i = !0;
					else {
						n = s = i = !1;
						var e = q.ui.keyCode;
						switch (t.keyCode) {
							case e.PAGE_UP:
								i = !0, this._move("previousPage", t);
								break;
							case e.PAGE_DOWN:
								i = !0, this._move("nextPage", t);
								break;
							case e.UP:
								i = !0, this._keyEvent("previous", t);
								break;
							case e.DOWN:
								i = !0, this._keyEvent("next", t);
								break;
							case e.ENTER:
								this.menu.active && (i = !0, t.preventDefault(), this.menu.select(t));
								break;
							case e.TAB:
								this.menu.active && this.menu.select(t);
								break;
							case e.ESCAPE:
								this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(t), t.preventDefault());
								break;
							default:
								n = !0, this._searchTimeout(t)
						}
					}
				},
				keypress: function (t) {
					if (i) return i = !1, void (this.isMultiLine && !this.menu.element.is(":visible") || t.preventDefault());
					if (!n) {
						var e = q.ui.keyCode;
						switch (t.keyCode) {
							case e.PAGE_UP:
								this._move("previousPage", t);
								break;
							case e.PAGE_DOWN:
								this._move("nextPage", t);
								break;
							case e.UP:
								this._keyEvent("previous", t);
								break;
							case e.DOWN:
								this._keyEvent("next", t)
						}
					}
				},
				input: function (t) {
					if (s) return s = !1, void t.preventDefault();
					this._searchTimeout(t)
				},
				focus: function () {
					this.selectedItem = null, this.previous = this._value()
				},
				blur: function (t) {
					clearTimeout(this.searching), this.close(t), this._change(t)
				}
			}), this._initSource(), this.menu = q("<ul>").appendTo(this._appendTo()).menu({
				role: null
			}).hide().attr({
				unselectable: "on"
			}).menu("instance"), this._addClass(this.menu.element, "ui-autocomplete", "ui-front"), this._on(this.menu.element, {
				mousedown: function (t) {
					t.preventDefault()
				},
				menufocus: function (t, e) {
					var i, n;
					if (this.isNewMenu && (this.isNewMenu = !1, t.originalEvent && /^mouse/.test(t.originalEvent.type))) return this.menu.blur(), void this.document.one("mousemove", function () {
						q(t.target).trigger(t.originalEvent)
					});
					n = e.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", t, {
						item: n
					}) && t.originalEvent && /^key/.test(t.originalEvent.type) && this._value(n.value), (i = e.item.attr("aria-label") || n.value) && String.prototype.trim.call(i).length && (clearTimeout(this.liveRegionTimer), this.liveRegionTimer = this._delay(function () {
						this.liveRegion.html(q("<div>").text(i))
					}, 100))
				},
				menuselect: function (t, e) {
					var i = e.item.data("ui-autocomplete-item"),
						n = this.previous;
					this.element[0] !== q.ui.safeActiveElement(this.document[0]) && (this.element.trigger("focus"), this.previous = n, this._delay(function () {
						this.previous = n, this.selectedItem = i
					})), !1 !== this._trigger("select", t, {
						item: i
					}) && this._value(i.value), this.term = this._value(), this.close(t), this.selectedItem = i
				}
			}), this.liveRegion = q("<div>", {
				role: "status",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			}).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this._on(this.window, {
				beforeunload: function () {
					this.element.removeAttr("autocomplete")
				}
			})
		},
		_destroy: function () {
			clearTimeout(this.searching), this.element.removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove()
		},
		_setOption: function (t, e) {
			this._super(t, e), "source" === t && this._initSource(), "appendTo" === t && this.menu.element.appendTo(this._appendTo()), "disabled" === t && e && this.xhr && this.xhr.abort()
		},
		_isEventTargetInWidget: function (t) {
			var e = this.menu.element[0];
			return t.target === this.element[0] || t.target === e || q.contains(e, t.target)
		},
		_closeOnClickOutside: function (t) {
			this._isEventTargetInWidget(t) || this.close()
		},
		_appendTo: function () {
			var t = this.options.appendTo;
			return t = (t = (t = t && (t.jquery || t.nodeType ? q(t) : this.document.find(t).eq(0))) && t[0] ? t : this.element.closest(".ui-front, dialog")).length ? t : this.document[0].body
		},
		_initSource: function () {
			var i, n, s = this;
			Array.isArray(this.options.source) ? (i = this.options.source, this.source = function (t, e) {
				e(q.ui.autocomplete.filter(i, t.term))
			}) : "string" == typeof this.options.source ? (n = this.options.source, this.source = function (t, e) {
				s.xhr && s.xhr.abort(), s.xhr = q.ajax({
					url: n,
					data: t,
					dataType: "json",
					success: function (t) {
						e(t)
					},
					error: function () {
						e([])
					}
				})
			}) : this.source = this.options.source
		},
		_searchTimeout: function (n) {
			clearTimeout(this.searching), this.searching = this._delay(function () {
				var t = this.term === this._value(),
					e = this.menu.element.is(":visible"),
					i = n.altKey || n.ctrlKey || n.metaKey || n.shiftKey;
				t && (e || i) || (this.selectedItem = null, this.search(null, n))
			}, this.options.delay)
		},
		search: function (t, e) {
			return t = null != t ? t : this._value(), this.term = this._value(), t.length < this.options.minLength ? this.close(e) : !1 !== this._trigger("search", e) ? this._search(t) : void 0
		},
		_search: function (t) {
			this.pending++, this._addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({
				term: t
			}, this._response())
		},
		_response: function () {
			var e = ++this.requestIndex;
			return function (t) {
				e === this.requestIndex && this.__response(t), --this.pending || this._removeClass("ui-autocomplete-loading")
			}.bind(this)
		},
		__response: function (t) {
			t = t && this._normalize(t), this._trigger("response", null, {
				content: t
			}), !this.options.disabled && t && t.length && !this.cancelSearch ? (this._suggest(t), this._trigger("open")) : this._close()
		},
		close: function (t) {
			this.cancelSearch = !0, this._close(t)
		},
		_close: function (t) {
			this._off(this.document, "mousedown"), this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", t))
		},
		_change: function (t) {
			this.previous !== this._value() && this._trigger("change", t, {
				item: this.selectedItem
			})
		},
		_normalize: function (t) {
			return t.length && t[0].label && t[0].value ? t : q.map(t, function (t) {
				return "string" == typeof t ? {
					label: t,
					value: t
				} : q.extend({}, t, {
					label: t.label || t.value,
					value: t.value || t.label
				})
			})
		},
		_suggest: function (t) {
			var e = this.menu.element.empty();
			this._renderMenu(e, t), this.isNewMenu = !0, this.menu.refresh(), e.show(), this._resizeMenu(), e.position(q.extend({
				of: this.element
			}, this.options.position)), this.options.autoFocus && this.menu.next(), this._on(this.document, {
				mousedown: "_closeOnClickOutside"
			})
		},
		_resizeMenu: function () {
			var t = this.menu.element;
			t.outerWidth(Math.max(t.width("").outerWidth() + 1, this.element.outerWidth()))
		},
		_renderMenu: function (i, t) {
			var n = this;
			q.each(t, function (t, e) {
				n._renderItemData(i, e)
			})
		},
		_renderItemData: function (t, e) {
			return this._renderItem(t, e).data("ui-autocomplete-item", e)
		},
		_renderItem: function (t, e) {
			return q("<li>").append(q("<div>").text(e.label)).appendTo(t)
		},
		_move: function (t, e) {
			if (this.menu.element.is(":visible")) return this.menu.isFirstItem() && /^previous/.test(t) || this.menu.isLastItem() && /^next/.test(t) ? (this.isMultiLine || this._value(this.term), void this.menu.blur()) : void this.menu[t](e);
			this.search(null, e)
		},
		widget: function () {
			return this.menu.element
		},
		_value: function () {
			return this.valueMethod.apply(this.element, arguments)
		},
		_keyEvent: function (t, e) {
			this.isMultiLine && !this.menu.element.is(":visible") || (this._move(t, e), e.preventDefault())
		},
		_isContentEditable: function (t) {
			if (!t.length) return !1;
			var e = t.prop("contentEditable");
			return "inherit" === e ? this._isContentEditable(t.parent()) : "true" === e
		}
	}), q.extend(q.ui.autocomplete, {
		escapeRegex: function (t) {
			return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
		},
		filter: function (t, e) {
			var i = new RegExp(q.ui.autocomplete.escapeRegex(e), "i");
			return q.grep(t, function (t) {
				return i.test(t.label || t.value || t)
			})
		}
	}), q.widget("ui.autocomplete", q.ui.autocomplete, {
		options: {
			messages: {
				noResults: "No search results.",
				results: function (t) {
					return t + (1 < t ? " results are" : " result is") + " available, use up and down arrow keys to navigate."
				}
			}
		},
		__response: function (t) {
			var e;
			this._superApply(arguments), this.options.disabled || this.cancelSearch || (e = t && t.length ? this.options.messages.results(t.length) : this.options.messages.noResults, clearTimeout(this.liveRegionTimer), this.liveRegionTimer = this._delay(function () {
				this.liveRegion.html(q("<div>").text(e))
			}, 100))
		}
	}), q.ui.autocomplete;
	var ht = /ui-corner-([a-z]){2,6}/g;
	q.widget("ui.controlgroup", {
		version: "1.13.2",
		defaultElement: "<div>",
		options: {
			direction: "horizontal",
			disabled: null,
			onlyVisible: !0,
			items: {
				button: "input[type=button], input[type=submit], input[type=reset], button, a",
				controlgroupLabel: ".ui-controlgroup-label",
				checkboxradio: "input[type='checkbox'], input[type='radio']",
				selectmenu: "select",
				spinner: ".ui-spinner-input"
			}
		},
		_create: function () {
			this._enhance()
		},
		_enhance: function () {
			this.element.attr("role", "toolbar"), this.refresh()
		},
		_destroy: function () {
			this._callChildMethod("destroy"), this.childWidgets.removeData("ui-controlgroup-data"), this.element.removeAttr("role"), this.options.items.controlgroupLabel && this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()
		},
		_initWidgets: function () {
			var o = this,
				r = [];
			q.each(this.options.items, function (n, t) {
				var e, s = {};
				if (t) return "controlgroupLabel" === n ? ((e = o.element.find(t)).each(function () {
					var t = q(this);
					t.children(".ui-controlgroup-label-contents").length || t.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")
				}), o._addClass(e, null, "ui-widget ui-widget-content ui-state-default"), void (r = r.concat(e.get()))) : void (q.fn[n] && (s = o["_" + n + "Options"] ? o["_" + n + "Options"]("middle") : {
					classes: {}
				}, o.element.find(t).each(function () {
					var t = q(this),
						e = t[n]("instance"),
						i = q.widget.extend({}, s);
					"button" === n && t.parent(".ui-spinner").length || ((e = e || t[n]()[n]("instance")) && (i.classes = o._resolveClassesValues(i.classes, e)), t[n](i), i = t[n]("widget"), q.data(i[0], "ui-controlgroup-data", e || t[n]("instance")), r.push(i[0]))
				})))
			}), this.childWidgets = q(q.uniqueSort(r)), this._addClass(this.childWidgets, "ui-controlgroup-item")
		},
		_callChildMethod: function (e) {
			this.childWidgets.each(function () {
				var t = q(this).data("ui-controlgroup-data");
				t && t[e] && t[e]()
			})
		},
		_updateCornerClass: function (t, e) {
			e = this._buildSimpleOptions(e, "label").classes.label, this._removeClass(t, null, "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all"), this._addClass(t, null, e)
		},
		_buildSimpleOptions: function (t, e) {
			var i = "vertical" === this.options.direction,
				n = {
					classes: {}
				};
			return n.classes[e] = {
				middle: "",
				first: "ui-corner-" + (i ? "top" : "left"),
				last: "ui-corner-" + (i ? "bottom" : "right"),
				only: "ui-corner-all"
			}[t], n
		},
		_spinnerOptions: function (t) {
			return t = this._buildSimpleOptions(t, "ui-spinner"), t.classes["ui-spinner-up"] = "", t.classes["ui-spinner-down"] = "", t
		},
		_buttonOptions: function (t) {
			return this._buildSimpleOptions(t, "ui-button")
		},
		_checkboxradioOptions: function (t) {
			return this._buildSimpleOptions(t, "ui-checkboxradio-label")
		},
		_selectmenuOptions: function (t) {
			var e = "vertical" === this.options.direction;
			return {
				width: e && "auto",
				classes: {
					middle: {
						"ui-selectmenu-button-open": "",
						"ui-selectmenu-button-closed": ""
					},
					first: {
						"ui-selectmenu-button-open": "ui-corner-" + (e ? "top" : "tl"),
						"ui-selectmenu-button-closed": "ui-corner-" + (e ? "top" : "left")
					},
					last: {
						"ui-selectmenu-button-open": e ? "" : "ui-corner-tr",
						"ui-selectmenu-button-closed": "ui-corner-" + (e ? "bottom" : "right")
					},
					only: {
						"ui-selectmenu-button-open": "ui-corner-top",
						"ui-selectmenu-button-closed": "ui-corner-all"
					}
				}[t]
			}
		},
		_resolveClassesValues: function (i, n) {
			var s = {};
			return q.each(i, function (t) {
				var e = n.options.classes[t] || "",
					e = String.prototype.trim.call(e.replace(ht, ""));
				s[t] = (e + " " + i[t]).replace(/\s+/g, " ")
			}), s
		},
		_setOption: function (t, e) {
			"direction" === t && this._removeClass("ui-controlgroup-" + this.options.direction), this._super(t, e), "disabled" !== t ? this.refresh() : this._callChildMethod(e ? "disable" : "enable")
		},
		refresh: function () {
			var s, o = this;
			this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction), "horizontal" === this.options.direction && this._addClass(null, "ui-helper-clearfix"), this._initWidgets(), s = this.childWidgets, (s = this.options.onlyVisible ? s.filter(":visible") : s).length && (q.each(["first", "last"], function (t, e) {
				var i, n = s[e]().data("ui-controlgroup-data");
				n && o["_" + n.widgetName + "Options"] ? ((i = o["_" + n.widgetName + "Options"](1 === s.length ? "only" : e)).classes = o._resolveClassesValues(i.classes, n), n.element[n.widgetName](i)) : o._updateCornerClass(s[e](), e)
			}), this._callChildMethod("refresh"))
		}
	}), q.widget("ui.checkboxradio", [q.ui.formResetMixin, {
		version: "1.13.2",
		options: {
			disabled: null,
			label: null,
			icon: !0,
			classes: {
				"ui-checkboxradio-label": "ui-corner-all",
				"ui-checkboxradio-icon": "ui-corner-all"
			}
		},
		_getCreateOptions: function () {
			var t, e = this._super() || {};
			return this._readType(), t = this.element.labels(), this.label = q(t[t.length - 1]), this.label.length || q.error("No label found for checkboxradio widget"), this.originalLabel = "", (t = this.label.contents().not(this.element[0])).length && (this.originalLabel += t.clone().wrapAll("<div></div>").parent().html()), this.originalLabel && (e.label = this.originalLabel), null != (t = this.element[0].disabled) && (e.disabled = t), e
		},
		_create: function () {
			var t = this.element[0].checked;
			this._bindFormResetHandler(), null == this.options.disabled && (this.options.disabled = this.element[0].disabled), this._setOption("disabled", this.options.disabled), this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible"), this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget"), "radio" === this.type && this._addClass(this.label, "ui-checkboxradio-radio-label"), this.options.label && this.options.label !== this.originalLabel ? this._updateLabel() : this.originalLabel && (this.options.label = this.originalLabel), this._enhance(), t && this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active"), this._on({
				change: "_toggleClasses",
				focus: function () {
					this._addClass(this.label, null, "ui-state-focus ui-visual-focus")
				},
				blur: function () {
					this._removeClass(this.label, null, "ui-state-focus ui-visual-focus")
				}
			})
		},
		_readType: function () {
			var t = this.element[0].nodeName.toLowerCase();
			this.type = this.element[0].type, "input" === t && /radio|checkbox/.test(this.type) || q.error("Can't create checkboxradio on element.nodeName=" + t + " and element.type=" + this.type)
		},
		_enhance: function () {
			this._updateIcon(this.element[0].checked)
		},
		widget: function () {
			return this.label
		},
		_getRadioGroup: function () {
			var t = this.element[0].name,
				e = "input[name='" + q.escapeSelector(t) + "']";
			return t ? (this.form.length ? q(this.form[0].elements).filter(e) : q(e).filter(function () {
				return 0 === q(this)._form().length
			})).not(this.element) : q([])
		},
		_toggleClasses: function () {
			var t = this.element[0].checked;
			this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t), this.options.icon && "checkbox" === this.type && this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", t)._toggleClass(this.icon, null, "ui-icon-blank", !t), "radio" === this.type && this._getRadioGroup().each(function () {
				var t = q(this).checkboxradio("instance");
				t && t._removeClass(t.label, "ui-checkboxradio-checked", "ui-state-active")
			})
		},
		_destroy: function () {
			this._unbindFormResetHandler(), this.icon && (this.icon.remove(), this.iconSpace.remove())
		},
		_setOption: function (t, e) {
			if ("label" !== t || e) {
				if (this._super(t, e), "disabled" === t) return this._toggleClass(this.label, null, "ui-state-disabled", e), void (this.element[0].disabled = e);
				this.refresh()
			}
		},
		_updateIcon: function (t) {
			var e = "ui-icon ui-icon-background ";
			this.options.icon ? (this.icon || (this.icon = q("<span>"), this.iconSpace = q("<span> </span>"), this._addClass(this.iconSpace, "ui-checkboxradio-icon-space")), "checkbox" === this.type ? (e += t ? "ui-icon-check ui-state-checked" : "ui-icon-blank", this._removeClass(this.icon, null, t ? "ui-icon-blank" : "ui-icon-check")) : e += "ui-icon-blank", this._addClass(this.icon, "ui-checkboxradio-icon", e), t || this._removeClass(this.icon, null, "ui-icon-check ui-state-checked"), this.icon.prependTo(this.label).after(this.iconSpace)) : void 0 !== this.icon && (this.icon.remove(), this.iconSpace.remove(), delete this.icon)
		},
		_updateLabel: function () {
			var t = this.label.contents().not(this.element[0]);
			this.icon && (t = t.not(this.icon[0])), (t = this.iconSpace ? t.not(this.iconSpace[0]) : t).remove(), this.label.append(this.options.label)
		},
		refresh: function () {
			var t = this.element[0].checked,
				e = this.element[0].disabled;
			this._updateIcon(t), this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t), null !== this.options.label && this._updateLabel(), e !== this.options.disabled && this._setOptions({
				disabled: e
			})
		}
	}]);
	var ct;
	q.ui.checkboxradio, q.widget("ui.button", {
		version: "1.13.2",
		defaultElement: "<button>",
		options: {
			classes: {
				"ui-button": "ui-corner-all"
			},
			disabled: null,
			icon: null,
			iconPosition: "beginning",
			label: null,
			showLabel: !0
		},
		_getCreateOptions: function () {
			var t, e = this._super() || {};
			return this.isInput = this.element.is("input"), null != (t = this.element[0].disabled) && (e.disabled = t), this.originalLabel = this.isInput ? this.element.val() : this.element.html(), this.originalLabel && (e.label = this.originalLabel), e
		},
		_create: function () {
			!this.option.showLabel & !this.options.icon && (this.options.showLabel = !0), null == this.options.disabled && (this.options.disabled = this.element[0].disabled || !1), this.hasTitle = !!this.element.attr("title"), this.options.label && this.options.label !== this.originalLabel && (this.isInput ? this.element.val(this.options.label) : this.element.html(this.options.label)), this._addClass("ui-button", "ui-widget"), this._setOption("disabled", this.options.disabled), this._enhance(), this.element.is("a") && this._on({
				keyup: function (t) {
					t.keyCode === q.ui.keyCode.SPACE && (t.preventDefault(), this.element[0].click ? this.element[0].click() : this.element.trigger("click"))
				}
			})
		},
		_enhance: function () {
			this.element.is("button") || this.element.attr("role", "button"), this.options.icon && (this._updateIcon("icon", this.options.icon), this._updateTooltip())
		},
		_updateTooltip: function () {
			this.title = this.element.attr("title"), this.options.showLabel || this.title || this.element.attr("title", this.options.label)
		},
		_updateIcon: function (t, e) {
			var i = "iconPosition" !== t,
				n = i ? this.options.iconPosition : e,
				t = "top" === n || "bottom" === n;
			this.icon ? i && this._removeClass(this.icon, null, this.options.icon) : (this.icon = q("<span>"), this._addClass(this.icon, "ui-button-icon", "ui-icon"), this.options.showLabel || this._addClass("ui-button-icon-only")), i && this._addClass(this.icon, null, e), this._attachIcon(n), t ? (this._addClass(this.icon, null, "ui-widget-icon-block"), this.iconSpace && this.iconSpace.remove()) : (this.iconSpace || (this.iconSpace = q("<span> </span>"), this._addClass(this.iconSpace, "ui-button-icon-space")), this._removeClass(this.icon, null, "ui-wiget-icon-block"), this._attachIconSpace(n))
		},
		_destroy: function () {
			this.element.removeAttr("role"), this.icon && this.icon.remove(), this.iconSpace && this.iconSpace.remove(), this.hasTitle || this.element.removeAttr("title")
		},
		_attachIconSpace: function (t) {
			this.icon[/^(?:end|bottom)/.test(t) ? "before" : "after"](this.iconSpace)
		},
		_attachIcon: function (t) {
			this.element[/^(?:end|bottom)/.test(t) ? "append" : "prepend"](this.icon)
		},
		_setOptions: function (t) {
			var e = (void 0 === t.showLabel ? this.options : t).showLabel,
				i = (void 0 === t.icon ? this.options : t).icon;
			e || i || (t.showLabel = !0), this._super(t)
		},
		_setOption: function (t, e) {
			"icon" === t && (e ? this._updateIcon(t, e) : this.icon && (this.icon.remove(), this.iconSpace && this.iconSpace.remove())), "iconPosition" === t && this._updateIcon(t, e), "showLabel" === t && (this._toggleClass("ui-button-icon-only", null, !e), this._updateTooltip()), "label" === t && (this.isInput ? this.element.val(e) : (this.element.html(e), this.icon && (this._attachIcon(this.options.iconPosition), this._attachIconSpace(this.options.iconPosition)))), this._super(t, e), "disabled" === t && (this._toggleClass(null, "ui-state-disabled", e), (this.element[0].disabled = e) && this.element.trigger("blur"))
		},
		refresh: function () {
			var t = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
			t !== this.options.disabled && this._setOptions({
				disabled: t
			}), this._updateTooltip()
		}
	}), !1 !== q.uiBackCompat && (q.widget("ui.button", q.ui.button, {
		options: {
			text: !0,
			icons: {
				primary: null,
				secondary: null
			}
		},
		_create: function () {
			this.options.showLabel && !this.options.text && (this.options.showLabel = this.options.text), !this.options.showLabel && this.options.text && (this.options.text = this.options.showLabel), this.options.icon || !this.options.icons.primary && !this.options.icons.secondary ? this.options.icon && (this.options.icons.primary = this.options.icon) : this.options.icons.primary ? this.options.icon = this.options.icons.primary : (this.options.icon = this.options.icons.secondary, this.options.iconPosition = "end"), this._super()
		},
		_setOption: function (t, e) {
			"text" !== t ? ("showLabel" === t && (this.options.text = e), "icon" === t && (this.options.icons.primary = e), "icons" === t && (e.primary ? (this._super("icon", e.primary), this._super("iconPosition", "beginning")) : e.secondary && (this._super("icon", e.secondary), this._super("iconPosition", "end"))), this._superApply(arguments)) : this._super("showLabel", e)
		}
	}), q.fn.button = (ct = q.fn.button, function (i) {
		var t = "string" == typeof i,
			n = Array.prototype.slice.call(arguments, 1),
			s = this;
		return t ? this.length || "instance" !== i ? this.each(function () {
			var t = q(this).attr("type"),
				e = q.data(this, "ui-" + ("checkbox" !== t && "radio" !== t ? "button" : "checkboxradio"));
			return "instance" === i ? (s = e, !1) : e ? "function" != typeof e[i] || "_" === i.charAt(0) ? q.error("no such method '" + i + "' for button widget instance") : (t = e[i].apply(e, n)) !== e && void 0 !== t ? (s = t && t.jquery ? s.pushStack(t.get()) : t, !1) : void 0 : q.error("cannot call methods on button prior to initialization; attempted to call method '" + i + "'")
		}) : s = void 0 : (n.length && (i = q.widget.extend.apply(null, [i].concat(n))), this.each(function () {
			var t = q(this).attr("type"),
				e = "checkbox" !== t && "radio" !== t ? "button" : "checkboxradio",
				t = q.data(this, "ui-" + e);
			t ? (t.option(i || {}), t._init && t._init()) : "button" != e ? q(this).checkboxradio(q.extend({
				icon: !1
			}, i)) : ct.call(q(this), i)
		})), s
	}), q.fn.buttonset = function () {
		return q.ui.controlgroup || q.error("Controlgroup widget missing"), "option" === arguments[0] && "items" === arguments[1] && arguments[2] ? this.controlgroup.apply(this, [arguments[0], "items.button", arguments[2]]) : "option" === arguments[0] && "items" === arguments[1] ? this.controlgroup.apply(this, [arguments[0], "items.button"]) : ("object" == typeof arguments[0] && arguments[0].items && (arguments[0].items = {
			button: arguments[0].items
		}), this.controlgroup.apply(this, arguments))
	});
	var O;
	q.ui.button, q.extend(q.ui, {
		datepicker: {
			version: "1.13.2"
		}
	}), q.extend(N.prototype, {
		markerClassName: "hasDatepicker",
		maxRows: 4,
		_widgetDatepicker: function () {
			return this.dpDiv
		},
		setDefaults: function (t) {
			return l(this._defaults, t || {}), this
		},
		_attachDatepicker: function (t, e) {
			var i, n = t.nodeName.toLowerCase(),
				s = "div" === n || "span" === n;
			t.id || (this.uuid += 1, t.id = "dp" + this.uuid), (i = this._newInst(q(t), s)).settings = q.extend({}, e || {}), "input" === n ? this._connectDatepicker(t, i) : s && this._inlineDatepicker(t, i)
		},
		_newInst: function (t, e) {
			return {
				id: t[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"),
				input: t,
				selectedDay: 0,
				selectedMonth: 0,
				selectedYear: 0,
				drawMonth: 0,
				drawYear: 0,
				inline: e,
				dpDiv: e ? R(q("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
			}
		},
		_connectDatepicker: function (t, e) {
			var i = q(t);
			e.append = q([]), e.trigger = q([]), i.hasClass(this.markerClassName) || (this._attachments(i, e), i.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp), this._autoSize(e), q.data(t, "datepicker", e), e.settings.disabled && this._disableDatepicker(t))
		},
		_attachments: function (t, e) {
			var i, n = this._get(e, "appendText"),
				s = this._get(e, "isRTL");
			e.append && e.append.remove(), n && (e.append = q("<span>").addClass(this._appendClass).text(n), t[s ? "before" : "after"](e.append)), t.off("focus", this._showDatepicker), e.trigger && e.trigger.remove(), "focus" !== (i = this._get(e, "showOn")) && "both" !== i || t.on("focus", this._showDatepicker), "button" !== i && "both" !== i || (n = this._get(e, "buttonText"), i = this._get(e, "buttonImage"), this._get(e, "buttonImageOnly") ? e.trigger = q("<img>").addClass(this._triggerClass).attr({
				src: i,
				alt: n,
				title: n
			}) : (e.trigger = q("<button type='button'>").addClass(this._triggerClass), i ? e.trigger.html(q("<img>").attr({
				src: i,
				alt: n,
				title: n
			})) : e.trigger.text(n)), t[s ? "before" : "after"](e.trigger), e.trigger.on("click", function () {
				return q.datepicker._datepickerShowing && q.datepicker._lastInput === t[0] ? q.datepicker._hideDatepicker() : (q.datepicker._datepickerShowing && q.datepicker._lastInput !== t[0] && q.datepicker._hideDatepicker(), q.datepicker._showDatepicker(t[0])), !1
			}))
		},
		_autoSize: function (t) {
			var e, i, n, s, o, r;
			this._get(t, "autoSize") && !t.inline && (o = new Date(2009, 11, 20), (r = this._get(t, "dateFormat")).match(/[DM]/) && (e = function (t) {
				for (s = n = i = 0; s < t.length; s++) t[s].length > i && (i = t[s].length, n = s);
				return n
			}, o.setMonth(e(this._get(t, r.match(/MM/) ? "monthNames" : "monthNamesShort"))), o.setDate(e(this._get(t, r.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - o.getDay())), t.input.attr("size", this._formatDate(t, o).length))
		},
		_inlineDatepicker: function (t, e) {
			var i = q(t);
			i.hasClass(this.markerClassName) || (i.addClass(this.markerClassName).append(e.dpDiv), q.data(t, "datepicker", e), this._setDate(e, this._getDefaultDate(e), !0), this._updateDatepicker(e), this._updateAlternate(e), e.settings.disabled && this._disableDatepicker(t), e.dpDiv.css("display", "block"))
		},
		_dialogDatepicker: function (t, e, i, n, s) {
			var o, r = this._dialogInst;
			return r || (this.uuid += 1, o = "dp" + this.uuid, this._dialogInput = q("<input type='text' id='" + o + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.on("keydown", this._doKeyDown), q("body").append(this._dialogInput), (r = this._dialogInst = this._newInst(this._dialogInput, !1)).settings = {}, q.data(this._dialogInput[0], "datepicker", r)), l(r.settings, n || {}), e = e && e.constructor === Date ? this._formatDate(r, e) : e, this._dialogInput.val(e), this._pos = s ? s.length ? s : [s.pageX, s.pageY] : null, this._pos || (o = document.documentElement.clientWidth, n = document.documentElement.clientHeight, e = document.documentElement.scrollLeft || document.body.scrollLeft, s = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [o / 2 - 100 + e, n / 2 - 150 + s]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), r.settings.onSelect = i, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), q.blockUI && q.blockUI(this.dpDiv), q.data(this._dialogInput[0], "datepicker", r), this
		},
		_destroyDatepicker: function (t) {
			var e, i = q(t),
				n = q.data(t, "datepicker");
			i.hasClass(this.markerClassName) && (e = t.nodeName.toLowerCase(), q.removeData(t, "datepicker"), "input" === e ? (n.append.remove(), n.trigger.remove(), i.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp)) : "div" !== e && "span" !== e || i.removeClass(this.markerClassName).empty(), O === n && (O = null, this._curInst = null))
		},
		_enableDatepicker: function (e) {
			var t, i = q(e),
				n = q.data(e, "datepicker");
			i.hasClass(this.markerClassName) && ("input" === (t = e.nodeName.toLowerCase()) ? (e.disabled = !1, n.trigger.filter("button").each(function () {
				this.disabled = !1
			}).end().filter("img").css({
				opacity: "1.0",
				cursor: ""
			})) : "div" !== t && "span" !== t || ((i = i.children("." + this._inlineClass)).children().removeClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = q.map(this._disabledInputs, function (t) {
				return t === e ? null : t
			}))
		},
		_disableDatepicker: function (e) {
			var t, i = q(e),
				n = q.data(e, "datepicker");
			i.hasClass(this.markerClassName) && ("input" === (t = e.nodeName.toLowerCase()) ? (e.disabled = !0, n.trigger.filter("button").each(function () {
				this.disabled = !0
			}).end().filter("img").css({
				opacity: "0.5",
				cursor: "default"
			})) : "div" !== t && "span" !== t || ((i = i.children("." + this._inlineClass)).children().addClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = q.map(this._disabledInputs, function (t) {
				return t === e ? null : t
			}), this._disabledInputs[this._disabledInputs.length] = e)
		},
		_isDisabledDatepicker: function (t) {
			if (!t) return !1;
			for (var e = 0; e < this._disabledInputs.length; e++)
				if (this._disabledInputs[e] === t) return !0;
			return !1
		},
		_getInst: function (t) {
			try {
				return q.data(t, "datepicker")
			} catch (t) {
				throw "Missing instance data for this datepicker"
			}
		},
		_optionDatepicker: function (t, e, i) {
			var n, s, o = this._getInst(t);
			if (2 === arguments.length && "string" == typeof e) return "defaults" === e ? q.extend({}, q.datepicker._defaults) : o ? "all" === e ? q.extend({}, o.settings) : this._get(o, e) : null;
			n = e || {}, "string" == typeof e && ((n = {})[e] = i), o && (this._curInst === o && this._hideDatepicker(), s = this._getDateDatepicker(t, !0), e = this._getMinMaxDate(o, "min"), i = this._getMinMaxDate(o, "max"), l(o.settings, n), null !== e && void 0 !== n.dateFormat && void 0 === n.minDate && (o.settings.minDate = this._formatDate(o, e)), null !== i && void 0 !== n.dateFormat && void 0 === n.maxDate && (o.settings.maxDate = this._formatDate(o, i)), "disabled" in n && (n.disabled ? this._disableDatepicker(t) : this._enableDatepicker(t)), this._attachments(q(t), o), this._autoSize(o), this._setDate(o, s), this._updateAlternate(o), this._updateDatepicker(o))
		},
		_changeDatepicker: function (t, e, i) {
			this._optionDatepicker(t, e, i)
		},
		_refreshDatepicker: function (t) {
			(t = this._getInst(t)) && this._updateDatepicker(t)
		},
		_setDateDatepicker: function (t, e) {
			(t = this._getInst(t)) && (this._setDate(t, e), this._updateDatepicker(t), this._updateAlternate(t))
		},
		_getDateDatepicker: function (t, e) {
			return t = this._getInst(t), t && !t.inline && this._setDateFromField(t, e), t ? this._getDate(t) : null
		},
		_doKeyDown: function (t) {
			var e, i, n = q.datepicker._getInst(t.target),
				s = !0,
				o = n.dpDiv.is(".ui-datepicker-rtl");
			if (n._keyEvent = !0, q.datepicker._datepickerShowing) switch (t.keyCode) {
				case 9:
					q.datepicker._hideDatepicker(), s = !1;
					break;
				case 13:
					return (i = q("td." + q.datepicker._dayOverClass + ":not(." + q.datepicker._currentClass + ")", n.dpDiv))[0] && q.datepicker._selectDay(t.target, n.selectedMonth, n.selectedYear, i[0]), (e = q.datepicker._get(n, "onSelect")) ? (i = q.datepicker._formatDate(n), e.apply(n.input ? n.input[0] : null, [i, n])) : q.datepicker._hideDatepicker(), !1;
				case 27:
					q.datepicker._hideDatepicker();
					break;
				case 33:
					q.datepicker._adjustDate(t.target, t.ctrlKey ? -q.datepicker._get(n, "stepBigMonths") : -q.datepicker._get(n, "stepMonths"), "M");
					break;
				case 34:
					q.datepicker._adjustDate(t.target, t.ctrlKey ? +q.datepicker._get(n, "stepBigMonths") : +q.datepicker._get(n, "stepMonths"), "M");
					break;
				case 35:
					(t.ctrlKey || t.metaKey) && q.datepicker._clearDate(t.target), s = t.ctrlKey || t.metaKey;
					break;
				case 36:
					(t.ctrlKey || t.metaKey) && q.datepicker._gotoToday(t.target), s = t.ctrlKey || t.metaKey;
					break;
				case 37:
					(t.ctrlKey || t.metaKey) && q.datepicker._adjustDate(t.target, o ? 1 : -1, "D"), s = t.ctrlKey || t.metaKey, t.originalEvent.altKey && q.datepicker._adjustDate(t.target, t.ctrlKey ? -q.datepicker._get(n, "stepBigMonths") : -q.datepicker._get(n, "stepMonths"), "M");
					break;
				case 38:
					(t.ctrlKey || t.metaKey) && q.datepicker._adjustDate(t.target, -7, "D"), s = t.ctrlKey || t.metaKey;
					break;
				case 39:
					(t.ctrlKey || t.metaKey) && q.datepicker._adjustDate(t.target, o ? -1 : 1, "D"), s = t.ctrlKey || t.metaKey, t.originalEvent.altKey && q.datepicker._adjustDate(t.target, t.ctrlKey ? +q.datepicker._get(n, "stepBigMonths") : +q.datepicker._get(n, "stepMonths"), "M");
					break;
				case 40:
					(t.ctrlKey || t.metaKey) && q.datepicker._adjustDate(t.target, 7, "D"), s = t.ctrlKey || t.metaKey;
					break;
				default:
					s = !1
			} else 36 === t.keyCode && t.ctrlKey ? q.datepicker._showDatepicker(this) : s = !1;
			s && (t.preventDefault(), t.stopPropagation())
		},
		_doKeyPress: function (t) {
			var e, i = q.datepicker._getInst(t.target);
			if (q.datepicker._get(i, "constrainInput")) return e = q.datepicker._possibleChars(q.datepicker._get(i, "dateFormat")), i = String.fromCharCode(null == t.charCode ? t.keyCode : t.charCode), t.ctrlKey || t.metaKey || i < " " || !e || -1 < e.indexOf(i)
		},
		_doKeyUp: function (t) {
			if (t = q.datepicker._getInst(t.target), t.input.val() !== t.lastVal) try {
				q.datepicker.parseDate(q.datepicker._get(t, "dateFormat"), t.input ? t.input.val() : null, q.datepicker._getFormatConfig(t)) && (q.datepicker._setDateFromField(t), q.datepicker._updateAlternate(t), q.datepicker._updateDatepicker(t))
			} catch (t) { }
			return !0
		},
		_showDatepicker: function (t) {
			var e, i, n, s;
			"input" !== (t = t.target || t).nodeName.toLowerCase() && (t = q("input", t.parentNode)[0]), q.datepicker._isDisabledDatepicker(t) || q.datepicker._lastInput === t || (s = q.datepicker._getInst(t), q.datepicker._curInst && q.datepicker._curInst !== s && (q.datepicker._curInst.dpDiv.stop(!0, !0), s && q.datepicker._datepickerShowing && q.datepicker._hideDatepicker(q.datepicker._curInst.input[0])), !1 !== (i = (n = q.datepicker._get(s, "beforeShow")) ? n.apply(t, [t, s]) : {}) && (l(s.settings, i), s.lastVal = null, q.datepicker._lastInput = t, q.datepicker._setDateFromField(s), q.datepicker._inDialog && (t.value = ""), q.datepicker._pos || (q.datepicker._pos = q.datepicker._findPos(t), q.datepicker._pos[1] += t.offsetHeight), e = !1, q(t).parents().each(function () {
				return !(e |= "fixed" === q(this).css("position"))
			}), n = {
				left: q.datepicker._pos[0],
				top: q.datepicker._pos[1]
			}, q.datepicker._pos = null, s.dpDiv.empty(), s.dpDiv.css({
				position: "absolute",
				display: "block",
				top: "-1000px"
			}), q.datepicker._updateDatepicker(s), n = q.datepicker._checkOffset(s, n, e), s.dpDiv.css({
				position: q.datepicker._inDialog && q.blockUI ? "static" : e ? "fixed" : "absolute",
				display: "none",
				left: n.left + "px",
				top: n.top + "px"
			}), s.inline || (i = q.datepicker._get(s, "showAnim"), n = q.datepicker._get(s, "duration"), s.dpDiv.css("z-index", function (t) {
				for (var e, i; t.length && t[0] !== document;) {
					if (("absolute" === (e = t.css("position")) || "relative" === e || "fixed" === e) && (i = parseInt(t.css("zIndex"), 10), !isNaN(i) && 0 !== i)) return i;
					t = t.parent()
				}
				return 0
			}(q(t)) + 1), q.datepicker._datepickerShowing = !0, q.effects && q.effects.effect[i] ? s.dpDiv.show(i, q.datepicker._get(s, "showOptions"), n) : s.dpDiv[i || "show"](i ? n : null), q.datepicker._shouldFocusInput(s) && s.input.trigger("focus"), q.datepicker._curInst = s)))
		},
		_updateDatepicker: function (t) {
			this.maxRows = 4, (O = t).dpDiv.empty().append(this._generateHTML(t)), this._attachHandlers(t);
			var e, i = this._getNumberOfMonths(t),
				n = i[1],
				s = t.dpDiv.find("." + this._dayOverClass + " a"),
				o = q.datepicker._get(t, "onUpdateDatepicker");
			0 < s.length && F.apply(s.get(0)), t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), 1 < n && t.dpDiv.addClass("ui-datepicker-multi-" + n).css("width", 17 * n + "em"), t.dpDiv[(1 !== i[0] || 1 !== i[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), t.dpDiv[(this._get(t, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), t === q.datepicker._curInst && q.datepicker._datepickerShowing && q.datepicker._shouldFocusInput(t) && t.input.trigger("focus"), t.yearshtml && (e = t.yearshtml, setTimeout(function () {
				e === t.yearshtml && t.yearshtml && t.dpDiv.find("select.ui-datepicker-year").first().replaceWith(t.yearshtml), e = t.yearshtml = null
			}, 0)), o && o.apply(t.input ? t.input[0] : null, [t])
		},
		_shouldFocusInput: function (t) {
			return t.input && t.input.is(":visible") && !t.input.is(":disabled") && !t.input.is(":focus")
		},
		_checkOffset: function (t, e, i) {
			var n = t.dpDiv.outerWidth(),
				s = t.dpDiv.outerHeight(),
				o = t.input ? t.input.outerWidth() : 0,
				r = t.input ? t.input.outerHeight() : 0,
				a = document.documentElement.clientWidth + (i ? 0 : q(document).scrollLeft()),
				l = document.documentElement.clientHeight + (i ? 0 : q(document).scrollTop());
			return e.left -= this._get(t, "isRTL") ? n - o : 0, e.left -= i && e.left === t.input.offset().left ? q(document).scrollLeft() : 0, e.top -= i && e.top === t.input.offset().top + r ? q(document).scrollTop() : 0, e.left -= Math.min(e.left, e.left + n > a && n < a ? Math.abs(e.left + n - a) : 0), e.top -= Math.min(e.top, e.top + s > l && s < l ? Math.abs(s + r) : 0), e
		},
		_findPos: function (t) {
			for (var e = this._getInst(t), i = this._get(e, "isRTL"); t && ("hidden" === t.type || 1 !== t.nodeType || q.expr.pseudos.hidden(t));) t = t[i ? "previousSibling" : "nextSibling"];
			return [(e = q(t).offset()).left, e.top]
		},
		_hideDatepicker: function (t) {
			var e, i, n = this._curInst;
			!n || t && n !== q.data(t, "datepicker") || this._datepickerShowing && (e = this._get(n, "showAnim"), i = this._get(n, "duration"), t = function () {
				q.datepicker._tidyDialog(n)
			}, q.effects && (q.effects.effect[e] || q.effects[e]) ? n.dpDiv.hide(e, q.datepicker._get(n, "showOptions"), i, t) : n.dpDiv["slideDown" === e ? "slideUp" : "fadeIn" === e ? "fadeOut" : "hide"](e ? i : null, t), e || t(), this._datepickerShowing = !1, (t = this._get(n, "onClose")) && t.apply(n.input ? n.input[0] : null, [n.input ? n.input.val() : "", n]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
				position: "absolute",
				left: "0",
				top: "-100px"
			}), q.blockUI && (q.unblockUI(), q("body").append(this.dpDiv))), this._inDialog = !1)
		},
		_tidyDialog: function (t) {
			t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")
		},
		_checkExternalClick: function (t) {
			var e;
			q.datepicker._curInst && (e = q(t.target), t = q.datepicker._getInst(e[0]), (e[0].id === q.datepicker._mainDivId || 0 !== e.parents("#" + q.datepicker._mainDivId).length || e.hasClass(q.datepicker.markerClassName) || e.closest("." + q.datepicker._triggerClass).length || !q.datepicker._datepickerShowing || q.datepicker._inDialog && q.blockUI) && (!e.hasClass(q.datepicker.markerClassName) || q.datepicker._curInst === t) || q.datepicker._hideDatepicker())
		},
		_adjustDate: function (t, e, i) {
			var n = q(t),
				t = this._getInst(n[0]);
			this._isDisabledDatepicker(n[0]) || (this._adjustInstDate(t, e, i), this._updateDatepicker(t))
		},
		_gotoToday: function (t) {
			var e = q(t),
				i = this._getInst(e[0]);
			this._get(i, "gotoCurrent") && i.currentDay ? (i.selectedDay = i.currentDay, i.drawMonth = i.selectedMonth = i.currentMonth, i.drawYear = i.selectedYear = i.currentYear) : (t = new Date, i.selectedDay = t.getDate(), i.drawMonth = i.selectedMonth = t.getMonth(), i.drawYear = i.selectedYear = t.getFullYear()), this._notifyChange(i), this._adjustDate(e)
		},
		_selectMonthYear: function (t, e, i) {
			var n = q(t),
				t = this._getInst(n[0]);
			t["selected" + ("M" === i ? "Month" : "Year")] = t["draw" + ("M" === i ? "Month" : "Year")] = parseInt(e.options[e.selectedIndex].value, 10), this._notifyChange(t), this._adjustDate(n)
		},
		_selectDay: function (t, e, i, n) {
			var s = q(t);
			q(n).hasClass(this._unselectableClass) || this._isDisabledDatepicker(s[0]) || ((s = this._getInst(s[0])).selectedDay = s.currentDay = parseInt(q("a", n).attr("data-date")), s.selectedMonth = s.currentMonth = e, s.selectedYear = s.currentYear = i, this._selectDate(t, this._formatDate(s, s.currentDay, s.currentMonth, s.currentYear)))
		},
		_clearDate: function (t) {
			t = q(t), this._selectDate(t, "")
		},
		_selectDate: function (t, e) {
			var i = q(t),
				t = this._getInst(i[0]);
			e = null != e ? e : this._formatDate(t), t.input && t.input.val(e), this._updateAlternate(t), (i = this._get(t, "onSelect")) ? i.apply(t.input ? t.input[0] : null, [e, t]) : t.input && t.input.trigger("change"), t.inline ? this._updateDatepicker(t) : (this._hideDatepicker(), this._lastInput = t.input[0], "object" != typeof t.input[0] && t.input.trigger("focus"), this._lastInput = null)
		},
		_updateAlternate: function (t) {
			var e, i, n = this._get(t, "altField");
			n && (e = this._get(t, "altFormat") || this._get(t, "dateFormat"), i = this._getDate(t), t = this.formatDate(e, i, this._getFormatConfig(t)), q(document).find(n).val(t))
		},
		noWeekends: function (t) {
			return t = t.getDay(), [0 < t && t < 6, ""]
		},
		iso8601Week: function (t) {
			var e = new Date(t.getTime());
			return e.setDate(e.getDate() + 4 - (e.getDay() || 7)), t = e.getTime(), e.setMonth(0), e.setDate(1), Math.floor(Math.round((t - e) / 864e5) / 7) + 1
		},
		parseDate: function (e, s, t) {
			if (null == e || null == s) throw "Invalid arguments";
			if ("" === (s = "object" == typeof s ? s.toString() : s + "")) return null;
			for (var i, n, o, r = 0, a = (t ? t.shortYearCutoff : null) || this._defaults.shortYearCutoff, a = "string" != typeof a ? a : (new Date).getFullYear() % 100 + parseInt(a, 10), l = (t ? t.dayNamesShort : null) || this._defaults.dayNamesShort, h = (t ? t.dayNames : null) || this._defaults.dayNames, c = (t ? t.monthNamesShort : null) || this._defaults.monthNamesShort, u = (t ? t.monthNames : null) || this._defaults.monthNames, d = -1, f = -1, p = -1, g = -1, m = !1, v = function (t) {
				return t = x + 1 < e.length && e.charAt(x + 1) === t, t && x++, t
			}, b = function (t) {
				var e = v(t),
					e = "@" === t ? 14 : "!" === t ? 20 : "y" === t && e ? 4 : "o" === t ? 3 : 2,
					e = new RegExp("^\\d{" + ("y" === t ? e : 1) + "," + e + "}"),
					e = s.substring(r).match(e);
				if (!e) throw "Missing number at position " + r;
				return r += e[0].length, parseInt(e[0], 10)
			}, _ = function (t, e, i) {
				var n = -1,
					e = q.map(v(t) ? i : e, function (t, e) {
						return [
							[e, t]
						]
					}).sort(function (t, e) {
						return -(t[1].length - e[1].length)
					});
				if (q.each(e, function (t, e) {
					var i = e[1];
					if (s.substr(r, i.length).toLowerCase() === i.toLowerCase()) return n = e[0], r += i.length, !1
				}), -1 !== n) return n + 1;
				throw "Unknown name at position " + r
			}, y = function () {
				if (s.charAt(r) !== e.charAt(x)) throw "Unexpected literal at position " + r;
				r++
			}, x = 0; x < e.length; x++)
				if (m) "'" !== e.charAt(x) || v("'") ? y() : m = !1;
				else switch (e.charAt(x)) {
					case "d":
						p = b("d");
						break;
					case "D":
						_("D", l, h);
						break;
					case "o":
						g = b("o");
						break;
					case "m":
						f = b("m");
						break;
					case "M":
						f = _("M", c, u);
						break;
					case "y":
						d = b("y");
						break;
					case "@":
						d = (o = new Date(b("@"))).getFullYear(), f = o.getMonth() + 1, p = o.getDate();
						break;
					case "!":
						d = (o = new Date((b("!") - this._ticksTo1970) / 1e4)).getFullYear(), f = o.getMonth() + 1, p = o.getDate();
						break;
					case "'":
						v("'") ? y() : m = !0;
						break;
					default:
						y()
				}
			if (r < s.length && (n = s.substr(r), !/^\s+/.test(n))) throw "Extra/unparsed characters found in date: " + n;
			if (-1 === d ? d = (new Date).getFullYear() : d < 100 && (d += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (d <= a ? 0 : -100)), -1 < g)
				for (f = 1, p = g; !(p <= (i = this._getDaysInMonth(d, f - 1)));) f++, p -= i;
			if ((o = this._daylightSavingAdjust(new Date(d, f - 1, p))).getFullYear() !== d || o.getMonth() + 1 !== f || o.getDate() !== p) throw "Invalid date";
			return o
		},
		ATOM: "yy-mm-dd",
		COOKIE: "D, dd M yy",
		ISO_8601: "yy-mm-dd",
		RFC_822: "D, d M y",
		RFC_850: "DD, dd-M-y",
		RFC_1036: "D, d M y",
		RFC_1123: "D, d M yy",
		RFC_2822: "D, d M yy",
		RSS: "D, d M y",
		TICKS: "!",
		TIMESTAMP: "@",
		W3C: "yy-mm-dd",
		_ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7,
		formatDate: function (e, t, i) {
			function n(t, e, i) {
				var n = "" + e;
				if (c(t))
					for (; n.length < i;) n = "0" + n;
				return n
			}

			function s(t, e, i, n) {
				return (c(t) ? n : i)[e]
			}
			if (!t) return "";
			var o, r = (i ? i.dayNamesShort : null) || this._defaults.dayNamesShort,
				a = (i ? i.dayNames : null) || this._defaults.dayNames,
				l = (i ? i.monthNamesShort : null) || this._defaults.monthNamesShort,
				h = (i ? i.monthNames : null) || this._defaults.monthNames,
				c = function (t) {
					return t = o + 1 < e.length && e.charAt(o + 1) === t, t && o++, t
				},
				u = "",
				d = !1;
			if (t)
				for (o = 0; o < e.length; o++)
					if (d) "'" !== e.charAt(o) || c("'") ? u += e.charAt(o) : d = !1;
					else switch (e.charAt(o)) {
						case "d":
							u += n("d", t.getDate(), 2);
							break;
						case "D":
							u += s("D", t.getDay(), r, a);
							break;
						case "o":
							u += n("o", Math.round((new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() - new Date(t.getFullYear(), 0, 0).getTime()) / 864e5), 3);
							break;
						case "m":
							u += n("m", t.getMonth() + 1, 2);
							break;
						case "M":
							u += s("M", t.getMonth(), l, h);
							break;
						case "y":
							u += c("y") ? t.getFullYear() : (t.getFullYear() % 100 < 10 ? "0" : "") + t.getFullYear() % 100;
							break;
						case "@":
							u += t.getTime();
							break;
						case "!":
							u += 1e4 * t.getTime() + this._ticksTo1970;
							break;
						case "'":
							c("'") ? u += "'" : d = !0;
							break;
						default:
							u += e.charAt(o)
					}
			return u
		},
		_possibleChars: function (e) {
			for (var t = "", i = !1, n = function (t) {
				return t = s + 1 < e.length && e.charAt(s + 1) === t, t && s++, t
			}, s = 0; s < e.length; s++)
				if (i) "'" !== e.charAt(s) || n("'") ? t += e.charAt(s) : i = !1;
				else switch (e.charAt(s)) {
					case "d":
					case "m":
					case "y":
					case "@":
						t += "0123456789";
						break;
					case "D":
					case "M":
						return null;
					case "'":
						n("'") ? t += "'" : i = !0;
						break;
					default:
						t += e.charAt(s)
				}
			return t
		},
		_get: function (t, e) {
			return (void 0 !== t.settings[e] ? t.settings : this._defaults)[e]
		},
		_setDateFromField: function (t, e) {
			if (t.input.val() !== t.lastVal) {
				var i = this._get(t, "dateFormat"),
					n = t.lastVal = t.input ? t.input.val() : null,
					s = this._getDefaultDate(t),
					o = s,
					r = this._getFormatConfig(t);
				try {
					o = this.parseDate(i, n, r) || s
				} catch (t) {
					n = e ? "" : n
				}
				t.selectedDay = o.getDate(), t.drawMonth = t.selectedMonth = o.getMonth(), t.drawYear = t.selectedYear = o.getFullYear(), t.currentDay = n ? o.getDate() : 0, t.currentMonth = n ? o.getMonth() : 0, t.currentYear = n ? o.getFullYear() : 0, this._adjustInstDate(t)
			}
		},
		_getDefaultDate: function (t) {
			return this._restrictMinMax(t, this._determineDate(t, this._get(t, "defaultDate"), new Date))
		},
		_determineDate: function (a, t, e) {
			var i, n, t = null == t || "" === t ? e : "string" == typeof t ? function (t) {
				try {
					return q.datepicker.parseDate(q.datepicker._get(a, "dateFormat"), t, q.datepicker._getFormatConfig(a))
				} catch (t) { }
				for (var e = (t.toLowerCase().match(/^c/) ? q.datepicker._getDate(a) : null) || new Date, i = e.getFullYear(), n = e.getMonth(), s = e.getDate(), o = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, r = o.exec(t); r;) {
					switch (r[2] || "d") {
						case "d":
						case "D":
							s += parseInt(r[1], 10);
							break;
						case "w":
						case "W":
							s += 7 * parseInt(r[1], 10);
							break;
						case "m":
						case "M":
							n += parseInt(r[1], 10), s = Math.min(s, q.datepicker._getDaysInMonth(i, n));
							break;
						case "y":
						case "Y":
							i += parseInt(r[1], 10), s = Math.min(s, q.datepicker._getDaysInMonth(i, n))
					}
					r = o.exec(t)
				}
				return new Date(i, n, s)
			}(t) : "number" == typeof t ? isNaN(t) ? e : (i = t, (n = new Date).setDate(n.getDate() + i), n) : new Date(t.getTime());
			return (t = t && "Invalid Date" === t.toString() ? e : t) && (t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)), this._daylightSavingAdjust(t)
		},
		_daylightSavingAdjust: function (t) {
			return t ? (t.setHours(12 < t.getHours() ? t.getHours() + 2 : 0), t) : null
		},
		_setDate: function (t, e, i) {
			var n = !e,
				s = t.selectedMonth,
				o = t.selectedYear,
				e = this._restrictMinMax(t, this._determineDate(t, e, new Date));
			t.selectedDay = t.currentDay = e.getDate(), t.drawMonth = t.selectedMonth = t.currentMonth = e.getMonth(), t.drawYear = t.selectedYear = t.currentYear = e.getFullYear(), s === t.selectedMonth && o === t.selectedYear || i || this._notifyChange(t), this._adjustInstDate(t), t.input && t.input.val(n ? "" : this._formatDate(t))
		},
		_getDate: function (t) {
			return !t.currentYear || t.input && "" === t.input.val() ? null : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay))
		},
		_attachHandlers: function (t) {
			var e = this._get(t, "stepMonths"),
				i = "#" + t.id.replace(/\\\\/g, "\\");
			t.dpDiv.find("[data-handler]").map(function () {
				var t = {
					prev: function () {
						q.datepicker._adjustDate(i, -e, "M")
					},
					next: function () {
						q.datepicker._adjustDate(i, +e, "M")
					},
					hide: function () {
						q.datepicker._hideDatepicker()
					},
					today: function () {
						q.datepicker._gotoToday(i)
					},
					selectDay: function () {
						return q.datepicker._selectDay(i, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1
					},
					selectMonth: function () {
						return q.datepicker._selectMonthYear(i, this, "M"), !1
					},
					selectYear: function () {
						return q.datepicker._selectMonthYear(i, this, "Y"), !1
					}
				};
				q(this).on(this.getAttribute("data-event"), t[this.getAttribute("data-handler")])
			})
		},
		_generateHTML: function (t) {
			var e, i, n, s, o, R, F, H, z, r, a, W, l, h, c, u, d, f, p, g, m, v, B, b, _, y, x, j, Y, w, k, C, D = new Date,
				V = this._daylightSavingAdjust(new Date(D.getFullYear(), D.getMonth(), D.getDate())),
				M = this._get(t, "isRTL"),
				$ = this._get(t, "showButtonPanel"),
				T = this._get(t, "hideIfNoPrevNext"),
				S = this._get(t, "navigationAsDateFormat"),
				P = this._getNumberOfMonths(t),
				I = this._get(t, "showCurrentAtPos"),
				D = this._get(t, "stepMonths"),
				U = 1 !== P[0] || 1 !== P[1],
				E = this._daylightSavingAdjust(t.currentDay ? new Date(t.currentYear, t.currentMonth, t.currentDay) : new Date(9999, 9, 9)),
				O = this._getMinMaxDate(t, "min"),
				A = this._getMinMaxDate(t, "max"),
				L = t.drawMonth - I,
				N = t.drawYear;
			if (L < 0 && (L += 12, N--), A)
				for (e = this._daylightSavingAdjust(new Date(A.getFullYear(), A.getMonth() - P[0] * P[1] + 1, A.getDate())), e = O && e < O ? O : e; this._daylightSavingAdjust(new Date(N, L, 1)) > e;) --L < 0 && (L = 11, N--);
			for (t.drawMonth = L, t.drawYear = N, I = this._get(t, "prevText"), I = S ? this.formatDate(I, this._daylightSavingAdjust(new Date(N, L - D, 1)), this._getFormatConfig(t)) : I, i = this._canAdjustMonth(t, -1, N, L) ? q("<a>").attr({
				class: "ui-datepicker-prev ui-corner-all",
				"data-handler": "prev",
				"data-event": "click",
				title: I
			}).append(q("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (M ? "e" : "w")).text(I))[0].outerHTML : T ? "" : q("<a>").attr({
				class: "ui-datepicker-prev ui-corner-all ui-state-disabled",
				title: I
			}).append(q("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (M ? "e" : "w")).text(I))[0].outerHTML, I = this._get(t, "nextText"), I = S ? this.formatDate(I, this._daylightSavingAdjust(new Date(N, L + D, 1)), this._getFormatConfig(t)) : I, n = this._canAdjustMonth(t, 1, N, L) ? q("<a>").attr({
				class: "ui-datepicker-next ui-corner-all",
				"data-handler": "next",
				"data-event": "click",
				title: I
			}).append(q("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (M ? "w" : "e")).text(I))[0].outerHTML : T ? "" : q("<a>").attr({
				class: "ui-datepicker-next ui-corner-all ui-state-disabled",
				title: I
			}).append(q("<span>").attr("class", "ui-icon ui-icon-circle-triangle-" + (M ? "w" : "e")).text(I))[0].outerHTML, D = this._get(t, "currentText"), T = this._get(t, "gotoCurrent") && t.currentDay ? E : V, D = S ? this.formatDate(D, T, this._getFormatConfig(t)) : D, I = "", t.inline || (I = q("<button>").attr({
				type: "button",
				class: "ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all",
				"data-handler": "hide",
				"data-event": "click"
			}).text(this._get(t, "closeText"))[0].outerHTML), S = "", $ && (S = q("<div class='ui-datepicker-buttonpane ui-widget-content'>").append(M ? I : "").append(this._isInRange(t, T) ? q("<button>").attr({
				type: "button",
				class: "ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all",
				"data-handler": "today",
				"data-event": "click"
			}).text(D) : "").append(M ? "" : I)[0].outerHTML), s = parseInt(this._get(t, "firstDay"), 10), s = isNaN(s) ? 0 : s, o = this._get(t, "showWeek"), R = this._get(t, "dayNames"), F = this._get(t, "dayNamesMin"), H = this._get(t, "monthNames"), z = this._get(t, "monthNamesShort"), r = this._get(t, "beforeShowDay"), a = this._get(t, "showOtherMonths"), W = this._get(t, "selectOtherMonths"), l = this._getDefaultDate(t), h = "", u = 0; u < P[0]; u++) {
				for (d = "", this.maxRows = 4, f = 0; f < P[1]; f++) {
					if (p = this._daylightSavingAdjust(new Date(N, L, t.selectedDay)), g = " ui-corner-all", m = "", U) {
						if (m += "<div class='ui-datepicker-group", 1 < P[1]) switch (f) {
							case 0:
								m += " ui-datepicker-group-first", g = " ui-corner-" + (M ? "right" : "left");
								break;
							case P[1] - 1:
								m += " ui-datepicker-group-last", g = " ui-corner-" + (M ? "left" : "right");
								break;
							default:
								m += " ui-datepicker-group-middle", g = ""
						}
						m += "'>"
					}
					for (m += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + g + "'>" + (/all|left/.test(g) && 0 === u ? M ? n : i : "") + (/all|right/.test(g) && 0 === u ? M ? i : n : "") + this._generateMonthYearHeader(t, L, N, O, A, 0 < u || 0 < f, H, z) + "</div><table class='ui-datepicker-calendar'><thead><tr>", v = o ? "<th class='ui-datepicker-week-col'>" + this._get(t, "weekHeader") + "</th>" : "", c = 0; c < 7; c++) v += "<th scope='col'" + (5 <= (c + s + 6) % 7 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + R[B = (c + s) % 7] + "'>" + F[B] + "</span></th>";
					for (m += v + "</tr></thead><tbody>", _ = this._getDaysInMonth(N, L), N === t.selectedYear && L === t.selectedMonth && (t.selectedDay = Math.min(t.selectedDay, _)), b = (this._getFirstDayOfMonth(N, L) - s + 7) % 7, _ = Math.ceil((b + _) / 7), y = U && this.maxRows > _ ? this.maxRows : _, this.maxRows = y, x = this._daylightSavingAdjust(new Date(N, L, 1 - b)), j = 0; j < y; j++) {
						for (m += "<tr>", Y = o ? "<td class='ui-datepicker-week-col'>" + this._get(t, "calculateWeek")(x) + "</td>" : "", c = 0; c < 7; c++) w = r ? r.apply(t.input ? t.input[0] : null, [x]) : [!0, ""], C = (k = x.getMonth() !== L) && !W || !w[0] || O && x < O || A && A < x, Y += "<td class='" + (5 <= (c + s + 6) % 7 ? " ui-datepicker-week-end" : "") + (k ? " ui-datepicker-other-month" : "") + (x.getTime() === p.getTime() && L === t.selectedMonth && t._keyEvent || l.getTime() === x.getTime() && l.getTime() === p.getTime() ? " " + this._dayOverClass : "") + (C ? " " + this._unselectableClass + " ui-state-disabled" : "") + (k && !a ? "" : " " + w[1] + (x.getTime() === E.getTime() ? " " + this._currentClass : "") + (x.getTime() === V.getTime() ? " ui-datepicker-today" : "")) + "'" + (k && !a || !w[2] ? "" : " title='" + w[2].replace(/'/g, "&#39;") + "'") + (C ? "" : " data-handler='selectDay' data-event='click' data-month='" + x.getMonth() + "' data-year='" + x.getFullYear() + "'") + ">" + (k && !a ? "&#xa0;" : C ? "<span class='ui-state-default'>" + x.getDate() + "</span>" : "<a class='ui-state-default" + (x.getTime() === V.getTime() ? " ui-state-highlight" : "") + (x.getTime() === E.getTime() ? " ui-state-active" : "") + (k ? " ui-priority-secondary" : "") + "' href='#' aria-current='" + (x.getTime() === E.getTime() ? "true" : "false") + "' data-date='" + x.getDate() + "'>" + x.getDate() + "</a>") + "</td>", x.setDate(x.getDate() + 1), x = this._daylightSavingAdjust(x);
						m += Y + "</tr>"
					}
					11 < ++L && (L = 0, N++), d += m += "</tbody></table>" + (U ? "</div>" + (0 < P[0] && f === P[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "")
				}
				h += d
			}
			return h += S, t._keyEvent = !1, h
		},
		_generateMonthYearHeader: function (t, e, i, n, s, o, r, a) {
			var l, h, c, u, d, f, p = this._get(t, "changeMonth"),
				g = this._get(t, "changeYear"),
				m = this._get(t, "showMonthAfterYear"),
				v = this._get(t, "selectMonthLabel"),
				b = this._get(t, "selectYearLabel"),
				_ = "<div class='ui-datepicker-title'>",
				y = "";
			if (o || !p) y += "<span class='ui-datepicker-month'>" + r[e] + "</span>";
			else {
				for (l = n && n.getFullYear() === i, h = s && s.getFullYear() === i, y += "<select class='ui-datepicker-month' aria-label='" + v + "' data-handler='selectMonth' data-event='change'>", c = 0; c < 12; c++)(!l || c >= n.getMonth()) && (!h || c <= s.getMonth()) && (y += "<option value='" + c + "'" + (c === e ? " selected='selected'" : "") + ">" + a[c] + "</option>");
				y += "</select>"
			}
			if (m || (_ += y + (!o && p && g ? "" : "&#xa0;")), !t.yearshtml)
				if (t.yearshtml = "", o || !g) _ += "<span class='ui-datepicker-year'>" + i + "</span>";
				else {
					for (r = this._get(t, "yearRange").split(":"), u = (new Date).getFullYear(), d = (v = function (t) {
						return t = t.match(/c[+\-].*/) ? i + parseInt(t.substring(1), 10) : t.match(/[+\-].*/) ? u + parseInt(t, 10) : parseInt(t, 10), isNaN(t) ? u : t
					})(r[0]), f = Math.max(d, v(r[1] || "")), d = n ? Math.max(d, n.getFullYear()) : d, f = s ? Math.min(f, s.getFullYear()) : f, t.yearshtml += "<select class='ui-datepicker-year' aria-label='" + b + "' data-handler='selectYear' data-event='change'>"; d <= f; d++) t.yearshtml += "<option value='" + d + "'" + (d === i ? " selected='selected'" : "") + ">" + d + "</option>";
					t.yearshtml += "</select>", _ += t.yearshtml, t.yearshtml = null
				}
			return _ += this._get(t, "yearSuffix"), m && (_ += (!o && p && g ? "" : "&#xa0;") + y), _ += "</div>"
		},
		_adjustInstDate: function (t, e, i) {
			var n = t.selectedYear + ("Y" === i ? e : 0),
				s = t.selectedMonth + ("M" === i ? e : 0),
				e = Math.min(t.selectedDay, this._getDaysInMonth(n, s)) + ("D" === i ? e : 0),
				e = this._restrictMinMax(t, this._daylightSavingAdjust(new Date(n, s, e)));
			t.selectedDay = e.getDate(), t.drawMonth = t.selectedMonth = e.getMonth(), t.drawYear = t.selectedYear = e.getFullYear(), "M" !== i && "Y" !== i || this._notifyChange(t)
		},
		_restrictMinMax: function (t, e) {
			var i = this._getMinMaxDate(t, "min"),
				t = this._getMinMaxDate(t, "max"),
				e = i && e < i ? i : e;
			return t && t < e ? t : e
		},
		_notifyChange: function (t) {
			var e = this._get(t, "onChangeMonthYear");
			e && e.apply(t.input ? t.input[0] : null, [t.selectedYear, t.selectedMonth + 1, t])
		},
		_getNumberOfMonths: function (t) {
			return t = this._get(t, "numberOfMonths"), null == t ? [1, 1] : "number" == typeof t ? [1, t] : t
		},
		_getMinMaxDate: function (t, e) {
			return this._determineDate(t, this._get(t, e + "Date"), null)
		},
		_getDaysInMonth: function (t, e) {
			return 32 - this._daylightSavingAdjust(new Date(t, e, 32)).getDate()
		},
		_getFirstDayOfMonth: function (t, e) {
			return new Date(t, e, 1).getDay()
		},
		_canAdjustMonth: function (t, e, i, n) {
			var s = this._getNumberOfMonths(t),
				s = this._daylightSavingAdjust(new Date(i, n + (e < 0 ? e : s[0] * s[1]), 1));
			return e < 0 && s.setDate(this._getDaysInMonth(s.getFullYear(), s.getMonth())), this._isInRange(t, s)
		},
		_isInRange: function (t, e) {
			var i = this._getMinMaxDate(t, "min"),
				n = this._getMinMaxDate(t, "max"),
				s = null,
				o = null,
				r = this._get(t, "yearRange");
			return r && (t = r.split(":"), r = (new Date).getFullYear(), s = parseInt(t[0], 10), o = parseInt(t[1], 10), t[0].match(/[+\-].*/) && (s += r), t[1].match(/[+\-].*/) && (o += r)), (!i || e.getTime() >= i.getTime()) && (!n || e.getTime() <= n.getTime()) && (!s || e.getFullYear() >= s) && (!o || e.getFullYear() <= o)
		},
		_getFormatConfig: function (t) {
			var e = this._get(t, "shortYearCutoff");
			return {
				shortYearCutoff: e = "string" != typeof e ? e : (new Date).getFullYear() % 100 + parseInt(e, 10),
				dayNamesShort: this._get(t, "dayNamesShort"),
				dayNames: this._get(t, "dayNames"),
				monthNamesShort: this._get(t, "monthNamesShort"),
				monthNames: this._get(t, "monthNames")
			}
		},
		_formatDate: function (t, e, i, n) {
			return e || (t.currentDay = t.selectedDay, t.currentMonth = t.selectedMonth, t.currentYear = t.selectedYear), e = e ? "object" == typeof e ? e : this._daylightSavingAdjust(new Date(n, i, e)) : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay)), this.formatDate(this._get(t, "dateFormat"), e, this._getFormatConfig(t))
		}
	}), q.fn.datepickerrange = function (t) {
		if (!this.length) return this;
		q.datepicker.initialized || (q(document).on("mousedown", q.datepicker._checkExternalClick), q.datepicker.initialized = !0), 0 === q("#" + q.datepicker._mainDivId).length && q("body").append(q.datepicker.dpDiv);
		var e = Array.prototype.slice.call(arguments, 1);
		return "string" == typeof t && ("isDisabled" === t || "getDate" === t || "widget" === t) || "option" === t && 2 === arguments.length && "string" == typeof arguments[1] ? q.datepicker["_" + t + "Datepicker"].apply(q.datepicker, [this[0]].concat(e)) : this.each(function () {
			"string" == typeof t ? q.datepicker["_" + t + "Datepicker"].apply(q.datepicker, [this].concat(e)) : q.datepicker._attachDatepicker(this, t)
		})
	}, q.datepicker = new N, q.datepicker.initialized = !1, q.datepicker.uuid = (new Date).getTime(), q.datepicker.version = "1.13.2", q.datepicker, q.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
	var A = !1;
	q(document).on("mouseup", function () {
		A = !1
	}), q.widget("ui.mouse", {
		version: "1.13.2",
		options: {
			cancel: "input, textarea, button, select, option",
			distance: 1,
			delay: 0
		},
		_mouseInit: function () {
			var e = this;
			this.element.on("mousedown." + this.widgetName, function (t) {
				return e._mouseDown(t)
			}).on("click." + this.widgetName, function (t) {
				if (!0 === q.data(t.target, e.widgetName + ".preventClickEvent")) return q.removeData(t.target, e.widgetName + ".preventClickEvent"), t.stopImmediatePropagation(), !1
			}), this.started = !1
		},
		_mouseDestroy: function () {
			this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate)
		},
		_mouseDown: function (t) {
			if (!A) {
				this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
				var e = this,
					i = 1 === t.which,
					n = !("string" != typeof this.options.cancel || !t.target.nodeName) && q(t.target).closest(this.options.cancel).length;
				return !(i && !n && this._mouseCapture(t)) || (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
					e.mouseDelayMet = !0
				}, this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t), !this._mouseStarted) ? (t.preventDefault(), !0) : (!0 === q.data(t.target, this.widgetName + ".preventClickEvent") && q.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (t) {
					return e._mouseMove(t)
				}, this._mouseUpDelegate = function (t) {
					return e._mouseUp(t)
				}, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), A = !0))
			}
		},
		_mouseMove: function (t) {
			if (this._mouseMoved) {
				if (q.ui.ie && (!document.documentMode || document.documentMode < 9) && !t.button) return this._mouseUp(t);
				if (!t.which)
					if (t.originalEvent.altKey || t.originalEvent.ctrlKey || t.originalEvent.metaKey || t.originalEvent.shiftKey) this.ignoreMissingWhich = !0;
					else if (!this.ignoreMissingWhich) return this._mouseUp(t)
			}
			return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t), this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
		},
		_mouseUp: function (t) {
			this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && q.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, A = !1, t.preventDefault()
		},
		_mouseDistanceMet: function (t) {
			return Math.max(Math.abs(this._mouseDownEvent.pageX - t.pageX), Math.abs(this._mouseDownEvent.pageY - t.pageY)) >= this.options.distance
		},
		_mouseDelayMet: function () {
			return this.mouseDelayMet
		},
		_mouseStart: function () { },
		_mouseDrag: function () { },
		_mouseStop: function () { },
		_mouseCapture: function () {
			return !0
		}
	}), q.ui.plugin = {
		add: function (t, e, i) {
			var n, s = q.ui[t].prototype;
			for (n in i) s.plugins[n] = s.plugins[n] || [], s.plugins[n].push([e, i[n]])
		},
		call: function (t, e, i, n) {
			var s, o = t.plugins[e];
			if (o && (n || t.element[0].parentNode && 11 !== t.element[0].parentNode.nodeType))
				for (s = 0; s < o.length; s++) t.options[o[s][0]] && o[s][1].apply(t.element, i)
		}
	}, q.ui.safeBlur = function (t) {
		t && "body" !== t.nodeName.toLowerCase() && q(t).trigger("blur")
	}, q.widget("ui.draggable", q.ui.mouse, {
		version: "1.13.2",
		widgetEventPrefix: "drag",
		options: {
			addClasses: !0,
			appendTo: "parent",
			axis: !1,
			connectToSortable: !1,
			containment: !1,
			cursor: "auto",
			cursorAt: !1,
			grid: !1,
			handle: !1,
			helper: "original",
			iframeFix: !1,
			opacity: !1,
			refreshPositions: !1,
			revert: !1,
			revertDuration: 500,
			scope: "default",
			scroll: !0,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			snap: !1,
			snapMode: "both",
			snapTolerance: 20,
			stack: !1,
			zIndex: !1,
			drag: null,
			start: null,
			stop: null
		},
		_create: function () {
			"original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this._addClass("ui-draggable"), this._setHandleClassName(), this._mouseInit()
		},
		_setOption: function (t, e) {
			this._super(t, e), "handle" === t && (this._removeHandleClassName(), this._setHandleClassName())
		},
		_destroy: function () {
			(this.helper || this.element).is(".ui-draggable-dragging") ? this.destroyOnClear = !0 : (this._removeHandleClassName(), this._mouseDestroy())
		},
		_mouseCapture: function (t) {
			var e = this.options;
			return !(this.helper || e.disabled || 0 < q(t.target).closest(".ui-resizable-handle").length || (this.handle = this._getHandle(t), !this.handle || (this._blurActiveElement(t), this._blockFrames(!0 === e.iframeFix ? "iframe" : e.iframeFix), 0)))
		},
		_blockFrames: function (t) {
			this.iframeBlocks = this.document.find(t).map(function () {
				var t = q(this);
				return q("<div>").css("position", "absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]
			})
		},
		_unblockFrames: function () {
			this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
		},
		_blurActiveElement: function (t) {
			var e = q.ui.safeActiveElement(this.document[0]);
			q(t.target).closest(e).length || q.ui.safeBlur(e)
		},
		_mouseStart: function (t) {
			var e = this.options;
			return this.helper = this._createHelper(t), this._addClass(this.helper, "ui-draggable-dragging"), this._cacheHelperProportions(), q.ui.ddmanager && (q.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = 0 < this.helper.parents().filter(function () {
				return "fixed" === q(this).css("position")
			}).length, this.positionAbs = this.element.offset(), this._refreshOffsets(t), this.originalPosition = this.position = this._generatePosition(t, !1), this.originalPageX = t.pageX, this.originalPageY = t.pageY, e.cursorAt && this._adjustOffsetFromHelper(e.cursorAt), this._setContainment(), !1 === this._trigger("start", t) ? (this._clear(), !1) : (this._cacheHelperProportions(), q.ui.ddmanager && !e.dropBehaviour && q.ui.ddmanager.prepareOffsets(this, t), this._mouseDrag(t, !0), q.ui.ddmanager && q.ui.ddmanager.dragStart(this, t), !0)
		},
		_refreshOffsets: function (t) {
			this.offset = {
				top: this.positionAbs.top - this.margins.top,
				left: this.positionAbs.left - this.margins.left,
				scroll: !1,
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset()
			}, this.offset.click = {
				left: t.pageX - this.offset.left,
				top: t.pageY - this.offset.top
			}
		},
		_mouseDrag: function (t, e) {
			if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(t, !0), this.positionAbs = this._convertPositionTo("absolute"), !e) {
				if (e = this._uiHash(), !1 === this._trigger("drag", t, e)) return this._mouseUp(new q.Event("mouseup", t)), !1;
				this.position = e.position
			}
			return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", q.ui.ddmanager && q.ui.ddmanager.drag(this, t), !1
		},
		_mouseStop: function (t) {
			var e = this,
				i = !1;
			return q.ui.ddmanager && !this.options.dropBehaviour && (i = q.ui.ddmanager.drop(this, t)), this.dropped && (i = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !i || "valid" === this.options.revert && i || !0 === this.options.revert || "function" == typeof this.options.revert && this.options.revert.call(this.element, i) ? q(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
				!1 !== e._trigger("stop", t) && e._clear()
			}) : !1 !== this._trigger("stop", t) && this._clear(), !1
		},
		_mouseUp: function (t) {
			return this._unblockFrames(), q.ui.ddmanager && q.ui.ddmanager.dragStop(this, t), this.handleElement.is(t.target) && this.element.trigger("focus"), q.ui.mouse.prototype._mouseUp.call(this, t)
		},
		cancel: function () {
			return this.helper.is(".ui-draggable-dragging") ? this._mouseUp(new q.Event("mouseup", {
				target: this.element[0]
			})) : this._clear(), this
		},
		_getHandle: function (t) {
			return !this.options.handle || !!q(t.target).closest(this.element.find(this.options.handle)).length
		},
		_setHandleClassName: function () {
			this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this._addClass(this.handleElement, "ui-draggable-handle")
		},
		_removeHandleClassName: function () {
			this._removeClass(this.handleElement, "ui-draggable-handle")
		},
		_createHelper: function (t) {
			var e = this.options,
				i = "function" == typeof e.helper,
				t = i ? q(e.helper.apply(this.element[0], [t])) : "clone" === e.helper ? this.element.clone().removeAttr("id") : this.element;
			return t.parents("body").length || t.appendTo("parent" === e.appendTo ? this.element[0].parentNode : e.appendTo), i && t[0] === this.element[0] && this._setPositionRelative(), t[0] === this.element[0] || /(fixed|absolute)/.test(t.css("position")) || t.css("position", "absolute"), t
		},
		_setPositionRelative: function () {
			/^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative")
		},
		_adjustOffsetFromHelper: function (t) {
			"string" == typeof t && (t = t.split(" ")), "left" in (t = Array.isArray(t) ? {
				left: +t[0],
				top: +t[1] || 0
			} : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
		},
		_isRootNode: function (t) {
			return /(html|body)/i.test(t.tagName) || t === this.document[0]
		},
		_getParentOffset: function () {
			var t = this.offsetParent.offset(),
				e = this.document[0];
			return "absolute" === this.cssPosition && this.scrollParent[0] !== e && q.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), {
				top: (t = this._isRootNode(this.offsetParent[0]) ? {
					top: 0,
					left: 0
				} : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
				left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
			}
		},
		_getRelativeOffset: function () {
			if ("relative" !== this.cssPosition) return {
				top: 0,
				left: 0
			};
			var t = this.element.position(),
				e = this._isRootNode(this.scrollParent[0]);
			return {
				top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + (e ? 0 : this.scrollParent.scrollTop()),
				left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + (e ? 0 : this.scrollParent.scrollLeft())
			}
		},
		_cacheMargins: function () {
			this.margins = {
				left: parseInt(this.element.css("marginLeft"), 10) || 0,
				top: parseInt(this.element.css("marginTop"), 10) || 0,
				right: parseInt(this.element.css("marginRight"), 10) || 0,
				bottom: parseInt(this.element.css("marginBottom"), 10) || 0
			}
		},
		_cacheHelperProportions: function () {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			}
		},
		_setContainment: function () {
			var t, e, i, n = this.options,
				s = this.document[0];
			this.relativeContainer = null, n.containment ? "window" !== n.containment ? "document" !== n.containment ? n.containment.constructor !== Array ? ("parent" === n.containment && (n.containment = this.helper[0].parentNode), (i = (e = q(n.containment))[0]) && (t = /(scroll|auto)/.test(e.css("overflow")), this.containment = [(parseInt(e.css("borderLeftWidth"), 10) || 0) + (parseInt(e.css("paddingLeft"), 10) || 0), (parseInt(e.css("borderTopWidth"), 10) || 0) + (parseInt(e.css("paddingTop"), 10) || 0), (t ? Math.max(i.scrollWidth, i.offsetWidth) : i.offsetWidth) - (parseInt(e.css("borderRightWidth"), 10) || 0) - (parseInt(e.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (t ? Math.max(i.scrollHeight, i.offsetHeight) : i.offsetHeight) - (parseInt(e.css("borderBottomWidth"), 10) || 0) - (parseInt(e.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = e)) : this.containment = n.containment : this.containment = [0, 0, q(s).width() - this.helperProportions.width - this.margins.left, (q(s).height() || s.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : this.containment = [q(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, q(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, q(window).scrollLeft() + q(window).width() - this.helperProportions.width - this.margins.left, q(window).scrollTop() + (q(window).height() || s.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : this.containment = null
		},
		_convertPositionTo: function (t, e) {
			e = e || this.position;
			var i = "absolute" === t ? 1 : -1,
				t = this._isRootNode(this.scrollParent[0]);
			return {
				top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.offset.scroll.top : t ? 0 : this.offset.scroll.top) * i,
				left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : t ? 0 : this.offset.scroll.left) * i
			}
		},
		_generatePosition: function (t, e) {
			var i, n = this.options,
				s = this._isRootNode(this.scrollParent[0]),
				o = t.pageX,
				r = t.pageY;
			return s && this.offset.scroll || (this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			}), e && (this.containment && (i = this.relativeContainer ? (i = this.relativeContainer.offset(), [this.containment[0] + i.left, this.containment[1] + i.top, this.containment[2] + i.left, this.containment[3] + i.top]) : this.containment, t.pageX - this.offset.click.left < i[0] && (o = i[0] + this.offset.click.left), t.pageY - this.offset.click.top < i[1] && (r = i[1] + this.offset.click.top), t.pageX - this.offset.click.left > i[2] && (o = i[2] + this.offset.click.left), t.pageY - this.offset.click.top > i[3] && (r = i[3] + this.offset.click.top)), n.grid && (t = n.grid[1] ? this.originalPageY + Math.round((r - this.originalPageY) / n.grid[1]) * n.grid[1] : this.originalPageY, r = !i || t - this.offset.click.top >= i[1] || t - this.offset.click.top > i[3] ? t : t - this.offset.click.top >= i[1] ? t - n.grid[1] : t + n.grid[1], t = n.grid[0] ? this.originalPageX + Math.round((o - this.originalPageX) / n.grid[0]) * n.grid[0] : this.originalPageX, o = !i || t - this.offset.click.left >= i[0] || t - this.offset.click.left > i[2] ? t : t - this.offset.click.left >= i[0] ? t - n.grid[0] : t + n.grid[0]), "y" === n.axis && (o = this.originalPageX), "x" === n.axis && (r = this.originalPageY)), {
				top: r - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : s ? 0 : this.offset.scroll.top),
				left: o - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : s ? 0 : this.offset.scroll.left)
			}
		},
		_clear: function () {
			this._removeClass(this.helper, "ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy()
		},
		_trigger: function (t, e, i) {
			return i = i || this._uiHash(), q.ui.plugin.call(this, t, [e, i, this], !0), /^(drag|start|stop)/.test(t) && (this.positionAbs = this._convertPositionTo("absolute"), i.offset = this.positionAbs), q.Widget.prototype._trigger.call(this, t, e, i)
		},
		plugins: {},
		_uiHash: function () {
			return {
				helper: this.helper,
				position: this.position,
				originalPosition: this.originalPosition,
				offset: this.positionAbs
			}
		}
	}), q.ui.plugin.add("draggable", "connectToSortable", {
		start: function (e, t, i) {
			var n = q.extend({}, t, {
				item: i.element
			});
			i.sortables = [], q(i.options.connectToSortable).each(function () {
				var t = q(this).sortable("instance");
				t && !t.options.disabled && (i.sortables.push(t), t.refreshPositions(), t._trigger("activate", e, n))
			})
		},
		stop: function (e, t, i) {
			var n = q.extend({}, t, {
				item: i.element
			});
			i.cancelHelperRemoval = !1, q.each(i.sortables, function () {
				var t = this;
				t.isOver ? (t.isOver = 0, i.cancelHelperRemoval = !0, t.cancelHelperRemoval = !1, t._storedCSS = {
					position: t.placeholder.css("position"),
					top: t.placeholder.css("top"),
					left: t.placeholder.css("left")
				}, t._mouseStop(e), t.options.helper = t.options._helper) : (t.cancelHelperRemoval = !0, t._trigger("deactivate", e, n))
			})
		},
		drag: function (i, n, s) {
			q.each(s.sortables, function () {
				var t = !1,
					e = this;
				e.positionAbs = s.positionAbs, e.helperProportions = s.helperProportions, e.offset.click = s.offset.click, e._intersectsWith(e.containerCache) && (t = !0, q.each(s.sortables, function () {
					return this.positionAbs = s.positionAbs, this.helperProportions = s.helperProportions, this.offset.click = s.offset.click, t = (this === e || !this._intersectsWith(this.containerCache) || !q.contains(e.element[0], this.element[0])) && t
				})), t ? (e.isOver || (e.isOver = 1, s._parent = n.helper.parent(), e.currentItem = n.helper.appendTo(e.element).data("ui-sortable-item", !0), e.options._helper = e.options.helper, e.options.helper = function () {
					return n.helper[0]
				}, i.target = e.currentItem[0], e._mouseCapture(i, !0), e._mouseStart(i, !0, !0), e.offset.click.top = s.offset.click.top, e.offset.click.left = s.offset.click.left, e.offset.parent.left -= s.offset.parent.left - e.offset.parent.left, e.offset.parent.top -= s.offset.parent.top - e.offset.parent.top, s._trigger("toSortable", i), s.dropped = e.element, q.each(s.sortables, function () {
					this.refreshPositions()
				}), s.currentItem = s.element, e.fromOutside = s), e.currentItem && (e._mouseDrag(i), n.position = e.position)) : e.isOver && (e.isOver = 0, e.cancelHelperRemoval = !0, e.options._revert = e.options.revert, e.options.revert = !1, e._trigger("out", i, e._uiHash(e)), e._mouseStop(i, !0), e.options.revert = e.options._revert, e.options.helper = e.options._helper, e.placeholder && e.placeholder.remove(), n.helper.appendTo(s._parent), s._refreshOffsets(i), n.position = s._generatePosition(i, !0), s._trigger("fromSortable", i), s.dropped = !1, q.each(s.sortables, function () {
					this.refreshPositions()
				}))
			})
		}
	}), q.ui.plugin.add("draggable", "cursor", {
		start: function (t, e, i) {
			var n = q("body"),
				i = i.options;
			n.css("cursor") && (i._cursor = n.css("cursor")), n.css("cursor", i.cursor)
		},
		stop: function (t, e, i) {
			i = i.options, i._cursor && q("body").css("cursor", i._cursor)
		}
	}), q.ui.plugin.add("draggable", "opacity", {
		start: function (t, e, i) {
			e = q(e.helper), i = i.options, e.css("opacity") && (i._opacity = e.css("opacity")), e.css("opacity", i.opacity)
		},
		stop: function (t, e, i) {
			i = i.options, i._opacity && q(e.helper).css("opacity", i._opacity)
		}
	}), q.ui.plugin.add("draggable", "scroll", {
		start: function (t, e, i) {
			i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset())
		},
		drag: function (t, e, i) {
			var n = i.options,
				s = !1,
				o = i.scrollParentNotHidden[0],
				r = i.document[0];
			o !== r && "HTML" !== o.tagName ? (n.axis && "x" === n.axis || (i.overflowOffset.top + o.offsetHeight - t.pageY < n.scrollSensitivity ? o.scrollTop = s = o.scrollTop + n.scrollSpeed : t.pageY - i.overflowOffset.top < n.scrollSensitivity && (o.scrollTop = s = o.scrollTop - n.scrollSpeed)), n.axis && "y" === n.axis || (i.overflowOffset.left + o.offsetWidth - t.pageX < n.scrollSensitivity ? o.scrollLeft = s = o.scrollLeft + n.scrollSpeed : t.pageX - i.overflowOffset.left < n.scrollSensitivity && (o.scrollLeft = s = o.scrollLeft - n.scrollSpeed))) : (n.axis && "x" === n.axis || (t.pageY - q(r).scrollTop() < n.scrollSensitivity ? s = q(r).scrollTop(q(r).scrollTop() - n.scrollSpeed) : q(window).height() - (t.pageY - q(r).scrollTop()) < n.scrollSensitivity && (s = q(r).scrollTop(q(r).scrollTop() + n.scrollSpeed))), n.axis && "y" === n.axis || (t.pageX - q(r).scrollLeft() < n.scrollSensitivity ? s = q(r).scrollLeft(q(r).scrollLeft() - n.scrollSpeed) : q(window).width() - (t.pageX - q(r).scrollLeft()) < n.scrollSensitivity && (s = q(r).scrollLeft(q(r).scrollLeft() + n.scrollSpeed)))), !1 !== s && q.ui.ddmanager && !n.dropBehaviour && q.ui.ddmanager.prepareOffsets(i, t)
		}
	}), q.ui.plugin.add("draggable", "snap", {
		start: function (t, e, i) {
			var n = i.options;
			i.snapElements = [], q(n.snap.constructor !== String ? n.snap.items || ":data(ui-draggable)" : n.snap).each(function () {
				var t = q(this),
					e = t.offset();
				this !== i.element[0] && i.snapElements.push({
					item: this,
					width: t.outerWidth(),
					height: t.outerHeight(),
					top: e.top,
					left: e.left
				})
			})
		},
		drag: function (t, e, i) {
			for (var n, s, o, r, a, l, h, c, u, d = i.options, f = d.snapTolerance, p = e.offset.left, g = p + i.helperProportions.width, m = e.offset.top, v = m + i.helperProportions.height, b = i.snapElements.length - 1; 0 <= b; b--) l = (a = i.snapElements[b].left - i.margins.left) + i.snapElements[b].width, c = (h = i.snapElements[b].top - i.margins.top) + i.snapElements[b].height, g < a - f || l + f < p || v < h - f || c + f < m || !q.contains(i.snapElements[b].item.ownerDocument, i.snapElements[b].item) ? (i.snapElements[b].snapping && i.options.snap.release && i.options.snap.release.call(i.element, t, q.extend(i._uiHash(), {
				snapItem: i.snapElements[b].item
			})), i.snapElements[b].snapping = !1) : ("inner" !== d.snapMode && (n = Math.abs(h - v) <= f, s = Math.abs(c - m) <= f, o = Math.abs(a - g) <= f, r = Math.abs(l - p) <= f, n && (e.position.top = i._convertPositionTo("relative", {
				top: h - i.helperProportions.height,
				left: 0
			}).top), s && (e.position.top = i._convertPositionTo("relative", {
				top: c,
				left: 0
			}).top), o && (e.position.left = i._convertPositionTo("relative", {
				top: 0,
				left: a - i.helperProportions.width
			}).left), r && (e.position.left = i._convertPositionTo("relative", {
				top: 0,
				left: l
			}).left)), u = n || s || o || r, "outer" !== d.snapMode && (n = Math.abs(h - m) <= f, s = Math.abs(c - v) <= f, o = Math.abs(a - p) <= f, r = Math.abs(l - g) <= f, n && (e.position.top = i._convertPositionTo("relative", {
				top: h,
				left: 0
			}).top), s && (e.position.top = i._convertPositionTo("relative", {
				top: c - i.helperProportions.height,
				left: 0
			}).top), o && (e.position.left = i._convertPositionTo("relative", {
				top: 0,
				left: a
			}).left), r && (e.position.left = i._convertPositionTo("relative", {
				top: 0,
				left: l - i.helperProportions.width
			}).left)), !i.snapElements[b].snapping && (n || s || o || r || u) && i.options.snap.snap && i.options.snap.snap.call(i.element, t, q.extend(i._uiHash(), {
				snapItem: i.snapElements[b].item
			})), i.snapElements[b].snapping = n || s || o || r || u)
		}
	}), q.ui.plugin.add("draggable", "stack", {
		start: function (t, e, i) {
			var n, i = i.options,
				i = q.makeArray(q(i.stack)).sort(function (t, e) {
					return (parseInt(q(t).css("zIndex"), 10) || 0) - (parseInt(q(e).css("zIndex"), 10) || 0)
				});
			i.length && (n = parseInt(q(i[0]).css("zIndex"), 10) || 0, q(i).each(function (t) {
				q(this).css("zIndex", n + t)
			}), this.css("zIndex", n + i.length))
		}
	}), q.ui.plugin.add("draggable", "zIndex", {
		start: function (t, e, i) {
			e = q(e.helper), i = i.options, e.css("zIndex") && (i._zIndex = e.css("zIndex")), e.css("zIndex", i.zIndex)
		},
		stop: function (t, e, i) {
			i = i.options, i._zIndex && q(e.helper).css("zIndex", i._zIndex)
		}
	}), q.ui.draggable, q.widget("ui.resizable", q.ui.mouse, {
		version: "1.13.2",
		widgetEventPrefix: "resize",
		options: {
			alsoResize: !1,
			animate: !1,
			animateDuration: "slow",
			animateEasing: "swing",
			aspectRatio: !1,
			autoHide: !1,
			classes: {
				"ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
			},
			containment: !1,
			ghost: !1,
			grid: !1,
			handles: "e,s,se",
			helper: !1,
			maxHeight: null,
			maxWidth: null,
			minHeight: 10,
			minWidth: 10,
			zIndex: 90,
			resize: null,
			start: null,
			stop: null
		},
		_num: function (t) {
			return parseFloat(t) || 0
		},
		_isNumber: function (t) {
			return !isNaN(parseFloat(t))
		},
		_hasScroll: function (t, e) {
			if ("hidden" === q(t).css("overflow")) return !1;
			var i = e && "left" === e ? "scrollLeft" : "scrollTop",
				e = !1;
			if (0 < t[i]) return !0;
			try {
				t[i] = 1, e = 0 < t[i], t[i] = 0
			} catch (t) { }
			return e
		},
		_create: function () {
			var t, e = this.options,
				i = this;
			this._addClass("ui-resizable"), q.extend(this, {
				_aspectRatio: !!e.aspectRatio,
				aspectRatio: e.aspectRatio,
				originalElement: this.element,
				_proportionallyResizeElements: [],
				_helper: e.helper || e.ghost || e.animate ? e.helper || "ui-resizable-helper" : null
			}), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(q("<div class='ui-wrapper'></div>").css({
				overflow: "hidden",
				position: this.element.css("position"),
				width: this.element.outerWidth(),
				height: this.element.outerHeight(),
				top: this.element.css("top"),
				left: this.element.css("left")
			})), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), this.elementIsWrapper = !0, t = {
				marginTop: this.originalElement.css("marginTop"),
				marginRight: this.originalElement.css("marginRight"),
				marginBottom: this.originalElement.css("marginBottom"),
				marginLeft: this.originalElement.css("marginLeft")
			}, this.element.css(t), this.originalElement.css("margin", 0), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
				position: "static",
				zoom: 1,
				display: "block"
			})), this.originalElement.css(t), this._proportionallyResize()), this._setupHandles(), e.autoHide && q(this.element).on("mouseenter", function () {
				e.disabled || (i._removeClass("ui-resizable-autohide"), i._handles.show())
			}).on("mouseleave", function () {
				e.disabled || i.resizing || (i._addClass("ui-resizable-autohide"), i._handles.hide())
			}), this._mouseInit()
		},
		_destroy: function () {
			function t(t) {
				q(t).removeData("resizable").removeData("ui-resizable").off(".resizable")
			}
			this._mouseDestroy(), this._addedHandles.remove();
			var e;
			return this.elementIsWrapper && (t(this.element), e = this.element, this.originalElement.css({
				position: e.css("position"),
				width: e.outerWidth(),
				height: e.outerHeight(),
				top: e.css("top"),
				left: e.css("left")
			}).insertAfter(e), e.remove()), this.originalElement.css("resize", this.originalResizeStyle), t(this.originalElement), this
		},
		_setOption: function (t, e) {
			switch (this._super(t, e), t) {
				case "handles":
					this._removeHandles(), this._setupHandles();
					break;
				case "aspectRatio":
					this._aspectRatio = !!e
			}
		},
		_setupHandles: function () {
			var t, e, i, n, s, o = this.options,
				r = this;
			if (this.handles = o.handles || (q(".ui-resizable-handle", this.element).length ? {
				n: ".ui-resizable-n",
				e: ".ui-resizable-e",
				s: ".ui-resizable-s",
				w: ".ui-resizable-w",
				se: ".ui-resizable-se",
				sw: ".ui-resizable-sw",
				ne: ".ui-resizable-ne",
				nw: ".ui-resizable-nw"
			} : "e,s,se"), this._handles = q(), this._addedHandles = q(), this.handles.constructor === String)
				for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), i = this.handles.split(","), this.handles = {}, e = 0; e < i.length; e++) n = "ui-resizable-" + (t = String.prototype.trim.call(i[e])), s = q("<div>"), this._addClass(s, "ui-resizable-handle " + n), s.css({
					zIndex: o.zIndex
				}), this.handles[t] = ".ui-resizable-" + t, this.element.children(this.handles[t]).length || (this.element.append(s), this._addedHandles = this._addedHandles.add(s));
			this._renderAxis = function (t) {
				var e, i, n;
				for (e in t = t || this.element, this.handles) this.handles[e].constructor === String ? this.handles[e] = this.element.children(this.handles[e]).first().show() : (this.handles[e].jquery || this.handles[e].nodeType) && (this.handles[e] = q(this.handles[e]), this._on(this.handles[e], {
					mousedown: r._mouseDown
				})), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (i = q(this.handles[e], this.element), n = /sw|ne|nw|se|n|s/.test(e) ? i.outerHeight() : i.outerWidth(), i = ["padding", /ne|nw|n/.test(e) ? "Top" : /se|sw|s/.test(e) ? "Bottom" : /^e$/.test(e) ? "Right" : "Left"].join(""), t.css(i, n), this._proportionallyResize()), this._handles = this._handles.add(this.handles[e])
			}, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), this._handles.disableSelection(), this._handles.on("mouseover", function () {
				r.resizing || (this.className && (s = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), r.axis = s && s[1] ? s[1] : "se")
			}), o.autoHide && (this._handles.hide(), this._addClass("ui-resizable-autohide"))
		},
		_removeHandles: function () {
			this._addedHandles.remove()
		},
		_mouseCapture: function (t) {
			var e, i, n = !1;
			for (e in this.handles) (i = q(this.handles[e])[0]) !== t.target && !q.contains(i, t.target) || (n = !0);
			return !this.options.disabled && n
		},
		_mouseStart: function (t) {
			var e, i, n = this.options,
				s = this.element;
			return this.resizing = !0, this._renderProxy(), e = this._num(this.helper.css("left")), i = this._num(this.helper.css("top")), n.containment && (e += q(n.containment).scrollLeft() || 0, i += q(n.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
				left: e,
				top: i
			}, this.size = this._helper ? {
				width: this.helper.width(),
				height: this.helper.height()
			} : {
				width: s.width(),
				height: s.height()
			}, this.originalSize = this._helper ? {
				width: s.outerWidth(),
				height: s.outerHeight()
			} : {
				width: s.width(),
				height: s.height()
			}, this.sizeDiff = {
				width: s.outerWidth() - s.width(),
				height: s.outerHeight() - s.height()
			}, this.originalPosition = {
				left: e,
				top: i
			}, this.originalMousePosition = {
				left: t.pageX,
				top: t.pageY
			}, this.aspectRatio = "number" == typeof n.aspectRatio ? n.aspectRatio : this.originalSize.width / this.originalSize.height || 1, n = q(".ui-resizable-" + this.axis).css("cursor"), q("body").css("cursor", "auto" === n ? this.axis + "-resize" : n), this._addClass("ui-resizable-resizing"), this._propagate("start", t), !0
		},
		_mouseDrag: function (t) {
			var e = this.originalMousePosition,
				i = this.axis,
				n = t.pageX - e.left || 0,
				e = t.pageY - e.top || 0,
				i = this._change[i];
			return this._updatePrevProperties(), i && (e = i.apply(this, [t, n, e]), this._updateVirtualBoundaries(t.shiftKey), (this._aspectRatio || t.shiftKey) && (e = this._updateRatio(e, t)), e = this._respectSize(e, t), this._updateCache(e), this._propagate("resize", t), e = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), q.isEmptyObject(e) || (this._updatePrevProperties(), this._trigger("resize", t, this.ui()), this._applyChanges())), !1
		},
		_mouseStop: function (t) {
			this.resizing = !1;
			var e, i, n, s = this.options,
				o = this;
			return this._helper && (n = (e = (i = this._proportionallyResizeElements).length && /textarea/i.test(i[0].nodeName)) && this._hasScroll(i[0], "left") ? 0 : o.sizeDiff.height, i = e ? 0 : o.sizeDiff.width, e = {
				width: o.helper.width() - i,
				height: o.helper.height() - n
			}, i = parseFloat(o.element.css("left")) + (o.position.left - o.originalPosition.left) || null, n = parseFloat(o.element.css("top")) + (o.position.top - o.originalPosition.top) || null, s.animate || this.element.css(q.extend(e, {
				top: n,
				left: i
			})), o.helper.height(o.size.height), o.helper.width(o.size.width), this._helper && !s.animate && this._proportionallyResize()), q("body").css("cursor", "auto"), this._removeClass("ui-resizable-resizing"), this._propagate("stop", t), this._helper && this.helper.remove(), !1
		},
		_updatePrevProperties: function () {
			this.prevPosition = {
				top: this.position.top,
				left: this.position.left
			}, this.prevSize = {
				width: this.size.width,
				height: this.size.height
			}
		},
		_applyChanges: function () {
			var t = {};
			return this.position.top !== this.prevPosition.top && (t.top = this.position.top + "px"), this.position.left !== this.prevPosition.left && (t.left = this.position.left + "px"), this.size.width !== this.prevSize.width && (t.width = this.size.width + "px"), this.size.height !== this.prevSize.height && (t.height = this.size.height + "px"), this.helper.css(t), t
		},
		_updateVirtualBoundaries: function (t) {
			var e, i, n = this.options,
				s = {
					minWidth: this._isNumber(n.minWidth) ? n.minWidth : 0,
					maxWidth: this._isNumber(n.maxWidth) ? n.maxWidth : 1 / 0,
					minHeight: this._isNumber(n.minHeight) ? n.minHeight : 0,
					maxHeight: this._isNumber(n.maxHeight) ? n.maxHeight : 1 / 0
				};
			(this._aspectRatio || t) && (e = s.minHeight * this.aspectRatio, i = s.minWidth / this.aspectRatio, n = s.maxHeight * this.aspectRatio, t = s.maxWidth / this.aspectRatio, e > s.minWidth && (s.minWidth = e), i > s.minHeight && (s.minHeight = i), n < s.maxWidth && (s.maxWidth = n), t < s.maxHeight && (s.maxHeight = t)), this._vBoundaries = s
		},
		_updateCache: function (t) {
			this.offset = this.helper.offset(), this._isNumber(t.left) && (this.position.left = t.left), this._isNumber(t.top) && (this.position.top = t.top), this._isNumber(t.height) && (this.size.height = t.height), this._isNumber(t.width) && (this.size.width = t.width)
		},
		_updateRatio: function (t) {
			var e = this.position,
				i = this.size,
				n = this.axis;
			return this._isNumber(t.height) ? t.width = t.height * this.aspectRatio : this._isNumber(t.width) && (t.height = t.width / this.aspectRatio), "sw" === n && (t.left = e.left + (i.width - t.width), t.top = null), "nw" === n && (t.top = e.top + (i.height - t.height), t.left = e.left + (i.width - t.width)), t
		},
		_respectSize: function (t) {
			var e = this._vBoundaries,
				i = this.axis,
				n = this._isNumber(t.width) && e.maxWidth && e.maxWidth < t.width,
				s = this._isNumber(t.height) && e.maxHeight && e.maxHeight < t.height,
				o = this._isNumber(t.width) && e.minWidth && e.minWidth > t.width,
				r = this._isNumber(t.height) && e.minHeight && e.minHeight > t.height,
				a = this.originalPosition.left + this.originalSize.width,
				l = this.originalPosition.top + this.originalSize.height,
				h = /sw|nw|w/.test(i),
				i = /nw|ne|n/.test(i);
			return o && (t.width = e.minWidth), r && (t.height = e.minHeight), n && (t.width = e.maxWidth), s && (t.height = e.maxHeight), o && h && (t.left = a - e.minWidth), n && h && (t.left = a - e.maxWidth), r && i && (t.top = l - e.minHeight), s && i && (t.top = l - e.maxHeight), t.width || t.height || t.left || !t.top ? t.width || t.height || t.top || !t.left || (t.left = null) : t.top = null, t
		},
		_getPaddingPlusBorderDimensions: function (t) {
			for (var e = 0, i = [], n = [t.css("borderTopWidth"), t.css("borderRightWidth"), t.css("borderBottomWidth"), t.css("borderLeftWidth")], s = [t.css("paddingTop"), t.css("paddingRight"), t.css("paddingBottom"), t.css("paddingLeft")]; e < 4; e++) i[e] = parseFloat(n[e]) || 0, i[e] += parseFloat(s[e]) || 0;
			return {
				height: i[0] + i[2],
				width: i[1] + i[3]
			}
		},
		_proportionallyResize: function () {
			if (this._proportionallyResizeElements.length)
				for (var t, e = 0, i = this.helper || this.element; e < this._proportionallyResizeElements.length; e++) t = this._proportionallyResizeElements[e], this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(t)), t.css({
					height: i.height() - this.outerDimensions.height || 0,
					width: i.width() - this.outerDimensions.width || 0
				})
		},
		_renderProxy: function () {
			var t = this.element,
				e = this.options;
			this.elementOffset = t.offset(), this._helper ? (this.helper = this.helper || q("<div></div>").css({
				overflow: "hidden"
			}), this._addClass(this.helper, this._helper), this.helper.css({
				width: this.element.outerWidth(),
				height: this.element.outerHeight(),
				position: "absolute",
				left: this.elementOffset.left + "px",
				top: this.elementOffset.top + "px",
				zIndex: ++e.zIndex
			}), this.helper.appendTo("body").disableSelection()) : this.helper = this.element
		},
		_change: {
			e: function (t, e) {
				return {
					width: this.originalSize.width + e
				}
			},
			w: function (t, e) {
				var i = this.originalSize;
				return {
					left: this.originalPosition.left + e,
					width: i.width - e
				}
			},
			n: function (t, e, i) {
				var n = this.originalSize;
				return {
					top: this.originalPosition.top + i,
					height: n.height - i
				}
			},
			s: function (t, e, i) {
				return {
					height: this.originalSize.height + i
				}
			},
			se: function (t, e, i) {
				return q.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [t, e, i]))
			},
			sw: function (t, e, i) {
				return q.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [t, e, i]))
			},
			ne: function (t, e, i) {
				return q.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [t, e, i]))
			},
			nw: function (t, e, i) {
				return q.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [t, e, i]))
			}
		},
		_propagate: function (t, e) {
			q.ui.plugin.call(this, t, [e, this.ui()]), "resize" !== t && this._trigger(t, e, this.ui())
		},
		plugins: {},
		ui: function () {
			return {
				originalElement: this.originalElement,
				element: this.element,
				helper: this.helper,
				position: this.position,
				size: this.size,
				originalSize: this.originalSize,
				originalPosition: this.originalPosition
			}
		}
	}), q.ui.plugin.add("resizable", "animate", {
		stop: function (e) {
			var i = q(this).resizable("instance"),
				t = i.options,
				n = i._proportionallyResizeElements,
				s = n.length && /textarea/i.test(n[0].nodeName),
				o = s && i._hasScroll(n[0], "left") ? 0 : i.sizeDiff.height,
				r = s ? 0 : i.sizeDiff.width,
				s = {
					width: i.size.width - r,
					height: i.size.height - o
				},
				r = parseFloat(i.element.css("left")) + (i.position.left - i.originalPosition.left) || null,
				o = parseFloat(i.element.css("top")) + (i.position.top - i.originalPosition.top) || null;
			i.element.animate(q.extend(s, o && r ? {
				top: o,
				left: r
			} : {}), {
				duration: t.animateDuration,
				easing: t.animateEasing,
				step: function () {
					var t = {
						width: parseFloat(i.element.css("width")),
						height: parseFloat(i.element.css("height")),
						top: parseFloat(i.element.css("top")),
						left: parseFloat(i.element.css("left"))
					};
					n && n.length && q(n[0]).css({
						width: t.width,
						height: t.height
					}), i._updateCache(t), i._propagate("resize", e)
				}
			})
		}
	}), q.ui.plugin.add("resizable", "containment", {
		start: function () {
			var i, n, s = q(this).resizable("instance"),
				t = s.options,
				e = s.element,
				o = t.containment,
				r = o instanceof q ? o.get(0) : /parent/.test(o) ? e.parent().get(0) : o;
			r && (s.containerElement = q(r), /document/.test(o) || o === document ? (s.containerOffset = {
				left: 0,
				top: 0
			}, s.containerPosition = {
				left: 0,
				top: 0
			}, s.parentData = {
				element: q(document),
				left: 0,
				top: 0,
				width: q(document).width(),
				height: q(document).height() || document.body.parentNode.scrollHeight
			}) : (i = q(r), n = [], q(["Top", "Right", "Left", "Bottom"]).each(function (t, e) {
				n[t] = s._num(i.css("padding" + e))
			}), s.containerOffset = i.offset(), s.containerPosition = i.position(), s.containerSize = {
				height: i.innerHeight() - n[3],
				width: i.innerWidth() - n[1]
			}, t = s.containerOffset, e = s.containerSize.height, o = s.containerSize.width, o = s._hasScroll(r, "left") ? r.scrollWidth : o, e = s._hasScroll(r) ? r.scrollHeight : e, s.parentData = {
				element: r,
				left: t.left,
				top: t.top,
				width: o,
				height: e
			}))
		},
		resize: function (t) {
			var e = q(this).resizable("instance"),
				i = e.options,
				n = e.containerOffset,
				s = e.position,
				o = e._aspectRatio || t.shiftKey,
				r = {
					top: 0,
					left: 0
				},
				a = e.containerElement,
				t = !0;
			a[0] !== document && /static/.test(a.css("position")) && (r = n), s.left < (e._helper ? n.left : 0) && (e.size.width = e.size.width + (e._helper ? e.position.left - n.left : e.position.left - r.left), o && (e.size.height = e.size.width / e.aspectRatio, t = !1), e.position.left = i.helper ? n.left : 0), s.top < (e._helper ? n.top : 0) && (e.size.height = e.size.height + (e._helper ? e.position.top - n.top : e.position.top), o && (e.size.width = e.size.height * e.aspectRatio, t = !1), e.position.top = e._helper ? n.top : 0), i = e.containerElement.get(0) === e.element.parent().get(0), s = /relative|absolute/.test(e.containerElement.css("position")), i && s ? (e.offset.left = e.parentData.left + e.position.left, e.offset.top = e.parentData.top + e.position.top) : (e.offset.left = e.element.offset().left, e.offset.top = e.element.offset().top), s = Math.abs(e.sizeDiff.width + (e._helper ? e.offset.left - r.left : e.offset.left - n.left)), n = Math.abs(e.sizeDiff.height + (e._helper ? e.offset.top - r.top : e.offset.top - n.top)), s + e.size.width >= e.parentData.width && (e.size.width = e.parentData.width - s, o && (e.size.height = e.size.width / e.aspectRatio, t = !1)), n + e.size.height >= e.parentData.height && (e.size.height = e.parentData.height - n, o && (e.size.width = e.size.height * e.aspectRatio, t = !1)), t || (e.position.left = e.prevPosition.left, e.position.top = e.prevPosition.top, e.size.width = e.prevSize.width, e.size.height = e.prevSize.height)
		},
		stop: function () {
			var t = q(this).resizable("instance"),
				e = t.options,
				i = t.containerOffset,
				n = t.containerPosition,
				s = t.containerElement,
				o = q(t.helper),
				r = o.offset(),
				a = o.outerWidth() - t.sizeDiff.width,
				o = o.outerHeight() - t.sizeDiff.height;
			t._helper && !e.animate && /relative/.test(s.css("position")) && q(this).css({
				left: r.left - n.left - i.left,
				width: a,
				height: o
			}), t._helper && !e.animate && /static/.test(s.css("position")) && q(this).css({
				left: r.left - n.left - i.left,
				width: a,
				height: o
			})
		}
	}), q.ui.plugin.add("resizable", "alsoResize", {
		start: function () {
			var t = q(this).resizable("instance").options;
			q(t.alsoResize).each(function () {
				var t = q(this);
				t.data("ui-resizable-alsoresize", {
					width: parseFloat(t.width()),
					height: parseFloat(t.height()),
					left: parseFloat(t.css("left")),
					top: parseFloat(t.css("top"))
				})
			})
		},
		resize: function (t, i) {
			var e = q(this).resizable("instance"),
				n = e.options,
				s = e.originalSize,
				o = e.originalPosition,
				r = {
					height: e.size.height - s.height || 0,
					width: e.size.width - s.width || 0,
					top: e.position.top - o.top || 0,
					left: e.position.left - o.left || 0
				};
			q(n.alsoResize).each(function () {
				var t = q(this),
					n = q(this).data("ui-resizable-alsoresize"),
					s = {},
					e = t.parents(i.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
				q.each(e, function (t, e) {
					var i = (n[e] || 0) + (r[e] || 0);
					i && 0 <= i && (s[e] = i || null)
				}), t.css(s)
			})
		},
		stop: function () {
			q(this).removeData("ui-resizable-alsoresize")
		}
	}), q.ui.plugin.add("resizable", "ghost", {
		start: function () {
			var t = q(this).resizable("instance"),
				e = t.size;
			t.ghost = t.originalElement.clone(), t.ghost.css({
				opacity: .25,
				display: "block",
				position: "relative",
				height: e.height,
				width: e.width,
				margin: 0,
				left: 0,
				top: 0
			}), t._addClass(t.ghost, "ui-resizable-ghost"), !1 !== q.uiBackCompat && "string" == typeof t.options.ghost && t.ghost.addClass(this.options.ghost), t.ghost.appendTo(t.helper)
		},
		resize: function () {
			var t = q(this).resizable("instance");
			t.ghost && t.ghost.css({
				position: "relative",
				height: t.size.height,
				width: t.size.width
			})
		},
		stop: function () {
			var t = q(this).resizable("instance");
			t.ghost && t.helper && t.helper.get(0).removeChild(t.ghost.get(0))
		}
	}), q.ui.plugin.add("resizable", "grid", {
		resize: function () {
			var t, e = q(this).resizable("instance"),
				i = e.options,
				n = e.size,
				s = e.originalSize,
				o = e.originalPosition,
				r = e.axis,
				a = "number" == typeof i.grid ? [i.grid, i.grid] : i.grid,
				l = a[0] || 1,
				h = a[1] || 1,
				c = Math.round((n.width - s.width) / l) * l,
				u = Math.round((n.height - s.height) / h) * h,
				d = s.width + c,
				f = s.height + u,
				p = i.maxWidth && i.maxWidth < d,
				g = i.maxHeight && i.maxHeight < f,
				m = i.minWidth && i.minWidth > d,
				n = i.minHeight && i.minHeight > f;
			i.grid = a, m && (d += l), n && (f += h), p && (d -= l), g && (f -= h), /^(se|s|e)$/.test(r) ? (e.size.width = d, e.size.height = f) : /^(ne)$/.test(r) ? (e.size.width = d, e.size.height = f, e.position.top = o.top - u) : /^(sw)$/.test(r) ? (e.size.width = d, e.size.height = f, e.position.left = o.left - c) : ((f - h <= 0 || d - l <= 0) && (t = e._getPaddingPlusBorderDimensions(this)), 0 < f - h ? (e.size.height = f, e.position.top = o.top - u) : (f = h - t.height, e.size.height = f, e.position.top = o.top + s.height - f), 0 < d - l ? (e.size.width = d, e.position.left = o.left - c) : (d = l - t.width, e.size.width = d, e.position.left = o.left + s.width - d))
		}
	}), q.ui.resizable, q.widget("ui.dialog", {
		version: "1.13.2",
		options: {
			appendTo: "body",
			autoOpen: !0,
			buttons: [],
			classes: {
				"ui-dialog": "ui-corner-all",
				"ui-dialog-titlebar": "ui-corner-all"
			},
			closeOnEscape: !0,
			closeText: "Close",
			draggable: !0,
			hide: null,
			height: "auto",
			maxHeight: null,
			maxWidth: null,
			minHeight: 150,
			minWidth: 150,
			modal: !1,
			position: {
				my: "center",
				at: "center",
				of: window,
				collision: "fit",
				using: function (t) {
					var e = q(this).css(t).offset().top;
					e < 0 && q(this).css("top", t.top - e)
				}
			},
			resizable: !0,
			show: null,
			title: null,
			width: 300,
			beforeClose: null,
			close: null,
			drag: null,
			dragStart: null,
			dragStop: null,
			focus: null,
			open: null,
			resize: null,
			resizeStart: null,
			resizeStop: null
		},
		sizeRelatedOptions: {
			buttons: !0,
			height: !0,
			maxHeight: !0,
			maxWidth: !0,
			minHeight: !0,
			minWidth: !0,
			width: !0
		},
		resizableRelatedOptions: {
			maxHeight: !0,
			maxWidth: !0,
			minHeight: !0,
			minWidth: !0
		},
		_create: function () {
			this.originalCss = {
				display: this.element[0].style.display,
				width: this.element[0].style.width,
				minHeight: this.element[0].style.minHeight,
				maxHeight: this.element[0].style.maxHeight,
				height: this.element[0].style.height
			}, this.originalPosition = {
				parent: this.element.parent(),
				index: this.element.parent().children().index(this.element)
			}, this.originalTitle = this.element.attr("title"), null == this.options.title && null != this.originalTitle && (this.options.title = this.originalTitle), this.options.disabled && (this.options.disabled = !1), this._createWrapper(), this.element.show().removeAttr("title").appendTo(this.uiDialog), this._addClass("ui-dialog-content", "ui-widget-content"), this._createTitlebar(), this._createButtonPane(), this.options.draggable && q.fn.draggable && this._makeDraggable(), this.options.resizable && q.fn.resizable && this._makeResizable(), this._isOpen = !1, this._trackFocus()
		},
		_init: function () {
			this.options.autoOpen && this.open()
		},
		_appendTo: function () {
			var t = this.options.appendTo;
			return t && (t.jquery || t.nodeType) ? q(t) : this.document.find(t || "body").eq(0)
		},
		_destroy: function () {
			var t, e = this.originalPosition;
			this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId().css(this.originalCss).detach(), this.uiDialog.remove(), this.originalTitle && this.element.attr("title", this.originalTitle), (t = e.parent.children().eq(e.index)).length && t[0] !== this.element[0] ? t.before(this.element) : e.parent.append(this.element)
		},
		widget: function () {
			return this.uiDialog
		},
		disable: q.noop,
		enable: q.noop,
		close: function (t) {
			var e = this;
			this._isOpen && !1 !== this._trigger("beforeClose", t) && (this._isOpen = !1, this._focusedElement = null, this._destroyOverlay(), this._untrackInstance(), this.opener.filter(":focusable").trigger("focus").length || q.ui.safeBlur(q.ui.safeActiveElement(this.document[0])), this._hide(this.uiDialog, this.options.hide, function () {
				e._trigger("close", t)
			}))
		},
		isOpen: function () {
			return this._isOpen
		},
		moveToTop: function () {
			this._moveToTop()
		},
		_moveToTop: function (t, e) {
			var i = !1,
				n = this.uiDialog.siblings(".ui-front:visible").map(function () {
					return +q(this).css("z-index")
				}).get(),
				n = Math.max.apply(null, n);
			return n >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", n + 1), i = !0), i && !e && this._trigger("focus", t), i
		},
		open: function () {
			var t = this;
			this._isOpen ? this._moveToTop() && this._focusTabbable() : (this._isOpen = !0, this.opener = q(q.ui.safeActiveElement(this.document[0])), this._size(), this._position(), this._createOverlay(), this._moveToTop(null, !0), this.overlay && this.overlay.css("z-index", this.uiDialog.css("z-index") - 1), this._show(this.uiDialog, this.options.show, function () {
				t._focusTabbable(), t._trigger("focus")
			}), this._makeFocusTarget(), this._trigger("open"))
		},
		_focusTabbable: function () {
			var t = this._focusedElement;
			(t = (t = (t = (t = (t = t || this.element.find("[autofocus]")).length ? t : this.element.find(":tabbable")).length ? t : this.uiDialogButtonPane.find(":tabbable")).length ? t : this.uiDialogTitlebarClose.filter(":tabbable")).length ? t : this.uiDialog).eq(0).trigger("focus")
		},
		_restoreTabbableFocus: function () {
			var t = q.ui.safeActiveElement(this.document[0]);
			this.uiDialog[0] === t || q.contains(this.uiDialog[0], t) || this._focusTabbable()
		},
		_keepFocus: function (t) {
			t.preventDefault(), this._restoreTabbableFocus(), this._delay(this._restoreTabbableFocus)
		},
		_createWrapper: function () {
			this.uiDialog = q("<div>").hide().attr({
				tabIndex: -1,
				role: "dialog"
			}).appendTo(this._appendTo()), this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front"), this._on(this.uiDialog, {
				keydown: function (t) {
					if (this.options.closeOnEscape && !t.isDefaultPrevented() && t.keyCode && t.keyCode === q.ui.keyCode.ESCAPE) return t.preventDefault(), void this.close(t);
					var e, i, n;
					t.keyCode !== q.ui.keyCode.TAB || t.isDefaultPrevented() || (e = this.uiDialog.find(":tabbable"), i = e.first(), n = e.last(), t.target !== n[0] && t.target !== this.uiDialog[0] || t.shiftKey ? t.target !== i[0] && t.target !== this.uiDialog[0] || !t.shiftKey || (this._delay(function () {
						n.trigger("focus")
					}), t.preventDefault()) : (this._delay(function () {
						i.trigger("focus")
					}), t.preventDefault()))
				},
				mousedown: function (t) {
					this._moveToTop(t) && this._focusTabbable()
				}
			}), this.element.find("[aria-describedby]").length || this.uiDialog.attr({
				"aria-describedby": this.element.uniqueId().attr("id")
			})
		},
		_createTitlebar: function () {
			var t;
			this.uiDialogTitlebar = q("<div>"), this._addClass(this.uiDialogTitlebar, "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix"), this._on(this.uiDialogTitlebar, {
				mousedown: function (t) {
					q(t.target).closest(".ui-dialog-titlebar-close") || this.uiDialog.trigger("focus")
				}
			}), this.uiDialogTitlebarClose = q("<button type='button'></button>").button({
				label: q("<a>").text(this.options.closeText).html(),
				icon: "ui-icon-closethick",
				showLabel: !1
			}).appendTo(this.uiDialogTitlebar), this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close"), this._on(this.uiDialogTitlebarClose, {
				click: function (t) {
					t.preventDefault(), this.close(t)
				}
			}), t = q("<span>").uniqueId().prependTo(this.uiDialogTitlebar), this._addClass(t, "ui-dialog-title"), this._title(t), this.uiDialogTitlebar.prependTo(this.uiDialog), this.uiDialog.attr({
				"aria-labelledby": t.attr("id")
			})
		},
		_title: function (t) {
			this.options.title ? t.text(this.options.title) : t.html("&#160;")
		},
		_createButtonPane: function () {
			this.uiDialogButtonPane = q("<div>"), this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane", "ui-widget-content ui-helper-clearfix"), this.uiButtonSet = q("<div>").appendTo(this.uiDialogButtonPane), this._addClass(this.uiButtonSet, "ui-dialog-buttonset"), this._createButtons()
		},
		_createButtons: function () {
			var n = this,
				t = this.options.buttons;
			this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), q.isEmptyObject(t) || Array.isArray(t) && !t.length ? this._removeClass(this.uiDialog, "ui-dialog-buttons") : (q.each(t, function (t, e) {
				var i;
				e = q.extend({
					type: "button"
				}, e = "function" == typeof e ? {
					click: e,
					text: t
				} : e), i = e.click, t = {
					icon: e.icon,
					iconPosition: e.iconPosition,
					showLabel: e.showLabel,
					icons: e.icons,
					text: e.text
				}, delete e.click, delete e.icon, delete e.iconPosition, delete e.showLabel, delete e.icons, "boolean" == typeof e.text && delete e.text, q("<button></button>", e).button(t).appendTo(n.uiButtonSet).on("click", function () {
					i.apply(n.element[0], arguments)
				})
			}), this._addClass(this.uiDialog, "ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog))
		},
		_makeDraggable: function () {
			function s(t) {
				return {
					position: t.position,
					offset: t.offset
				}
			}
			var o = this,
				r = this.options;
			this.uiDialog.draggable({
				cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
				handle: ".ui-dialog-titlebar",
				containment: "document",
				start: function (t, e) {
					o._addClass(q(this), "ui-dialog-dragging"), o._blockFrames(), o._trigger("dragStart", t, s(e))
				},
				drag: function (t, e) {
					o._trigger("drag", t, s(e))
				},
				stop: function (t, e) {
					var i = e.offset.left - o.document.scrollLeft(),
						n = e.offset.top - o.document.scrollTop();
					r.position = {
						my: "left top",
						at: "left" + (0 <= i ? "+" : "") + i + " top" + (0 <= n ? "+" : "") + n,
						of: o.window
					}, o._removeClass(q(this), "ui-dialog-dragging"), o._unblockFrames(), o._trigger("dragStop", t, s(e))
				}
			})
		},
		_makeResizable: function () {
			function s(t) {
				return {
					originalPosition: t.originalPosition,
					originalSize: t.originalSize,
					position: t.position,
					size: t.size
				}
			}
			var o = this,
				r = this.options,
				t = r.resizable,
				e = this.uiDialog.css("position"),
				t = "string" == typeof t ? t : "n,e,s,w,se,sw,ne,nw";
			this.uiDialog.resizable({
				cancel: ".ui-dialog-content",
				containment: "document",
				alsoResize: this.element,
				maxWidth: r.maxWidth,
				maxHeight: r.maxHeight,
				minWidth: r.minWidth,
				minHeight: this._minHeight(),
				handles: t,
				start: function (t, e) {
					o._addClass(q(this), "ui-dialog-resizing"), o._blockFrames(), o._trigger("resizeStart", t, s(e))
				},
				resize: function (t, e) {
					o._trigger("resize", t, s(e))
				},
				stop: function (t, e) {
					var i = o.uiDialog.offset(),
						n = i.left - o.document.scrollLeft(),
						i = i.top - o.document.scrollTop();
					r.height = o.uiDialog.height(), r.width = o.uiDialog.width(), r.position = {
						my: "left top",
						at: "left" + (0 <= n ? "+" : "") + n + " top" + (0 <= i ? "+" : "") + i,
						of: o.window
					}, o._removeClass(q(this), "ui-dialog-resizing"), o._unblockFrames(), o._trigger("resizeStop", t, s(e))
				}
			}).css("position", e)
		},
		_trackFocus: function () {
			this._on(this.widget(), {
				focusin: function (t) {
					this._makeFocusTarget(), this._focusedElement = q(t.target)
				}
			})
		},
		_makeFocusTarget: function () {
			this._untrackInstance(), this._trackingInstances().unshift(this)
		},
		_untrackInstance: function () {
			var t = this._trackingInstances(),
				e = q.inArray(this, t); - 1 !== e && t.splice(e, 1)
		},
		_trackingInstances: function () {
			var t = this.document.data("ui-dialog-instances");
			return t || this.document.data("ui-dialog-instances", t = []), t
		},
		_minHeight: function () {
			var t = this.options;
			return "auto" === t.height ? t.minHeight : Math.min(t.minHeight, t.height)
		},
		_position: function () {
			var t = this.uiDialog.is(":visible");
			t || this.uiDialog.show(), this.uiDialog.position(this.options.position), t || this.uiDialog.hide()
		},
		_setOptions: function (t) {
			var i = this,
				n = !1,
				s = {};
			q.each(t, function (t, e) {
				i._setOption(t, e), t in i.sizeRelatedOptions && (n = !0), t in i.resizableRelatedOptions && (s[t] = e)
			}), n && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", s)
		},
		_setOption: function (t, e) {
			var i, n = this.uiDialog;
			"disabled" !== t && (this._super(t, e), "appendTo" === t && this.uiDialog.appendTo(this._appendTo()), "buttons" === t && this._createButtons(), "closeText" === t && this.uiDialogTitlebarClose.button({
				label: q("<a>").text("" + this.options.closeText).html()
			}), "draggable" === t && ((i = n.is(":data(ui-draggable)")) && !e && n.draggable("destroy"), !i && e && this._makeDraggable()), "position" === t && this._position(), "resizable" === t && ((i = n.is(":data(ui-resizable)")) && !e && n.resizable("destroy"), i && "string" == typeof e && n.resizable("option", "handles", e), i || !1 === e || this._makeResizable()), "title" === t && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))
		},
		_size: function () {
			var t, e, i, n = this.options;
			this.element.show().css({
				width: "auto",
				minHeight: 0,
				maxHeight: "none",
				height: 0
			}), n.minWidth > n.width && (n.width = n.minWidth), t = this.uiDialog.css({
				height: "auto",
				width: n.width
			}).outerHeight(), e = Math.max(0, n.minHeight - t), i = "number" == typeof n.maxHeight ? Math.max(0, n.maxHeight - t) : "none", "auto" === n.height ? this.element.css({
				minHeight: e,
				maxHeight: i,
				height: "auto"
			}) : this.element.height(Math.max(0, n.height - t)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight())
		},
		_blockFrames: function () {
			this.iframeBlocks = this.document.find("iframe").map(function () {
				var t = q(this);
				return q("<div>").css({
					position: "absolute",
					width: t.outerWidth(),
					height: t.outerHeight()
				}).appendTo(t.parent()).offset(t.offset())[0]
			})
		},
		_unblockFrames: function () {
			this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
		},
		_allowInteraction: function (t) {
			return !!q(t.target).closest(".ui-dialog").length || !!q(t.target).closest(".ui-datepicker").length
		},
		_createOverlay: function () {
			var i, n;
			this.options.modal && (i = q.fn.jquery.substring(0, 4), n = !0, this._delay(function () {
				n = !1
			}), this.document.data("ui-dialog-overlays") || this.document.on("focusin.ui-dialog", function (t) {
				var e;
				n || (e = this._trackingInstances()[0])._allowInteraction(t) || (t.preventDefault(), e._focusTabbable(), "3.4." !== i && "3.5." !== i || e._delay(e._restoreTabbableFocus))
			}.bind(this)), this.overlay = q("<div>").appendTo(this._appendTo()), this._addClass(this.overlay, null, "ui-widget-overlay ui-front"), this._on(this.overlay, {
				mousedown: "_keepFocus"
			}), this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1))
		},
		_destroyOverlay: function () {
			var t;
			this.options.modal && this.overlay && ((t = this.document.data("ui-dialog-overlays") - 1) ? this.document.data("ui-dialog-overlays", t) : (this.document.off("focusin.ui-dialog"), this.document.removeData("ui-dialog-overlays")), this.overlay.remove(), this.overlay = null)
		}
	}), !1 !== q.uiBackCompat && q.widget("ui.dialog", q.ui.dialog, {
		options: {
			dialogClass: ""
		},
		_createWrapper: function () {
			this._super(), this.uiDialog.addClass(this.options.dialogClass)
		},
		_setOption: function (t, e) {
			"dialogClass" === t && this.uiDialog.removeClass(this.options.dialogClass).addClass(e), this._superApply(arguments)
		}
	}), q.ui.dialog, q.widget("ui.droppable", {
		version: "1.13.2",
		widgetEventPrefix: "drop",
		options: {
			accept: "*",
			addClasses: !0,
			greedy: !1,
			scope: "default",
			tolerance: "intersect",
			activate: null,
			deactivate: null,
			drop: null,
			out: null,
			over: null
		},
		_create: function () {
			var t, e = this.options,
				i = e.accept;
			this.isover = !1, this.isout = !0, this.accept = "function" == typeof i ? i : function (t) {
				return t.is(i)
			}, this.proportions = function () {
				if (!arguments.length) return t = t || {
					width: this.element[0].offsetWidth,
					height: this.element[0].offsetHeight
				};
				t = arguments[0]
			}, this._addToManager(e.scope), e.addClasses && this._addClass("ui-droppable")
		},
		_addToManager: function (t) {
			q.ui.ddmanager.droppables[t] = q.ui.ddmanager.droppables[t] || [], q.ui.ddmanager.droppables[t].push(this)
		},
		_splice: function (t) {
			for (var e = 0; e < t.length; e++) t[e] === this && t.splice(e, 1)
		},
		_destroy: function () {
			var t = q.ui.ddmanager.droppables[this.options.scope];
			this._splice(t)
		},
		_setOption: function (t, e) {
			var i;
			"accept" === t ? this.accept = "function" == typeof e ? e : function (t) {
				return t.is(e)
			} : "scope" === t && (i = q.ui.ddmanager.droppables[this.options.scope], this._splice(i), this._addToManager(e)), this._super(t, e)
		},
		_activate: function (t) {
			var e = q.ui.ddmanager.current;
			this._addActiveClass(), e && this._trigger("activate", t, this.ui(e))
		},
		_deactivate: function (t) {
			var e = q.ui.ddmanager.current;
			this._removeActiveClass(), e && this._trigger("deactivate", t, this.ui(e))
		},
		_over: function (t) {
			var e = q.ui.ddmanager.current;
			e && (e.currentItem || e.element)[0] !== this.element[0] && this.accept.call(this.element[0], e.currentItem || e.element) && (this._addHoverClass(), this._trigger("over", t, this.ui(e)))
		},
		_out: function (t) {
			var e = q.ui.ddmanager.current;
			e && (e.currentItem || e.element)[0] !== this.element[0] && this.accept.call(this.element[0], e.currentItem || e.element) && (this._removeHoverClass(), this._trigger("out", t, this.ui(e)))
		},
		_drop: function (e, t) {
			var i = t || q.ui.ddmanager.current,
				n = !1;
			return !(!i || (i.currentItem || i.element)[0] === this.element[0]) && (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function () {
				var t = q(this).droppable("instance");
				if (t.options.greedy && !t.options.disabled && t.options.scope === i.options.scope && t.accept.call(t.element[0], i.currentItem || i.element) && q.ui.intersect(i, q.extend(t, {
					offset: t.element.offset()
				}), t.options.tolerance, e)) return !(n = !0)
			}), !n && !!this.accept.call(this.element[0], i.currentItem || i.element) && (this._removeActiveClass(), this._removeHoverClass(), this._trigger("drop", e, this.ui(i)), this.element))
		},
		ui: function (t) {
			return {
				draggable: t.currentItem || t.element,
				helper: t.helper,
				position: t.position,
				offset: t.positionAbs
			}
		},
		_addHoverClass: function () {
			this._addClass("ui-droppable-hover")
		},
		_removeHoverClass: function () {
			this._removeClass("ui-droppable-hover")
		},
		_addActiveClass: function () {
			this._addClass("ui-droppable-active")
		},
		_removeActiveClass: function () {
			this._removeClass("ui-droppable-active")
		}
	}), q.ui.intersect = function (t, e, i, n) {
		if (!e.offset) return !1;
		var s = (t.positionAbs || t.position.absolute).left + t.margins.left,
			o = (t.positionAbs || t.position.absolute).top + t.margins.top,
			r = s + t.helperProportions.width,
			a = o + t.helperProportions.height,
			l = e.offset.left,
			h = e.offset.top,
			c = l + e.proportions().width,
			u = h + e.proportions().height;
		switch (i) {
			case "fit":
				return l <= s && r <= c && h <= o && a <= u;
			case "intersect":
				return l < s + t.helperProportions.width / 2 && r - t.helperProportions.width / 2 < c && h < o + t.helperProportions.height / 2 && a - t.helperProportions.height / 2 < u;
			case "pointer":
				return H(n.pageY, h, e.proportions().height) && H(n.pageX, l, e.proportions().width);
			case "touch":
				return (h <= o && o <= u || h <= a && a <= u || o < h && u < a) && (l <= s && s <= c || l <= r && r <= c || s < l && c < r);
			default:
				return !1
		}
	}, !(q.ui.ddmanager = {
		current: null,
		droppables: {
			default: []
		},
		prepareOffsets: function (t, e) {
			var i, n, s = q.ui.ddmanager.droppables[t.options.scope] || [],
				o = e ? e.type : null,
				r = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
			t: for (i = 0; i < s.length; i++)
				if (!(s[i].options.disabled || t && !s[i].accept.call(s[i].element[0], t.currentItem || t.element))) {
					for (n = 0; n < r.length; n++)
						if (r[n] === s[i].element[0]) {
							s[i].proportions().height = 0;
							continue t
						}
					s[i].visible = "none" !== s[i].element.css("display"), s[i].visible && ("mousedown" === o && s[i]._activate.call(s[i], e), s[i].offset = s[i].element.offset(), s[i].proportions({
						width: s[i].element[0].offsetWidth,
						height: s[i].element[0].offsetHeight
					}))
				}
		},
		drop: function (t, e) {
			var i = !1;
			return q.each((q.ui.ddmanager.droppables[t.options.scope] || []).slice(), function () {
				this.options && (!this.options.disabled && this.visible && q.ui.intersect(t, this, this.options.tolerance, e) && (i = this._drop.call(this, e) || i), !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = !0, this.isover = !1, this._deactivate.call(this, e)))
			}), i
		},
		dragStart: function (t, e) {
			t.element.parentsUntil("body").on("scroll.droppable", function () {
				t.options.refreshPositions || q.ui.ddmanager.prepareOffsets(t, e)
			})
		},
		drag: function (s, o) {
			s.options.refreshPositions && q.ui.ddmanager.prepareOffsets(s, o), q.each(q.ui.ddmanager.droppables[s.options.scope] || [], function () {
				var t, e, i, n;
				this.options.disabled || this.greedyChild || !this.visible || (n = !(i = q.ui.intersect(s, this, this.options.tolerance, o)) && this.isover ? "isout" : i && !this.isover ? "isover" : null) && (this.options.greedy && (e = this.options.scope, (i = this.element.parents(":data(ui-droppable)").filter(function () {
					return q(this).droppable("instance").options.scope === e
				})).length && ((t = q(i[0]).droppable("instance")).greedyChild = "isover" === n)), t && "isover" === n && (t.isover = !1, t.isout = !0, t._out.call(t, o)), this[n] = !0, this["isout" === n ? "isover" : "isout"] = !1, this["isover" === n ? "_over" : "_out"].call(this, o), t && "isout" === n && (t.isout = !1, t.isover = !0, t._over.call(t, o)))
			})
		},
		dragStop: function (t, e) {
			t.element.parentsUntil("body").off("scroll.droppable"), t.options.refreshPositions || q.ui.ddmanager.prepareOffsets(t, e)
		}
	}) !== q.uiBackCompat && q.widget("ui.droppable", q.ui.droppable, {
		options: {
			hoverClass: !1,
			activeClass: !1
		},
		_addActiveClass: function () {
			this._super(), this.options.activeClass && this.element.addClass(this.options.activeClass)
		},
		_removeActiveClass: function () {
			this._super(), this.options.activeClass && this.element.removeClass(this.options.activeClass)
		},
		_addHoverClass: function () {
			this._super(), this.options.hoverClass && this.element.addClass(this.options.hoverClass)
		},
		_removeHoverClass: function () {
			this._super(), this.options.hoverClass && this.element.removeClass(this.options.hoverClass)
		}
	}), q.ui.droppable, q.widget("ui.progressbar", {
		version: "1.13.2",
		options: {
			classes: {
				"ui-progressbar": "ui-corner-all",
				"ui-progressbar-value": "ui-corner-left",
				"ui-progressbar-complete": "ui-corner-right"
			},
			max: 100,
			value: 0,
			change: null,
			complete: null
		},
		min: 0,
		_create: function () {
			this.oldValue = this.options.value = this._constrainedValue(), this.element.attr({
				role: "progressbar",
				"aria-valuemin": this.min
			}), this._addClass("ui-progressbar", "ui-widget ui-widget-content"), this.valueDiv = q("<div>").appendTo(this.element), this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header"), this._refreshValue()
		},
		_destroy: function () {
			this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"), this.valueDiv.remove()
		},
		value: function (t) {
			if (void 0 === t) return this.options.value;
			this.options.value = this._constrainedValue(t), this._refreshValue()
		},
		_constrainedValue: function (t) {
			return void 0 === t && (t = this.options.value), this.indeterminate = !1 === t, "number" != typeof t && (t = 0), !this.indeterminate && Math.min(this.options.max, Math.max(this.min, t))
		},
		_setOptions: function (t) {
			var e = t.value;
			delete t.value, this._super(t), this.options.value = this._constrainedValue(e), this._refreshValue()
		},
		_setOption: function (t, e) {
			"max" === t && (e = Math.max(this.min, e)), this._super(t, e)
		},
		_setOptionDisabled: function (t) {
			this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t)
		},
		_percentage: function () {
			return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min)
		},
		_refreshValue: function () {
			var t = this.options.value,
				e = this._percentage();
			this.valueDiv.toggle(this.indeterminate || t > this.min).width(e.toFixed(0) + "%"), this._toggleClass(this.valueDiv, "ui-progressbar-complete", null, t === this.options.max)._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), this.overlayDiv || (this.overlayDiv = q("<div>").appendTo(this.valueDiv), this._addClass(this.overlayDiv, "ui-progressbar-overlay"))) : (this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": t
			}), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== t && (this.oldValue = t, this._trigger("change")), t === this.options.max && this._trigger("complete")
		}
	}), q.widget("ui.selectable", q.ui.mouse, {
		version: "1.13.2",
		options: {
			appendTo: "body",
			autoRefresh: !0,
			distance: 0,
			filter: "*",
			tolerance: "touch",
			selected: null,
			selecting: null,
			start: null,
			stop: null,
			unselected: null,
			unselecting: null
		},
		_create: function () {
			var i = this;
			this._addClass("ui-selectable"), this.dragged = !1, this.refresh = function () {
				i.elementPos = q(i.element[0]).offset(), i.selectees = q(i.options.filter, i.element[0]), i._addClass(i.selectees, "ui-selectee"), i.selectees.each(function () {
					var t = q(this),
						e = t.offset(),
						e = {
							left: e.left - i.elementPos.left,
							top: e.top - i.elementPos.top
						};
					q.data(this, "selectable-item", {
						element: this,
						$element: t,
						left: e.left,
						top: e.top,
						right: e.left + t.outerWidth(),
						bottom: e.top + t.outerHeight(),
						startselected: !1,
						selected: t.hasClass("ui-selected"),
						selecting: t.hasClass("ui-selecting"),
						unselecting: t.hasClass("ui-unselecting")
					})
				})
			}, this.refresh(), this._mouseInit(), this.helper = q("<div>"), this._addClass(this.helper, "ui-selectable-helper")
		},
		_destroy: function () {
			this.selectees.removeData("selectable-item"), this._mouseDestroy()
		},
		_mouseStart: function (i) {
			var n = this,
				t = this.options;
			this.opos = [i.pageX, i.pageY], this.elementPos = q(this.element[0]).offset(), this.options.disabled || (this.selectees = q(t.filter, this.element[0]), this._trigger("start", i), q(t.appendTo).append(this.helper), this.helper.css({
				left: i.pageX,
				top: i.pageY,
				width: 0,
				height: 0
			}), t.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function () {
				var t = q.data(this, "selectable-item");
				t.startselected = !0, i.metaKey || i.ctrlKey || (n._removeClass(t.$element, "ui-selected"), t.selected = !1, n._addClass(t.$element, "ui-unselecting"), t.unselecting = !0, n._trigger("unselecting", i, {
					unselecting: t.element
				}))
			}), q(i.target).parents().addBack().each(function () {
				var t, e = q.data(this, "selectable-item");
				if (e) return t = !i.metaKey && !i.ctrlKey || !e.$element.hasClass("ui-selected"), n._removeClass(e.$element, t ? "ui-unselecting" : "ui-selected")._addClass(e.$element, t ? "ui-selecting" : "ui-unselecting"), e.unselecting = !t, e.selecting = t, (e.selected = t) ? n._trigger("selecting", i, {
					selecting: e.element
				}) : n._trigger("unselecting", i, {
					unselecting: e.element
				}), !1
			}))
		},
		_mouseDrag: function (n) {
			if (this.dragged = !0, !this.options.disabled) {
				var t, s = this,
					o = this.options,
					r = this.opos[0],
					a = this.opos[1],
					l = n.pageX,
					h = n.pageY;
				return l < r && (t = l, l = r, r = t), h < a && (t = h, h = a, a = t), this.helper.css({
					left: r,
					top: a,
					width: l - r,
					height: h - a
				}), this.selectees.each(function () {
					var t = q.data(this, "selectable-item"),
						e = !1,
						i = {};
					t && t.element !== s.element[0] && (i.left = t.left + s.elementPos.left, i.right = t.right + s.elementPos.left, i.top = t.top + s.elementPos.top, i.bottom = t.bottom + s.elementPos.top, "touch" === o.tolerance ? e = !(i.left > l || i.right < r || i.top > h || i.bottom < a) : "fit" === o.tolerance && (e = i.left > r && i.right < l && i.top > a && i.bottom < h), e ? (t.selected && (s._removeClass(t.$element, "ui-selected"), t.selected = !1), t.unselecting && (s._removeClass(t.$element, "ui-unselecting"), t.unselecting = !1), t.selecting || (s._addClass(t.$element, "ui-selecting"), t.selecting = !0, s._trigger("selecting", n, {
						selecting: t.element
					}))) : (t.selecting && ((n.metaKey || n.ctrlKey) && t.startselected ? (s._removeClass(t.$element, "ui-selecting"), t.selecting = !1, s._addClass(t.$element, "ui-selected"), t.selected = !0) : (s._removeClass(t.$element, "ui-selecting"), t.selecting = !1, t.startselected && (s._addClass(t.$element, "ui-unselecting"), t.unselecting = !0), s._trigger("unselecting", n, {
						unselecting: t.element
					}))), t.selected && (n.metaKey || n.ctrlKey || t.startselected || (s._removeClass(t.$element, "ui-selected"), t.selected = !1, s._addClass(t.$element, "ui-unselecting"), t.unselecting = !0, s._trigger("unselecting", n, {
						unselecting: t.element
					})))))
				}), !1
			}
		},
		_mouseStop: function (e) {
			var i = this;
			return this.dragged = !1, q(".ui-unselecting", this.element[0]).each(function () {
				var t = q.data(this, "selectable-item");
				i._removeClass(t.$element, "ui-unselecting"), t.unselecting = !1, t.startselected = !1, i._trigger("unselected", e, {
					unselected: t.element
				})
			}), q(".ui-selecting", this.element[0]).each(function () {
				var t = q.data(this, "selectable-item");
				i._removeClass(t.$element, "ui-selecting")._addClass(t.$element, "ui-selected"), t.selecting = !1, t.selected = !0, t.startselected = !0, i._trigger("selected", e, {
					selected: t.element
				})
			}), this._trigger("stop", e), this.helper.remove(), !1
		}
	}), q.widget("ui.selectmenu", [q.ui.formResetMixin, {
		version: "1.13.2",
		defaultElement: "<select>",
		options: {
			appendTo: null,
			classes: {
				"ui-selectmenu-button-open": "ui-corner-top",
				"ui-selectmenu-button-closed": "ui-corner-all"
			},
			disabled: null,
			icons: {
				button: "ui-icon-triangle-1-s"
			},
			position: {
				my: "left top",
				at: "left bottom",
				collision: "none"
			},
			width: !1,
			change: null,
			close: null,
			focus: null,
			open: null,
			select: null
		},
		_create: function () {
			var t = this.element.uniqueId().attr("id");
			this.ids = {
				element: t,
				button: t + "-button",
				menu: t + "-menu"
			}, this._drawButton(), this._drawMenu(), this._bindFormResetHandler(), this._rendered = !1, this.menuItems = q()
		},
		_drawButton: function () {
			var t, e = this,
				i = this._parseOption(this.element.find("option:selected"), this.element[0].selectedIndex);
			this.labels = this.element.labels().attr("for", this.ids.button), this._on(this.labels, {
				click: function (t) {
					this.button.trigger("focus"), t.preventDefault()
				}
			}), this.element.hide(), this.button = q("<span>", {
				tabindex: this.options.disabled ? -1 : 0,
				id: this.ids.button,
				role: "combobox",
				"aria-expanded": "false",
				"aria-autocomplete": "list",
				"aria-owns": this.ids.menu,
				"aria-haspopup": "true",
				title: this.element.attr("title")
			}).insertAfter(this.element), this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed", "ui-button ui-widget"), t = q("<span>").appendTo(this.button), this._addClass(t, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button), this.buttonItem = this._renderButtonItem(i).appendTo(this.button), !1 !== this.options.width && this._resizeButton(), this._on(this.button, this._buttonEvents), this.button.one("focusin", function () {
				e._rendered || e._refreshMenu()
			})
		},
		_drawMenu: function () {
			var i = this;
			this.menu = q("<ul>", {
				"aria-hidden": "true",
				"aria-labelledby": this.ids.button,
				id: this.ids.menu
			}), this.menuWrap = q("<div>").append(this.menu), this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front"), this.menuWrap.appendTo(this._appendTo()), this.menuInstance = this.menu.menu({
				classes: {
					"ui-menu": "ui-corner-bottom"
				},
				role: "listbox",
				select: function (t, e) {
					t.preventDefault(), i._setSelection(), i._select(e.item.data("ui-selectmenu-item"), t)
				},
				focus: function (t, e) {
					e = e.item.data("ui-selectmenu-item"), null != i.focusIndex && e.index !== i.focusIndex && (i._trigger("focus", t, {
						item: e
					}), i.isOpen || i._select(e, t)), i.focusIndex = e.index, i.button.attr("aria-activedescendant", i.menuItems.eq(e.index).attr("id"))
				}
			}).menu("instance"), this.menuInstance._off(this.menu, "mouseleave"), this.menuInstance._closeOnDocumentClick = function () {
				return !1
			}, this.menuInstance._isDivider = function () {
				return !1
			}
		},
		refresh: function () {
			this._refreshMenu(), this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item") || {})), null === this.options.width && this._resizeButton()
		},
		_refreshMenu: function () {
			var t = this.element.find("option");
			this.menu.empty(), this._parseOptions(t), this._renderMenu(this.menu, this.items), this.menuInstance.refresh(), this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"), this._rendered = !0, t.length && (t = this._getSelectedItem(), this.menuInstance.focus(null, t), this._setAria(t.data("ui-selectmenu-item")), this._setOption("disabled", this.element.prop("disabled")))
		},
		open: function (t) {
			this.options.disabled || (this._rendered ? (this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active"), this.menuInstance.focus(null, this._getSelectedItem())) : this._refreshMenu(), this.menuItems.length && (this.isOpen = !0, this._toggleAttr(), this._resizeMenu(), this._position(), this._on(this.document, this._documentClick), this._trigger("open", t)))
		},
		_position: function () {
			this.menuWrap.position(q.extend({
				of: this.button
			}, this.options.position))
		},
		close: function (t) {
			this.isOpen && (this.isOpen = !1, this._toggleAttr(), this.range = null, this._off(this.document), this._trigger("close", t))
		},
		widget: function () {
			return this.button
		},
		menuWidget: function () {
			return this.menu
		},
		_renderButtonItem: function (t) {
			var e = q("<span>");
			return this._setText(e, t.label), this._addClass(e, "ui-selectmenu-text"), e
		},
		_renderMenu: function (n, t) {
			var s = this,
				o = "";
			q.each(t, function (t, e) {
				var i;
				e.optgroup !== o && (i = q("<li>", {
					text: e.optgroup
				}), s._addClass(i, "ui-selectmenu-optgroup", "ui-menu-divider" + (e.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : "")), i.appendTo(n), o = e.optgroup), s._renderItemData(n, e)
			})
		},
		_renderItemData: function (t, e) {
			return this._renderItem(t, e).data("ui-selectmenu-item", e)
		},
		_renderItem: function (t, e) {
			var i = q("<li>"),
				n = q("<div>", {
					title: e.element.attr("title")
				});
			return e.disabled && this._addClass(i, null, "ui-state-disabled"), this._setText(n, e.label), i.append(n).appendTo(t)
		},
		_setText: function (t, e) {
			e ? t.text(e) : t.html("&#160;")
		},
		_move: function (t, e) {
			var i, n = ".ui-menu-item";
			this.isOpen ? i = this.menuItems.eq(this.focusIndex).parent("li") : (i = this.menuItems.eq(this.element[0].selectedIndex).parent("li"), n += ":not(.ui-state-disabled)"), (n = "first" === t || "last" === t ? i["first" === t ? "prevAll" : "nextAll"](n).eq(-1) : i[t + "All"](n).eq(0)).length && this.menuInstance.focus(e, n)
		},
		_getSelectedItem: function () {
			return this.menuItems.eq(this.element[0].selectedIndex).parent("li")
		},
		_toggle: function (t) {
			this[this.isOpen ? "close" : "open"](t)
		},
		_setSelection: function () {
			var t;
			this.range && (window.getSelection ? ((t = window.getSelection()).removeAllRanges(), t.addRange(this.range)) : this.range.select(), this.button.trigger("focus"))
		},
		_documentClick: {
			mousedown: function (t) {
				this.isOpen && (q(t.target).closest(".ui-selectmenu-menu, #" + q.escapeSelector(this.ids.button)).length || this.close(t))
			}
		},
		_buttonEvents: {
			mousedown: function () {
				var t;
				window.getSelection ? (t = window.getSelection()).rangeCount && (this.range = t.getRangeAt(0)) : this.range = document.selection.createRange()
			},
			click: function (t) {
				this._setSelection(), this._toggle(t)
			},
			keydown: function (t) {
				var e = !0;
				switch (t.keyCode) {
					case q.ui.keyCode.TAB:
					case q.ui.keyCode.ESCAPE:
						this.close(t), e = !1;
						break;
					case q.ui.keyCode.ENTER:
						this.isOpen && this._selectFocusedItem(t);
						break;
					case q.ui.keyCode.UP:
						t.altKey ? this._toggle(t) : this._move("prev", t);
						break;
					case q.ui.keyCode.DOWN:
						t.altKey ? this._toggle(t) : this._move("next", t);
						break;
					case q.ui.keyCode.SPACE:
						this.isOpen ? this._selectFocusedItem(t) : this._toggle(t);
						break;
					case q.ui.keyCode.LEFT:
						this._move("prev", t);
						break;
					case q.ui.keyCode.RIGHT:
						this._move("next", t);
						break;
					case q.ui.keyCode.HOME:
					case q.ui.keyCode.PAGE_UP:
						this._move("first", t);
						break;
					case q.ui.keyCode.END:
					case q.ui.keyCode.PAGE_DOWN:
						this._move("last", t);
						break;
					default:
						this.menu.trigger(t), e = !1
				}
				e && t.preventDefault()
			}
		},
		_selectFocusedItem: function (t) {
			var e = this.menuItems.eq(this.focusIndex).parent("li");
			e.hasClass("ui-state-disabled") || this._select(e.data("ui-selectmenu-item"), t)
		},
		_select: function (t, e) {
			var i = this.element[0].selectedIndex;
			this.element[0].selectedIndex = t.index, this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(t)), this._setAria(t), this._trigger("select", e, {
				item: t
			}), t.index !== i && this._trigger("change", e, {
				item: t
			}), this.close(e)
		},
		_setAria: function (t) {
			t = this.menuItems.eq(t.index).attr("id"), this.button.attr({
				"aria-labelledby": t,
				"aria-activedescendant": t
			}), this.menu.attr("aria-activedescendant", t)
		},
		_setOption: function (t, e) {
			var i;
			"icons" === t && (i = this.button.find("span.ui-icon"), this._removeClass(i, null, this.options.icons.button)._addClass(i, null, e.button)), this._super(t, e), "appendTo" === t && this.menuWrap.appendTo(this._appendTo()), "width" === t && this._resizeButton()
		},
		_setOptionDisabled: function (t) {
			this._super(t), this.menuInstance.option("disabled", t), this.button.attr("aria-disabled", t), this._toggleClass(this.button, null, "ui-state-disabled", t), this.element.prop("disabled", t), t ? (this.button.attr("tabindex", -1), this.close()) : this.button.attr("tabindex", 0)
		},
		_appendTo: function () {
			var t = this.options.appendTo;
			return t = (t = (t = t && (t.jquery || t.nodeType ? q(t) : this.document.find(t).eq(0))) && t[0] ? t : this.element.closest(".ui-front, dialog")).length ? t : this.document[0].body
		},
		_toggleAttr: function () {
			this.button.attr("aria-expanded", this.isOpen), this._removeClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open"))._addClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "open" : "closed"))._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen), this.menu.attr("aria-hidden", !this.isOpen)
		},
		_resizeButton: function () {
			var t = this.options.width;
			!1 !== t ? (null === t && (t = this.element.show().outerWidth(), this.element.hide()), this.button.outerWidth(t)) : this.button.css("width", "")
		},
		_resizeMenu: function () {
			this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1))
		},
		_getCreateOptions: function () {
			var t = this._super();
			return t.disabled = this.element.prop("disabled"), t
		},
		_parseOptions: function (t) {
			var i = this,
				n = [];
			t.each(function (t, e) {
				e.hidden || n.push(i._parseOption(q(e), t))
			}), this.items = n
		},
		_parseOption: function (t, e) {
			var i = t.parent("optgroup");
			return {
				element: t,
				index: e,
				value: t.val(),
				label: t.text(),
				optgroup: i.attr("label") || "",
				disabled: i.prop("disabled") || t.prop("disabled")
			}
		},
		_destroy: function () {
			this._unbindFormResetHandler(), this.menuWrap.remove(), this.button.remove(), this.element.show(), this.element.removeUniqueId(), this.labels.attr("for", this.ids.element)
		}
	}]), q.widget("ui.slider", q.ui.mouse, {
		version: "1.13.2",
		widgetEventPrefix: "slide",
		options: {
			animate: !1,
			classes: {
				"ui-slider": "ui-corner-all",
				"ui-slider-handle": "ui-corner-all",
				"ui-slider-range": "ui-corner-all ui-widget-header"
			},
			distance: 0,
			max: 100,
			min: 0,
			orientation: "horizontal",
			range: !1,
			step: 1,
			value: 0,
			values: null,
			change: null,
			slide: null,
			start: null,
			stop: null
		},
		numPages: 5,
		_create: function () {
			this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1
		},
		_refresh: function () {
			this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
		},
		_createHandles: function () {
			var t, e = this.options,
				i = this.element.find(".ui-slider-handle"),
				n = [],
				s = e.values && e.values.length || 1;
			for (i.length > s && (i.slice(s).remove(), i = i.slice(0, s)), t = i.length; t < s; t++) n.push("<span tabindex='0'></span>");
			this.handles = i.add(q(n.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each(function (t) {
				q(this).data("ui-slider-handle-index", t).attr("tabIndex", 0)
			})
		},
		_createRange: function () {
			var t = this.options;
			t.range ? (!0 === t.range && (t.values ? t.values.length && 2 !== t.values.length ? t.values = [t.values[0], t.values[0]] : Array.isArray(t.values) && (t.values = t.values.slice(0)) : t.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
				left: "",
				bottom: ""
			})) : (this.range = q("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== t.range && "max" !== t.range || this._addClass(this.range, "ui-slider-range-" + t.range)) : (this.range && this.range.remove(), this.range = null)
		},
		_setupEvents: function () {
			this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles)
		},
		_destroy: function () {
			this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy()
		},
		_mouseCapture: function (t) {
			var i, n, s, o, e, r, a = this,
				l = this.options;
			return !l.disabled && (this.elementSize = {
				width: this.element.outerWidth(),
				height: this.element.outerHeight()
			}, this.elementOffset = this.element.offset(), r = {
				x: t.pageX,
				y: t.pageY
			}, i = this._normValueFromMouse(r), n = this._valueMax() - this._valueMin() + 1, this.handles.each(function (t) {
				var e = Math.abs(i - a.values(t));
				(e < n || n === e && (t === a._lastChangedValue || a.values(t) === l.min)) && (n = e, s = q(this), o = t)
			}), !1 !== this._start(t, o) && (this._mouseSliding = !0, this._handleIndex = o, this._addClass(s, null, "ui-state-active"), s.trigger("focus"), e = s.offset(), r = !q(t.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = r ? {
				left: 0,
				top: 0
			} : {
				left: t.pageX - e.left - s.width() / 2,
				top: t.pageY - e.top - s.height() / 2 - (parseInt(s.css("borderTopWidth"), 10) || 0) - (parseInt(s.css("borderBottomWidth"), 10) || 0) + (parseInt(s.css("marginTop"), 10) || 0)
			}, this.handles.hasClass("ui-state-hover") || this._slide(t, o, i), this._animateOff = !0))
		},
		_mouseStart: function () {
			return !0
		},
		_mouseDrag: function (t) {
			var e = {
				x: t.pageX,
				y: t.pageY
			},
				e = this._normValueFromMouse(e);
			return this._slide(t, this._handleIndex, e), !1
		},
		_mouseStop: function (t) {
			return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(t, this._handleIndex), this._change(t, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1
		},
		_detectOrientation: function () {
			this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
		},
		_normValueFromMouse: function (t) {
			var e, t = "horizontal" === this.orientation ? (e = this.elementSize.width, t.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (e = this.elementSize.height, t.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)),
				t = t / e;
			return (t = 1 < t ? 1 : t) < 0 && (t = 0), "vertical" === this.orientation && (t = 1 - t), e = this._valueMax() - this._valueMin(), e = this._valueMin() + t * e, this._trimAlignValue(e)
		},
		_uiHash: function (t, e, i) {
			var n = {
				handle: this.handles[t],
				handleIndex: t,
				value: void 0 !== e ? e : this.value()
			};
			return this._hasMultipleValues() && (n.value = void 0 !== e ? e : this.values(t), n.values = i || this.values()), n
		},
		_hasMultipleValues: function () {
			return this.options.values && this.options.values.length
		},
		_start: function (t, e) {
			return this._trigger("start", t, this._uiHash(e))
		},
		_slide: function (t, e, i) {
			var n, s = this.value(),
				o = this.values();
			this._hasMultipleValues() && (n = this.values(e ? 0 : 1), s = this.values(e), 2 === this.options.values.length && !0 === this.options.range && (i = 0 === e ? Math.min(n, i) : Math.max(n, i)), o[e] = i), i !== s && !1 !== this._trigger("slide", t, this._uiHash(e, i, o)) && (this._hasMultipleValues() ? this.values(e, i) : this.value(i))
		},
		_stop: function (t, e) {
			this._trigger("stop", t, this._uiHash(e))
		},
		_change: function (t, e) {
			this._keySliding || this._mouseSliding || (this._lastChangedValue = e, this._trigger("change", t, this._uiHash(e)))
		},
		value: function (t) {
			return arguments.length ? (this.options.value = this._trimAlignValue(t), this._refreshValue(), void this._change(null, 0)) : this._value()
		},
		values: function (t, e) {
			var i, n, s;
			if (1 < arguments.length) return this.options.values[t] = this._trimAlignValue(e), this._refreshValue(), void this._change(null, t);
			if (!arguments.length) return this._values();
			if (!Array.isArray(t)) return this._hasMultipleValues() ? this._values(t) : this.value();
			for (i = this.options.values, n = t, s = 0; s < i.length; s += 1) i[s] = this._trimAlignValue(n[s]), this._change(null, s);
			this._refreshValue()
		},
		_setOption: function (t, e) {
			var i, n = 0;
			switch ("range" === t && !0 === this.options.range && ("min" === e ? (this.options.value = this._values(0), this.options.values = null) : "max" === e && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), Array.isArray(this.options.values) && (n = this.options.values.length), this._super(t, e), t) {
				case "orientation":
					this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(e), this.handles.css("horizontal" === e ? "bottom" : "left", "");
					break;
				case "value":
					this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
					break;
				case "values":
					for (this._animateOff = !0, this._refreshValue(), i = n - 1; 0 <= i; i--) this._change(null, i);
					this._animateOff = !1;
					break;
				case "step":
				case "min":
				case "max":
					this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
					break;
				case "range":
					this._animateOff = !0, this._refresh(), this._animateOff = !1
			}
		},
		_setOptionDisabled: function (t) {
			this._super(t), this._toggleClass(null, "ui-state-disabled", !!t)
		},
		_value: function () {
			var t = this.options.value;
			return t = this._trimAlignValue(t)
		},
		_values: function (t) {
			var e, i;
			if (arguments.length) return t = this.options.values[t], t = this._trimAlignValue(t);
			if (this._hasMultipleValues()) {
				for (e = this.options.values.slice(), i = 0; i < e.length; i += 1) e[i] = this._trimAlignValue(e[i]);
				return e
			}
			return []
		},
		_trimAlignValue: function (t) {
			if (t <= this._valueMin()) return this._valueMin();
			if (t >= this._valueMax()) return this._valueMax();
			var e = 0 < this.options.step ? this.options.step : 1,
				i = (t - this._valueMin()) % e,
				t = t - i;
			return 2 * Math.abs(i) >= e && (t += 0 < i ? e : -e), parseFloat(t.toFixed(5))
		},
		_calculateNewMax: function () {
			var t = this.options.max,
				e = this._valueMin(),
				i = this.options.step;
			(t = Math.round((t - e) / i) * i + e) > this.options.max && (t -= i), this.max = parseFloat(t.toFixed(this._precision()))
		},
		_precision: function () {
			var t = this._precisionOf(this.options.step);
			return t = null !== this.options.min ? Math.max(t, this._precisionOf(this.options.min)) : t
		},
		_precisionOf: function (t) {
			var e = t.toString(),
				t = e.indexOf(".");
			return -1 === t ? 0 : e.length - t - 1
		},
		_valueMin: function () {
			return this.options.min
		},
		_valueMax: function () {
			return this.max
		},
		_refreshRange: function (t) {
			"vertical" === t && this.range.css({
				width: "",
				left: ""
			}), "horizontal" === t && this.range.css({
				height: "",
				bottom: ""
			})
		},
		_refreshValue: function () {
			var e, i, t, n, s, o = this.options.range,
				r = this.options,
				a = this,
				l = !this._animateOff && r.animate,
				h = {};
			this._hasMultipleValues() ? this.handles.each(function (t) {
				i = (a.values(t) - a._valueMin()) / (a._valueMax() - a._valueMin()) * 100, h["horizontal" === a.orientation ? "left" : "bottom"] = i + "%", q(this).stop(1, 1)[l ? "animate" : "css"](h, r.animate), !0 === a.options.range && ("horizontal" === a.orientation ? (0 === t && a.range.stop(1, 1)[l ? "animate" : "css"]({
					left: i + "%"
				}, r.animate), 1 === t && a.range[l ? "animate" : "css"]({
					width: i - e + "%"
				}, {
					queue: !1,
					duration: r.animate
				})) : (0 === t && a.range.stop(1, 1)[l ? "animate" : "css"]({
					bottom: i + "%"
				}, r.animate), 1 === t && a.range[l ? "animate" : "css"]({
					height: i - e + "%"
				}, {
					queue: !1,
					duration: r.animate
				}))), e = i
			}) : (t = this.value(), n = this._valueMin(), s = this._valueMax(), i = s !== n ? (t - n) / (s - n) * 100 : 0, h["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[l ? "animate" : "css"](h, r.animate), "min" === o && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
				width: i + "%"
			}, r.animate), "max" === o && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
				width: 100 - i + "%"
			}, r.animate), "min" === o && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
				height: i + "%"
			}, r.animate), "max" === o && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
				height: 100 - i + "%"
			}, r.animate))
		},
		_handleEvents: {
			keydown: function (t) {
				var e, i, n, s = q(t.target).data("ui-slider-handle-index");
				switch (t.keyCode) {
					case q.ui.keyCode.HOME:
					case q.ui.keyCode.END:
					case q.ui.keyCode.PAGE_UP:
					case q.ui.keyCode.PAGE_DOWN:
					case q.ui.keyCode.UP:
					case q.ui.keyCode.RIGHT:
					case q.ui.keyCode.DOWN:
					case q.ui.keyCode.LEFT:
						if (t.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(q(t.target), null, "ui-state-active"), !1 === this._start(t, s))) return
				}
				switch (n = this.options.step, e = i = this._hasMultipleValues() ? this.values(s) : this.value(), t.keyCode) {
					case q.ui.keyCode.HOME:
						i = this._valueMin();
						break;
					case q.ui.keyCode.END:
						i = this._valueMax();
						break;
					case q.ui.keyCode.PAGE_UP:
						i = this._trimAlignValue(e + (this._valueMax() - this._valueMin()) / this.numPages);
						break;
					case q.ui.keyCode.PAGE_DOWN:
						i = this._trimAlignValue(e - (this._valueMax() - this._valueMin()) / this.numPages);
						break;
					case q.ui.keyCode.UP:
					case q.ui.keyCode.RIGHT:
						if (e === this._valueMax()) return;
						i = this._trimAlignValue(e + n);
						break;
					case q.ui.keyCode.DOWN:
					case q.ui.keyCode.LEFT:
						if (e === this._valueMin()) return;
						i = this._trimAlignValue(e - n)
				}
				this._slide(t, s, i)
			},
			keyup: function (t) {
				var e = q(t.target).data("ui-slider-handle-index");
				this._keySliding && (this._keySliding = !1, this._stop(t, e), this._change(t, e), this._removeClass(q(t.target), null, "ui-state-active"))
			}
		}
	}), q.widget("ui.sortable", q.ui.mouse, {
		version: "1.13.2",
		widgetEventPrefix: "sort",
		ready: !1,
		options: {
			appendTo: "parent",
			axis: !1,
			connectWith: !1,
			containment: !1,
			cursor: "auto",
			cursorAt: !1,
			dropOnEmpty: !0,
			forcePlaceholderSize: !1,
			forceHelperSize: !1,
			grid: !1,
			handle: !1,
			helper: "original",
			items: "> *",
			opacity: !1,
			placeholder: !1,
			revert: !1,
			scroll: !0,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			scope: "default",
			tolerance: "intersect",
			zIndex: 1e3,
			activate: null,
			beforeStop: null,
			change: null,
			deactivate: null,
			out: null,
			over: null,
			receive: null,
			remove: null,
			sort: null,
			start: null,
			stop: null,
			update: null
		},
		_isOverAxis: function (t, e, i) {
			return e <= t && t < e + i
		},
		_isFloating: function (t) {
			return /left|right/.test(t.css("float")) || /inline|table-cell/.test(t.css("display"))
		},
		_create: function () {
			this.containerCache = {}, this._addClass("ui-sortable"), this.refresh(), this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), this.ready = !0
		},
		_setOption: function (t, e) {
			this._super(t, e), "handle" === t && this._setHandleClassName()
		},
		_setHandleClassName: function () {
			var t = this;
			this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle"), q.each(this.items, function () {
				t._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle")
			})
		},
		_destroy: function () {
			this._mouseDestroy();
			for (var t = this.items.length - 1; 0 <= t; t--) this.items[t].item.removeData(this.widgetName + "-item");
			return this
		},
		_mouseCapture: function (t, e) {
			var i = null,
				n = !1,
				s = this;
			return !(this.reverting || this.options.disabled || "static" === this.options.type || (this._refreshItems(t), q(t.target).parents().each(function () {
				if (q.data(this, s.widgetName + "-item") === s) return i = q(this), !1
			}), !(i = q.data(t.target, s.widgetName + "-item") === s ? q(t.target) : i) || this.options.handle && !e && (q(this.options.handle, i).find("*").addBack().each(function () {
				this === t.target && (n = !0)
			}), !n) || (this.currentItem = i, this._removeCurrentsFromItems(), 0)))
		},
		_mouseStart: function (t, e, i) {
			var n, s, o = this.options;
			if ((this.currentContainer = this).refreshPositions(), this.appendTo = q("parent" !== o.appendTo ? o.appendTo : this.currentItem.parent()), this.helper = this._createHelper(t), this._cacheHelperProportions(), this._cacheMargins(), this.offset = this.currentItem.offset(), this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			}, q.extend(this.offset, {
				click: {
					left: t.pageX - this.offset.left,
					top: t.pageY - this.offset.top
				},
				relative: this._getRelativeOffset()
			}), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this.domPosition = {
				prev: this.currentItem.prev()[0],
				parent: this.currentItem.parent()[0]
			}, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), this.scrollParent = this.placeholder.scrollParent(), q.extend(this.offset, {
				parent: this._getParentOffset()
			}), o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (s = this.document.find("body"), this.storedCursor = s.css("cursor"), s.css("cursor", o.cursor), this.storedStylesheet = q("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(s)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o.zIndex)), o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", o.opacity)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !i)
				for (n = this.containers.length - 1; 0 <= n; n--) this.containers[n]._trigger("activate", t, this._uiHash(this));
			return q.ui.ddmanager && (q.ui.ddmanager.current = this), q.ui.ddmanager && !o.dropBehaviour && q.ui.ddmanager.prepareOffsets(this, t), this.dragging = !0, this._addClass(this.helper, "ui-sortable-helper"), this.helper.parent().is(this.appendTo) || (this.helper.detach().appendTo(this.appendTo), this.offset.parent = this._getParentOffset()), this.position = this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, this.lastPositionAbs = this.positionAbs = this._convertPositionTo("absolute"), this._mouseDrag(t), !0
		},
		_scroll: function (t) {
			var e = this.options,
				i = !1;
			return this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < e.scrollSensitivity ? this.scrollParent[0].scrollTop = i = this.scrollParent[0].scrollTop + e.scrollSpeed : t.pageY - this.overflowOffset.top < e.scrollSensitivity && (this.scrollParent[0].scrollTop = i = this.scrollParent[0].scrollTop - e.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < e.scrollSensitivity ? this.scrollParent[0].scrollLeft = i = this.scrollParent[0].scrollLeft + e.scrollSpeed : t.pageX - this.overflowOffset.left < e.scrollSensitivity && (this.scrollParent[0].scrollLeft = i = this.scrollParent[0].scrollLeft - e.scrollSpeed)) : (t.pageY - this.document.scrollTop() < e.scrollSensitivity ? i = this.document.scrollTop(this.document.scrollTop() - e.scrollSpeed) : this.window.height() - (t.pageY - this.document.scrollTop()) < e.scrollSensitivity && (i = this.document.scrollTop(this.document.scrollTop() + e.scrollSpeed)), t.pageX - this.document.scrollLeft() < e.scrollSensitivity ? i = this.document.scrollLeft(this.document.scrollLeft() - e.scrollSpeed) : this.window.width() - (t.pageX - this.document.scrollLeft()) < e.scrollSensitivity && (i = this.document.scrollLeft(this.document.scrollLeft() + e.scrollSpeed))), i
		},
		_mouseDrag: function (t) {
			var e, i, n, s, o = this.options;
			for (this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), o.scroll && !1 !== this._scroll(t) && (this._refreshItemPositions(!0), q.ui.ddmanager && !o.dropBehaviour && q.ui.ddmanager.prepareOffsets(this, t)), this.dragDirection = {
				vertical: this._getDragVerticalDirection(),
				horizontal: this._getDragHorizontalDirection()
			}, e = this.items.length - 1; 0 <= e; e--)
				if (n = (i = this.items[e]).item[0], (s = this._intersectsWithPointer(i)) && i.instance === this.currentContainer && !(n === this.currentItem[0] || this.placeholder[1 === s ? "next" : "prev"]()[0] === n || q.contains(this.placeholder[0], n) || "semi-dynamic" === this.options.type && q.contains(this.element[0], n))) {
					if (this.direction = 1 === s ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(i)) break;
					this._rearrange(t, i), this._trigger("change", t, this._uiHash());
					break
				}
			return this._contactContainers(t), q.ui.ddmanager && q.ui.ddmanager.drag(this, t), this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1
		},
		_mouseStop: function (t, e) {
			var i, n, s, o;
			if (t) return q.ui.ddmanager && !this.options.dropBehaviour && q.ui.ddmanager.drop(this, t), this.options.revert ? (n = (i = this).placeholder.offset(), o = {}, (s = this.options.axis) && "x" !== s || (o.left = n.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), s && "y" !== s || (o.top = n.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = !0, q(this.helper).animate(o, parseInt(this.options.revert, 10) || 500, function () {
				i._clear(t)
			})) : this._clear(t, e), !1
		},
		cancel: function () {
			if (this.dragging) {
				this._mouseUp(new q.Event("mouseup", {
					target: null
				})), "original" === this.options.helper ? (this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")) : this.currentItem.show();
				for (var t = this.containers.length - 1; 0 <= t; t--) this.containers[t]._trigger("deactivate", null, this._uiHash(this)), this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)), this.containers[t].containerCache.over = 0)
			}
			return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), q.extend(this, {
				helper: null,
				dragging: !1,
				reverting: !1,
				_noFinalSort: null
			}), this.domPosition.prev ? q(this.domPosition.prev).after(this.currentItem) : q(this.domPosition.parent).prepend(this.currentItem)), this
		},
		serialize: function (e) {
			var t = this._getItemsAsjQuery(e && e.connected),
				i = [];
			return e = e || {}, q(t).each(function () {
				var t = (q(e.item || this).attr(e.attribute || "id") || "").match(e.expression || /(.+)[\-=_](.+)/);
				t && i.push((e.key || t[1] + "[]") + "=" + (e.key && e.expression ? t[1] : t[2]))
			}), !i.length && e.key && i.push(e.key + "="), i.join("&")
		},
		toArray: function (t) {
			var e = this._getItemsAsjQuery(t && t.connected),
				i = [];
			return t = t || {}, e.each(function () {
				i.push(q(t.item || this).attr(t.attribute || "id") || "")
			}), i
		},
		_intersectsWith: function (t) {
			var e = this.positionAbs.left,
				i = e + this.helperProportions.width,
				n = this.positionAbs.top,
				s = n + this.helperProportions.height,
				o = t.left,
				r = o + t.width,
				a = t.top,
				l = a + t.height,
				h = this.offset.click.top,
				c = this.offset.click.left,
				h = "x" === this.options.axis || a < n + h && n + h < l,
				c = "y" === this.options.axis || o < e + c && e + c < r;
			return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > t[this.floating ? "width" : "height"] ? h && c : o < e + this.helperProportions.width / 2 && i - this.helperProportions.width / 2 < r && a < n + this.helperProportions.height / 2 && s - this.helperProportions.height / 2 < l
		},
		_intersectsWithPointer: function (t) {
			var e = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top, t.height),
				t = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left, t.width);
			return !(!e || !t) && (e = this.dragDirection.vertical, t = this.dragDirection.horizontal, this.floating ? "right" === t || "down" === e ? 2 : 1 : e && ("down" === e ? 2 : 1))
		},
		_intersectsWithSides: function (t) {
			var e = this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top + t.height / 2, t.height),
				i = this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left + t.width / 2, t.width),
				n = this.dragDirection.vertical,
				t = this.dragDirection.horizontal;
			return this.floating && t ? "right" === t && i || "left" === t && !i : n && ("down" === n && e || "up" === n && !e)
		},
		_getDragVerticalDirection: function () {
			var t = this.positionAbs.top - this.lastPositionAbs.top;
			return 0 != t && (0 < t ? "down" : "up")
		},
		_getDragHorizontalDirection: function () {
			var t = this.positionAbs.left - this.lastPositionAbs.left;
			return 0 != t && (0 < t ? "right" : "left")
		},
		refresh: function (t) {
			return this._refreshItems(t), this._setHandleClassName(), this.refreshPositions(), this
		},
		_connectWith: function () {
			var t = this.options;
			return t.connectWith.constructor === String ? [t.connectWith] : t.connectWith
		},
		_getItemsAsjQuery: function (t) {
			function e() {
				r.push(this)
			}
			var i, n, s, o, r = [],
				a = [],
				l = this._connectWith();
			if (l && t)
				for (i = l.length - 1; 0 <= i; i--)
					for (n = (s = q(l[i], this.document[0])).length - 1; 0 <= n; n--)(o = q.data(s[n], this.widgetFullName)) && o !== this && !o.options.disabled && a.push(["function" == typeof o.options.items ? o.options.items.call(o.element) : q(o.options.items, o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), o]);
			for (a.push(["function" == typeof this.options.items ? this.options.items.call(this.element, null, {
				options: this.options,
				item: this.currentItem
			}) : q(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), i = a.length - 1; 0 <= i; i--) a[i][0].each(e);
			return q(r)
		},
		_removeCurrentsFromItems: function () {
			var i = this.currentItem.find(":data(" + this.widgetName + "-item)");
			this.items = q.grep(this.items, function (t) {
				for (var e = 0; e < i.length; e++)
					if (i[e] === t.item[0]) return !1;
				return !0
			})
		},
		_refreshItems: function (t) {
			this.items = [], this.containers = [this];
			var e, i, n, s, o, r, a, l, h = this.items,
				c = [
					["function" == typeof this.options.items ? this.options.items.call(this.element[0], t, {
						item: this.currentItem
					}) : q(this.options.items, this.element), this]
				],
				u = this._connectWith();
			if (u && this.ready)
				for (e = u.length - 1; 0 <= e; e--)
					for (i = (n = q(u[e], this.document[0])).length - 1; 0 <= i; i--)(s = q.data(n[i], this.widgetFullName)) && s !== this && !s.options.disabled && (c.push(["function" == typeof s.options.items ? s.options.items.call(s.element[0], t, {
						item: this.currentItem
					}) : q(s.options.items, s.element), s]), this.containers.push(s));
			for (e = c.length - 1; 0 <= e; e--)
				for (o = c[e][1], l = (r = c[e][i = 0]).length; i < l; i++)(a = q(r[i])).data(this.widgetName + "-item", o), h.push({
					item: a,
					instance: o,
					width: 0,
					height: 0,
					left: 0,
					top: 0
				})
		},
		_refreshItemPositions: function (t) {
			for (var e, i, n = this.items.length - 1; 0 <= n; n--) e = this.items[n], this.currentContainer && e.instance !== this.currentContainer && e.item[0] !== this.currentItem[0] || (i = this.options.toleranceElement ? q(this.options.toleranceElement, e.item) : e.item, t || (e.width = i.outerWidth(), e.height = i.outerHeight()), i = i.offset(), e.left = i.left, e.top = i.top)
		},
		refreshPositions: function (t) {
			var e, i;
			if (this.floating = !!this.items.length && ("x" === this.options.axis || this._isFloating(this.items[0].item)), this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset()), this._refreshItemPositions(t), this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);
			else
				for (e = this.containers.length - 1; 0 <= e; e--) i = this.containers[e].element.offset(), this.containers[e].containerCache.left = i.left, this.containers[e].containerCache.top = i.top, this.containers[e].containerCache.width = this.containers[e].element.outerWidth(), this.containers[e].containerCache.height = this.containers[e].element.outerHeight();
			return this
		},
		_createPlaceholder: function (i) {
			var n, s, o = (i = i || this).options;
			o.placeholder && o.placeholder.constructor !== String || (n = o.placeholder, s = i.currentItem[0].nodeName.toLowerCase(), o.placeholder = {
				element: function () {
					var t = q("<" + s + ">", i.document[0]);
					return i._addClass(t, "ui-sortable-placeholder", n || i.currentItem[0].className)._removeClass(t, "ui-sortable-helper"), "tbody" === s ? i._createTrPlaceholder(i.currentItem.find("tr").eq(0), q("<tr>", i.document[0]).appendTo(t)) : "tr" === s ? i._createTrPlaceholder(i.currentItem, t) : "img" === s && t.attr("src", i.currentItem.attr("src")), n || t.css("visibility", "hidden"), t
				},
				update: function (t, e) {
					n && !o.forcePlaceholderSize || (e.height() && (!o.forcePlaceholderSize || "tbody" !== s && "tr" !== s) || e.height(i.currentItem.innerHeight() - parseInt(i.currentItem.css("paddingTop") || 0, 10) - parseInt(i.currentItem.css("paddingBottom") || 0, 10)), e.width() || e.width(i.currentItem.innerWidth() - parseInt(i.currentItem.css("paddingLeft") || 0, 10) - parseInt(i.currentItem.css("paddingRight") || 0, 10)))
				}
			}), i.placeholder = q(o.placeholder.element.call(i.element, i.currentItem)), i.currentItem.after(i.placeholder), o.placeholder.update(i, i.placeholder)
		},
		_createTrPlaceholder: function (t, e) {
			var i = this;
			t.children().each(function () {
				q("<td>&#160;</td>", i.document[0]).attr("colspan", q(this).attr("colspan") || 1).appendTo(e)
			})
		},
		_contactContainers: function (t) {
			for (var e, i, n, s, o, r, a, l, h, c = null, u = null, d = this.containers.length - 1; 0 <= d; d--) q.contains(this.currentItem[0], this.containers[d].element[0]) || (this._intersectsWith(this.containers[d].containerCache) ? c && q.contains(this.containers[d].element[0], c.element[0]) || (c = this.containers[d], u = d) : this.containers[d].containerCache.over && (this.containers[d]._trigger("out", t, this._uiHash(this)), this.containers[d].containerCache.over = 0));
			if (c)
				if (1 === this.containers.length) this.containers[u].containerCache.over || (this.containers[u]._trigger("over", t, this._uiHash(this)), this.containers[u].containerCache.over = 1);
				else {
					for (i = 1e4, n = null, s = (l = c.floating || this._isFloating(this.currentItem)) ? "left" : "top", o = l ? "width" : "height", h = l ? "pageX" : "pageY", e = this.items.length - 1; 0 <= e; e--) q.contains(this.containers[u].element[0], this.items[e].item[0]) && this.items[e].item[0] !== this.currentItem[0] && (r = this.items[e].item.offset()[s], a = !1, t[h] - r > this.items[e][o] / 2 && (a = !0), Math.abs(t[h] - r) < i && (i = Math.abs(t[h] - r), n = this.items[e], this.direction = a ? "up" : "down"));
					(n || this.options.dropOnEmpty) && (this.currentContainer !== this.containers[u] ? (n ? this._rearrange(t, n, null, !0) : this._rearrange(t, null, this.containers[u].element, !0), this._trigger("change", t, this._uiHash()), this.containers[u]._trigger("change", t, this._uiHash(this)), this.currentContainer = this.containers[u], this.options.placeholder.update(this.currentContainer, this.placeholder), this.scrollParent = this.placeholder.scrollParent(), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this.containers[u]._trigger("over", t, this._uiHash(this)), this.containers[u].containerCache.over = 1) : this.currentContainer.containerCache.over || (this.containers[u]._trigger("over", t, this._uiHash()), this.currentContainer.containerCache.over = 1))
				}
		},
		_createHelper: function (t) {
			var e = this.options,
				t = "function" == typeof e.helper ? q(e.helper.apply(this.element[0], [t, this.currentItem])) : "clone" === e.helper ? this.currentItem.clone() : this.currentItem;
			return t.parents("body").length || this.appendTo[0].appendChild(t[0]), t[0] === this.currentItem[0] && (this._storedCSS = {
				width: this.currentItem[0].style.width,
				height: this.currentItem[0].style.height,
				position: this.currentItem.css("position"),
				top: this.currentItem.css("top"),
				left: this.currentItem.css("left")
			}), t[0].style.width && !e.forceHelperSize || t.width(this.currentItem.width()), t[0].style.height && !e.forceHelperSize || t.height(this.currentItem.height()), t
		},
		_adjustOffsetFromHelper: function (t) {
			"string" == typeof t && (t = t.split(" ")), "left" in (t = Array.isArray(t) ? {
				left: +t[0],
				top: +t[1] || 0
			} : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
		},
		_getParentOffset: function () {
			this.offsetParent = this.helper.offsetParent();
			var t = this.offsetParent.offset();
			return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && q.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), {
				top: (t = this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && q.ui.ie ? {
					top: 0,
					left: 0
				} : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
				left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
			}
		},
		_getRelativeOffset: function () {
			if ("relative" !== this.cssPosition) return {
				top: 0,
				left: 0
			};
			var t = this.currentItem.position();
			return {
				top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
				left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
			}
		},
		_cacheMargins: function () {
			this.margins = {
				left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
				top: parseInt(this.currentItem.css("marginTop"), 10) || 0
			}
		},
		_cacheHelperProportions: function () {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			}
		},
		_setContainment: function () {
			var t, e, i = this.options;
			"parent" === i.containment && (i.containment = this.helper[0].parentNode), "document" !== i.containment && "window" !== i.containment || (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === i.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === i.containment ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(i.containment) || (t = q(i.containment)[0], e = q(i.containment).offset(), i = "hidden" !== q(t).css("overflow"), this.containment = [e.left + (parseInt(q(t).css("borderLeftWidth"), 10) || 0) + (parseInt(q(t).css("paddingLeft"), 10) || 0) - this.margins.left, e.top + (parseInt(q(t).css("borderTopWidth"), 10) || 0) + (parseInt(q(t).css("paddingTop"), 10) || 0) - this.margins.top, e.left + (i ? Math.max(t.scrollWidth, t.offsetWidth) : t.offsetWidth) - (parseInt(q(t).css("borderLeftWidth"), 10) || 0) - (parseInt(q(t).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, e.top + (i ? Math.max(t.scrollHeight, t.offsetHeight) : t.offsetHeight) - (parseInt(q(t).css("borderTopWidth"), 10) || 0) - (parseInt(q(t).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top])
		},
		_convertPositionTo: function (t, e) {
			e = e || this.position;
			var i = "absolute" === t ? 1 : -1,
				n = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && q.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
				t = /(html|body)/i.test(n[0].tagName);
			return {
				top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : t ? 0 : n.scrollTop()) * i,
				left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : t ? 0 : n.scrollLeft()) * i
			}
		},
		_generatePosition: function (t) {
			var e = this.options,
				i = t.pageX,
				n = t.pageY,
				s = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && q.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
				o = /(html|body)/i.test(s[0].tagName);
			return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (i = this.containment[0] + this.offset.click.left), t.pageY - this.offset.click.top < this.containment[1] && (n = this.containment[1] + this.offset.click.top), t.pageX - this.offset.click.left > this.containment[2] && (i = this.containment[2] + this.offset.click.left), t.pageY - this.offset.click.top > this.containment[3] && (n = this.containment[3] + this.offset.click.top)), e.grid && (t = this.originalPageY + Math.round((n - this.originalPageY) / e.grid[1]) * e.grid[1], n = !this.containment || t - this.offset.click.top >= this.containment[1] && t - this.offset.click.top <= this.containment[3] ? t : t - this.offset.click.top >= this.containment[1] ? t - e.grid[1] : t + e.grid[1], t = this.originalPageX + Math.round((i - this.originalPageX) / e.grid[0]) * e.grid[0], i = !this.containment || t - this.offset.click.left >= this.containment[0] && t - this.offset.click.left <= this.containment[2] ? t : t - this.offset.click.left >= this.containment[0] ? t - e.grid[0] : t + e.grid[0])), {
				top: n - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : o ? 0 : s.scrollTop()),
				left: i - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : o ? 0 : s.scrollLeft())
			}
		},
		_rearrange: function (t, e, i, n) {
			i ? i[0].appendChild(this.placeholder[0]) : e.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? e.item[0] : e.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
			var s = this.counter;
			this._delay(function () {
				s === this.counter && this.refreshPositions(!n)
			})
		},
		_clear: function (t, e) {
			function i(e, i, n) {
				return function (t) {
					n._trigger(e, t, i._uiHash(i))
				}
			}
			this.reverting = !1;
			var n, s = [];
			if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
				for (n in this._storedCSS) "auto" !== this._storedCSS[n] && "static" !== this._storedCSS[n] || (this._storedCSS[n] = "");
				this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")
			} else this.currentItem.show();
			for (this.fromOutside && !e && s.push(function (t) {
				this._trigger("receive", t, this._uiHash(this.fromOutside))
			}), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || e || s.push(function (t) {
				this._trigger("update", t, this._uiHash())
			}), this !== this.currentContainer && (e || (s.push(function (t) {
				this._trigger("remove", t, this._uiHash())
			}), s.push(function (e) {
				return function (t) {
					e._trigger("receive", t, this._uiHash(this))
				}
			}.call(this, this.currentContainer)), s.push(function (e) {
				return function (t) {
					e._trigger("update", t, this._uiHash(this))
				}
			}.call(this, this.currentContainer)))), n = this.containers.length - 1; 0 <= n; n--) e || s.push(i("deactivate", this, this.containers[n])), this.containers[n].containerCache.over && (s.push(i("out", this, this.containers[n])), this.containers[n].containerCache.over = 0);
			if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, e || this._trigger("beforeStop", t, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null), !e) {
				for (n = 0; n < s.length; n++) s[n].call(this, t);
				this._trigger("stop", t, this._uiHash())
			}
			return this.fromOutside = !1, !this.cancelHelperRemoval
		},
		_trigger: function () {
			!1 === q.Widget.prototype._trigger.apply(this, arguments) && this.cancel()
		},
		_uiHash: function (t) {
			var e = t || this;
			return {
				helper: e.helper,
				placeholder: e.placeholder || q([]),
				position: e.position,
				originalPosition: e.originalPosition,
				offset: e.positionAbs,
				item: e.currentItem,
				sender: t ? t.element : null
			}
		}
	}), q.widget("ui.spinner", {
		version: "1.13.2",
		defaultElement: "<input>",
		widgetEventPrefix: "spin",
		options: {
			classes: {
				"ui-spinner": "ui-corner-all",
				"ui-spinner-down": "ui-corner-br",
				"ui-spinner-up": "ui-corner-tr"
			},
			culture: null,
			icons: {
				down: "ui-icon-triangle-1-s",
				up: "ui-icon-triangle-1-n"
			},
			incremental: !0,
			max: null,
			min: null,
			numberFormat: null,
			page: 10,
			step: 1,
			change: null,
			spin: null,
			start: null,
			stop: null
		},
		_create: function () {
			this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), "" !== this.value() && this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
				beforeunload: function () {
					this.element.removeAttr("autocomplete")
				}
			})
		},
		_getCreateOptions: function () {
			var n = this._super(),
				s = this.element;
			return q.each(["min", "max", "step"], function (t, e) {
				var i = s.attr(e);
				null != i && i.length && (n[e] = i)
			}), n
		},
		_events: {
			keydown: function (t) {
				this._start(t) && this._keydown(t) && t.preventDefault()
			},
			keyup: "_stop",
			focus: function () {
				this.previous = this.element.val()
			},
			blur: function (t) {
				this.cancelBlur ? delete this.cancelBlur : (this._stop(), this._refresh(), this.previous !== this.element.val() && this._trigger("change", t))
			},
			mousewheel: function (t, e) {
				var i = q.ui.safeActiveElement(this.document[0]);
				if (this.element[0] === i && e) {
					if (!this.spinning && !this._start(t)) return !1;
					this._spin((0 < e ? 1 : -1) * this.options.step, t), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function () {
						this.spinning && this._stop(t)
					}, 100), t.preventDefault()
				}
			},
			"mousedown .ui-spinner-button": function (t) {
				function e() {
					this.element[0] === q.ui.safeActiveElement(this.document[0]) || (this.element.trigger("focus"), this.previous = i, this._delay(function () {
						this.previous = i
					}))
				}
				var i;
				i = this.element[0] === q.ui.safeActiveElement(this.document[0]) ? this.previous : this.element.val(), t.preventDefault(), e.call(this), this.cancelBlur = !0, this._delay(function () {
					delete this.cancelBlur, e.call(this)
				}), !1 !== this._start(t) && this._repeat(null, q(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
			},
			"mouseup .ui-spinner-button": "_stop",
			"mouseenter .ui-spinner-button": function (t) {
				if (q(t.currentTarget).hasClass("ui-state-active")) return !1 !== this._start(t) && void this._repeat(null, q(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
			},
			"mouseleave .ui-spinner-button": "_stop"
		},
		_enhance: function () {
			this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>")
		},
		_draw: function () {
			this._enhance(), this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content"), this._addClass("ui-spinner-input"), this.element.attr("role", "spinbutton"), this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", !0).button({
				classes: {
					"ui-button": ""
				}
			}), this._removeClass(this.buttons, "ui-corner-all"), this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up"), this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down"), this.buttons.first().button({
				icon: this.options.icons.up,
				showLabel: !1
			}), this.buttons.last().button({
				icon: this.options.icons.down,
				showLabel: !1
			}), this.buttons.height() > Math.ceil(.5 * this.uiSpinner.height()) && 0 < this.uiSpinner.height() && this.uiSpinner.height(this.uiSpinner.height())
		},
		_keydown: function (t) {
			var e = this.options,
				i = q.ui.keyCode;
			switch (t.keyCode) {
				case i.UP:
					return this._repeat(null, 1, t), !0;
				case i.DOWN:
					return this._repeat(null, -1, t), !0;
				case i.PAGE_UP:
					return this._repeat(null, e.page, t), !0;
				case i.PAGE_DOWN:
					return this._repeat(null, -e.page, t), !0
			}
			return !1
		},
		_start: function (t) {
			return !(!this.spinning && !1 === this._trigger("start", t)) && (this.counter || (this.counter = 1), this.spinning = !0)
		},
		_repeat: function (t, e, i) {
			t = t || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
				this._repeat(40, e, i)
			}, t), this._spin(e * this.options.step, i)
		},
		_spin: function (t, e) {
			var i = this.value() || 0;
			this.counter || (this.counter = 1), i = this._adjustValue(i + t * this._increment(this.counter)), this.spinning && !1 === this._trigger("spin", e, {
				value: i
			}) || (this._value(i), this.counter++)
		},
		_increment: function (t) {
			var e = this.options.incremental;
			return e ? "function" == typeof e ? e(t) : Math.floor(t * t * t / 5e4 - t * t / 500 + 17 * t / 200 + 1) : 1
		},
		_precision: function () {
			var t = this._precisionOf(this.options.step);
			return t = null !== this.options.min ? Math.max(t, this._precisionOf(this.options.min)) : t
		},
		_precisionOf: function (t) {
			var e = t.toString(),
				t = e.indexOf(".");
			return -1 === t ? 0 : e.length - t - 1
		},
		_adjustValue: function (t) {
			var e = this.options,
				i = null !== e.min ? e.min : 0,
				n = t - i;
			return t = i + Math.round(n / e.step) * e.step, t = parseFloat(t.toFixed(this._precision())), null !== e.max && t > e.max ? e.max : null !== e.min && t < e.min ? e.min : t
		},
		_stop: function (t) {
			this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", t))
		},
		_setOption: function (t, e) {
			var i;
			if ("culture" === t || "numberFormat" === t) return i = this._parse(this.element.val()), this.options[t] = e, void this.element.val(this._format(i));
			"max" !== t && "min" !== t && "step" !== t || "string" == typeof e && (e = this._parse(e)), "icons" === t && (i = this.buttons.first().find(".ui-icon"), this._removeClass(i, null, this.options.icons.up), this._addClass(i, null, e.up), i = this.buttons.last().find(".ui-icon"), this._removeClass(i, null, this.options.icons.down), this._addClass(i, null, e.down)), this._super(t, e)
		},
		_setOptionDisabled: function (t) {
			this._super(t), this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!t), this.element.prop("disabled", !!t), this.buttons.button(t ? "disable" : "enable")
		},
		_setOptions: n(function (t) {
			this._super(t)
		}),
		_parse: function (t) {
			return "" === (t = "string" == typeof t && "" !== t ? window.Globalize && this.options.numberFormat ? Globalize.parseFloat(t, 10, this.options.culture) : +t : t) || isNaN(t) ? null : t
		},
		_format: function (t) {
			return "" === t ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(t, this.options.numberFormat, this.options.culture) : t
		},
		_refresh: function () {
			this.element.attr({
				"aria-valuemin": this.options.min,
				"aria-valuemax": this.options.max,
				"aria-valuenow": this._parse(this.element.val())
			})
		},
		isValid: function () {
			var t = this.value();
			return null !== t && t === this._adjustValue(t)
		},
		_value: function (t, e) {
			var i;
			"" !== t && null !== (i = this._parse(t)) && (e || (i = this._adjustValue(i)), t = this._format(i)), this.element.val(t), this._refresh()
		},
		_destroy: function () {
			this.element.prop("disabled", !1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"), this.uiSpinner.replaceWith(this.element)
		},
		stepUp: n(function (t) {
			this._stepUp(t)
		}),
		_stepUp: function (t) {
			this._start() && (this._spin((t || 1) * this.options.step), this._stop())
		},
		stepDown: n(function (t) {
			this._stepDown(t)
		}),
		_stepDown: function (t) {
			this._start() && (this._spin((t || 1) * -this.options.step), this._stop())
		},
		pageUp: n(function (t) {
			this._stepUp((t || 1) * this.options.page)
		}),
		pageDown: n(function (t) {
			this._stepDown((t || 1) * this.options.page)
		}),
		value: function (t) {
			if (!arguments.length) return this._parse(this.element.val());
			n(this._value).call(this, t)
		},
		widget: function () {
			return this.uiSpinner
		}
	}), !1 !== q.uiBackCompat && q.widget("ui.spinner", q.ui.spinner, {
		_enhance: function () {
			this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())
		},
		_uiSpinnerHtml: function () {
			return "<span>"
		},
		_buttonHtml: function () {
			return "<a></a><a></a>"
		}
	});
	var L;
	q.ui.spinner, q.widget("ui.tabs", {
		version: "1.13.2",
		delay: 300,
		options: {
			active: null,
			classes: {
				"ui-tabs": "ui-corner-all",
				"ui-tabs-nav": "ui-corner-all",
				"ui-tabs-panel": "ui-corner-bottom",
				"ui-tabs-tab": "ui-corner-top"
			},
			collapsible: !1,
			event: "click",
			heightStyle: "content",
			hide: null,
			show: null,
			activate: null,
			beforeActivate: null,
			beforeLoad: null,
			load: null
		},
		_isLocal: (L = /#.*$/, function (t) {
			var e = t.href.replace(L, ""),
				i = location.href.replace(L, "");
			try {
				e = decodeURIComponent(e)
			} catch (t) { }
			try {
				i = decodeURIComponent(i)
			} catch (t) { }
			return 1 < t.hash.length && e === i
		}),
		_create: function () {
			var e = this,
				t = this.options;
			this.running = !1, this._addClass("ui-tabs", "ui-widget ui-widget-content"), this._toggleClass("ui-tabs-collapsible", null, t.collapsible), this._processTabs(), t.active = this._initialActive(), Array.isArray(t.disabled) && (t.disabled = q.uniqueSort(t.disabled.concat(q.map(this.tabs.filter(".ui-state-disabled"), function (t) {
				return e.tabs.index(t)
			}))).sort()), !1 !== this.options.active && this.anchors.length ? this.active = this._findActive(t.active) : this.active = q(), this._refresh(), this.active.length && this.load(t.active)
		},
		_initialActive: function () {
			var i = this.options.active,
				t = this.options.collapsible,
				n = location.hash.substring(1);
			return null === i && (n && this.tabs.each(function (t, e) {
				if (q(e).attr("aria-controls") === n) return i = t, !1
			}), null !== (i = null === i ? this.tabs.index(this.tabs.filter(".ui-tabs-active")) : i) && -1 !== i || (i = !!this.tabs.length && 0)), !1 !== i && -1 === (i = this.tabs.index(this.tabs.eq(i))) && (i = !t && 0), i = !t && !1 === i && this.anchors.length ? 0 : i
		},
		_getCreateEventData: function () {
			return {
				tab: this.active,
				panel: this.active.length ? this._getPanelForTab(this.active) : q()
			}
		},
		_tabKeydown: function (t) {
			var e = q(q.ui.safeActiveElement(this.document[0])).closest("li"),
				i = this.tabs.index(e),
				n = !0;
			if (!this._handlePageNav(t)) {
				switch (t.keyCode) {
					case q.ui.keyCode.RIGHT:
					case q.ui.keyCode.DOWN:
						i++;
						break;
					case q.ui.keyCode.UP:
					case q.ui.keyCode.LEFT:
						n = !1, i--;
						break;
					case q.ui.keyCode.END:
						i = this.anchors.length - 1;
						break;
					case q.ui.keyCode.HOME:
						i = 0;
						break;
					case q.ui.keyCode.SPACE:
						return t.preventDefault(), clearTimeout(this.activating), void this._activate(i);
					case q.ui.keyCode.ENTER:
						return t.preventDefault(), clearTimeout(this.activating), void this._activate(i !== this.options.active && i);
					default:
						return
				}
				t.preventDefault(), clearTimeout(this.activating), i = this._focusNextTab(i, n), t.ctrlKey || t.metaKey || (e.attr("aria-selected", "false"), this.tabs.eq(i).attr("aria-selected", "true"), this.activating = this._delay(function () {
					this.option("active", i)
				}, this.delay))
			}
		},
		_panelKeydown: function (t) {
			this._handlePageNav(t) || t.ctrlKey && t.keyCode === q.ui.keyCode.UP && (t.preventDefault(), this.active.trigger("focus"))
		},
		_handlePageNav: function (t) {
			return t.altKey && t.keyCode === q.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : t.altKey && t.keyCode === q.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0
		},
		_findNextTab: function (t, e) {
			for (var i = this.tabs.length - 1; - 1 !== q.inArray(t = (t = i < t ? 0 : t) < 0 ? i : t, this.options.disabled);) t = e ? t + 1 : t - 1;
			return t
		},
		_focusNextTab: function (t, e) {
			return t = this._findNextTab(t, e), this.tabs.eq(t).trigger("focus"), t
		},
		_setOption: function (t, e) {
			"active" !== t ? (this._super(t, e), "collapsible" === t && (this._toggleClass("ui-tabs-collapsible", null, e), e || !1 !== this.options.active || this._activate(0)), "event" === t && this._setupEvents(e), "heightStyle" === t && this._setupHeightStyle(e)) : this._activate(e)
		},
		_sanitizeSelector: function (t) {
			return t ? t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : ""
		},
		refresh: function () {
			var t = this.options,
				e = this.tablist.children(":has(a[href])");
			t.disabled = q.map(e.filter(".ui-state-disabled"), function (t) {
				return e.index(t)
			}), this._processTabs(), !1 !== t.active && this.anchors.length ? this.active.length && !q.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1, this.active = q()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active) : (t.active = !1, this.active = q()), this._refresh()
		},
		_refresh: function () {
			this._setOptionDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
				"aria-selected": "false",
				"aria-expanded": "false",
				tabIndex: -1
			}), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
				"aria-hidden": "true"
			}), this.active.length ? (this.active.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			}), this._addClass(this.active, "ui-tabs-active", "ui-state-active"), this._getPanelForTab(this.active).show().attr({
				"aria-hidden": "false"
			})) : this.tabs.eq(0).attr("tabIndex", 0)
		},
		_processTabs: function () {
			var l = this,
				t = this.tabs,
				e = this.anchors,
				i = this.panels;
			this.tablist = this._getList().attr("role", "tablist"), this._addClass(this.tablist, "ui-tabs-nav", "ui-helper-reset ui-helper-clearfix ui-widget-header"), this.tablist.on("mousedown" + this.eventNamespace, "> li", function (t) {
				q(this).is(".ui-state-disabled") && t.preventDefault()
			}).on("focus" + this.eventNamespace, ".ui-tabs-anchor", function () {
				q(this).closest("li").is(".ui-state-disabled") && this.blur()
			}), this.tabs = this.tablist.find("> li:has(a[href])").attr({
				role: "tab",
				tabIndex: -1
			}), this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default"), this.anchors = this.tabs.map(function () {
				return q("a", this)[0]
			}).attr({
				tabIndex: -1
			}), this._addClass(this.anchors, "ui-tabs-anchor"), this.panels = q(), this.anchors.each(function (t, e) {
				var i, n, s, o = q(e).uniqueId().attr("id"),
					r = q(e).closest("li"),
					a = r.attr("aria-controls");
				l._isLocal(e) ? (s = (i = e.hash).substring(1), n = l.element.find(l._sanitizeSelector(i))) : (s = r.attr("aria-controls") || q({}).uniqueId()[0].id, (n = l.element.find(i = "#" + s)).length || (n = l._createPanel(s)).insertAfter(l.panels[t - 1] || l.tablist), n.attr("aria-live", "polite")), n.length && (l.panels = l.panels.add(n)), a && r.data("ui-tabs-aria-controls", a), r.attr({
					"aria-controls": s,
					"aria-labelledby": o
				}), n.attr("aria-labelledby", o)
			}), this.panels.attr("role", "tabpanel"), this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content"), t && (this._off(t.not(this.tabs)), this._off(e.not(this.anchors)), this._off(i.not(this.panels)))
		},
		_getList: function () {
			return this.tablist || this.element.find("ol, ul").eq(0)
		},
		_createPanel: function (t) {
			return q("<div>").attr("id", t).data("ui-tabs-destroy", !0)
		},
		_setOptionDisabled: function (t) {
			var e, i;
			for (Array.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1), i = 0; e = this.tabs[i]; i++) e = q(e), !0 === t || -1 !== q.inArray(i, t) ? (e.attr("aria-disabled", "true"), this._addClass(e, null, "ui-state-disabled")) : (e.removeAttr("aria-disabled"), this._removeClass(e, null, "ui-state-disabled"));
			this.options.disabled = t, this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !0 === t)
		},
		_setupEvents: function (t) {
			var i = {};
			t && q.each(t.split(" "), function (t, e) {
				i[e] = "_eventHandler"
			}), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, {
				click: function (t) {
					t.preventDefault()
				}
			}), this._on(this.anchors, i), this._on(this.tabs, {
				keydown: "_tabKeydown"
			}), this._on(this.panels, {
				keydown: "_panelKeydown"
			}), this._focusable(this.tabs), this._hoverable(this.tabs)
		},
		_setupHeightStyle: function (t) {
			var i, e = this.element.parent();
			"fill" === t ? (i = e.height(), i -= this.element.outerHeight() - this.element.height(), this.element.siblings(":visible").each(function () {
				var t = q(this),
					e = t.css("position");
				"absolute" !== e && "fixed" !== e && (i -= t.outerHeight(!0))
			}), this.element.children().not(this.panels).each(function () {
				i -= q(this).outerHeight(!0)
			}), this.panels.each(function () {
				q(this).height(Math.max(0, i - q(this).innerHeight() + q(this).height()))
			}).css("overflow", "auto")) : "auto" === t && (i = 0, this.panels.each(function () {
				i = Math.max(i, q(this).height("").height())
			}).height(i))
		},
		_eventHandler: function (t) {
			var e = this.options,
				i = this.active,
				n = q(t.currentTarget).closest("li"),
				s = n[0] === i[0],
				o = s && e.collapsible,
				r = o ? q() : this._getPanelForTab(n),
				a = i.length ? this._getPanelForTab(i) : q(),
				i = {
					oldTab: i,
					oldPanel: a,
					newTab: o ? q() : n,
					newPanel: r
				};
			t.preventDefault(), n.hasClass("ui-state-disabled") || n.hasClass("ui-tabs-loading") || this.running || s && !e.collapsible || !1 === this._trigger("beforeActivate", t, i) || (e.active = !o && this.tabs.index(n), this.active = s ? q() : n, this.xhr && this.xhr.abort(), a.length || r.length || q.error("jQuery UI Tabs: Mismatching fragment identifier."), r.length && this.load(this.tabs.index(n), t), this._toggle(t, i))
		},
		_toggle: function (t, e) {
			function i() {
				s.running = !1, s._trigger("activate", t, e)
			}

			function n() {
				s._addClass(e.newTab.closest("li"), "ui-tabs-active", "ui-state-active"), o.length && s.options.show ? s._show(o, s.options.show, i) : (o.show(), i())
			}
			var s = this,
				o = e.newPanel,
				r = e.oldPanel;
			this.running = !0, r.length && this.options.hide ? this._hide(r, this.options.hide, function () {
				s._removeClass(e.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), n()
			}) : (this._removeClass(e.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), r.hide(), n()), r.attr("aria-hidden", "true"), e.oldTab.attr({
				"aria-selected": "false",
				"aria-expanded": "false"
			}), o.length && r.length ? e.oldTab.attr("tabIndex", -1) : o.length && this.tabs.filter(function () {
				return 0 === q(this).attr("tabIndex")
			}).attr("tabIndex", -1), o.attr("aria-hidden", "false"), e.newTab.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			})
		},
		_activate: function (t) {
			var t = this._findActive(t);
			t[0] !== this.active[0] && (t = (t = t.length ? t : this.active).find(".ui-tabs-anchor")[0], this._eventHandler({
				target: t,
				currentTarget: t,
				preventDefault: q.noop
			}))
		},
		_findActive: function (t) {
			return !1 === t ? q() : this.tabs.eq(t)
		},
		_getIndex: function (t) {
			return t = "string" == typeof t ? this.anchors.index(this.anchors.filter("[href$='" + q.escapeSelector(t) + "']")) : t
		},
		_destroy: function () {
			this.xhr && this.xhr.abort(), this.tablist.removeAttr("role").off(this.eventNamespace), this.anchors.removeAttr("role tabIndex").removeUniqueId(), this.tabs.add(this.panels).each(function () {
				q.data(this, "ui-tabs-destroy") ? q(this).remove() : q(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")
			}), this.tabs.each(function () {
				var t = q(this),
					e = t.data("ui-tabs-aria-controls");
				e ? t.attr("aria-controls", e).removeData("ui-tabs-aria-controls") : t.removeAttr("aria-controls")
			}), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "")
		},
		enable: function (i) {
			var t = this.options.disabled;
			!1 !== t && (t = void 0 !== i && (i = this._getIndex(i), Array.isArray(t) ? q.map(t, function (t) {
				return t !== i ? t : null
			}) : q.map(this.tabs, function (t, e) {
				return e !== i ? e : null
			})), this._setOptionDisabled(t))
		},
		disable: function (t) {
			var e = this.options.disabled;
			if (!0 !== e) {
				if (void 0 === t) e = !0;
				else {
					if (t = this._getIndex(t), -1 !== q.inArray(t, e)) return;
					e = Array.isArray(e) ? q.merge([t], e).sort() : [t]
				}
				this._setOptionDisabled(e)
			}
		},
		load: function (t, n) {
			function s(t, e) {
				"abort" === e && o.panels.stop(!1, !0), o._removeClass(i, "ui-tabs-loading"), r.removeAttr("aria-busy"), t === o.xhr && delete o.xhr
			}
			t = this._getIndex(t);
			var o = this,
				i = this.tabs.eq(t),
				t = i.find(".ui-tabs-anchor"),
				r = this._getPanelForTab(i),
				a = {
					tab: i,
					panel: r
				};
			this._isLocal(t[0]) || (this.xhr = q.ajax(this._ajaxSettings(t, n, a)), this.xhr && "canceled" !== this.xhr.statusText && (this._addClass(i, "ui-tabs-loading"), r.attr("aria-busy", "true"), this.xhr.done(function (t, e, i) {
				setTimeout(function () {
					r.html(t), o._trigger("load", n, a), s(i, e)
				}, 1)
			}).fail(function (t, e) {
				setTimeout(function () {
					s(t, e)
				}, 1)
			})))
		},
		_ajaxSettings: function (t, i, n) {
			var s = this;
			return {
				url: t.attr("href").replace(/#.*$/, ""),
				beforeSend: function (t, e) {
					return s._trigger("beforeLoad", i, q.extend({
						jqXHR: t,
						ajaxSettings: e
					}, n))
				}
			}
		},
		_getPanelForTab: function (t) {
			return t = q(t).attr("aria-controls"), this.element.find(this._sanitizeSelector("#" + t))
		}
	}), !1 !== q.uiBackCompat && q.widget("ui.tabs", q.ui.tabs, {
		_processTabs: function () {
			this._superApply(arguments), this._addClass(this.tabs, "ui-tab")
		}
	}), q.ui.tabs, q.widget("ui.tooltip", {
		version: "1.13.2",
		options: {
			classes: {
				"ui-tooltip": "ui-corner-all ui-widget-shadow"
			},
			content: function () {
				var t = q(this).attr("title");
				return q("<a>").text(t).html()
			},
			hide: !0,
			items: "[title]:not([disabled])",
			position: {
				my: "left top+15",
				at: "left bottom",
				collision: "flipfit flip"
			},
			show: !0,
			track: !1,
			close: null,
			open: null
		},
		_addDescribedBy: function (t, e) {
			var i = (t.attr("aria-describedby") || "").split(/\s+/);
			i.push(e), t.data("ui-tooltip-id", e).attr("aria-describedby", String.prototype.trim.call(i.join(" ")))
		},
		_removeDescribedBy: function (t) {
			var e = t.data("ui-tooltip-id"),
				i = (t.attr("aria-describedby") || "").split(/\s+/),
				e = q.inArray(e, i); - 1 !== e && i.splice(e, 1), t.removeData("ui-tooltip-id"), (i = String.prototype.trim.call(i.join(" "))) ? t.attr("aria-describedby", i) : t.removeAttr("aria-describedby")
		},
		_create: function () {
			this._on({
				mouseover: "open",
				focusin: "open"
			}), this.tooltips = {}, this.parents = {}, this.liveRegion = q("<div>").attr({
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			}).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this.disabledTitles = q([])
		},
		_setOption: function (t, e) {
			var i = this;
			this._super(t, e), "content" === t && q.each(this.tooltips, function (t, e) {
				i._updateContent(e.element)
			})
		},
		_setOptionDisabled: function (t) {
			this[t ? "_disable" : "_enable"]()
		},
		_disable: function () {
			var n = this;
			q.each(this.tooltips, function (t, e) {
				var i = q.Event("blur");
				i.target = i.currentTarget = e.element[0], n.close(i, !0)
			}), this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function () {
				var t = q(this);
				if (t.is("[title]")) return t.data("ui-tooltip-title", t.attr("title")).removeAttr("title")
			}))
		},
		_enable: function () {
			this.disabledTitles.each(function () {
				var t = q(this);
				t.data("ui-tooltip-title") && t.attr("title", t.data("ui-tooltip-title"))
			}), this.disabledTitles = q([])
		},
		open: function (t) {
			var i = this,
				e = q(t ? t.target : this.element).closest(this.options.items);
			e.length && !e.data("ui-tooltip-id") && (e.attr("title") && e.data("ui-tooltip-title", e.attr("title")), e.data("ui-tooltip-open", !0), t && "mouseover" === t.type && e.parents().each(function () {
				var t, e = q(this);
				e.data("ui-tooltip-open") && ((t = q.Event("blur")).target = t.currentTarget = this, i.close(t, !0)), e.attr("title") && (e.uniqueId(), i.parents[this.id] = {
					element: this,
					title: e.attr("title")
				}, e.attr("title", ""))
			}), this._registerCloseHandlers(t, e), this._updateContent(e, t))
		},
		_updateContent: function (e, i) {
			var t = this.options.content,
				n = this,
				s = i ? i.type : null;
			if ("string" == typeof t || t.nodeType || t.jquery) return this._open(i, e, t);
			(t = t.call(e[0], function (t) {
				n._delay(function () {
					e.data("ui-tooltip-open") && (i && (i.type = s), this._open(i, e, t))
				})
			})) && this._open(i, e, t)
		},
		_open: function (t, e, i) {
			function n(t) {
				a.of = t, o.is(":hidden") || o.position(a)
			}
			var s, o, r, a = q.extend({}, this.options.position);
			i && ((s = this._find(e)) ? s.tooltip.find(".ui-tooltip-content").html(i) : (e.is("[title]") && (t && "mouseover" === t.type ? e.attr("title", "") : e.removeAttr("title")), s = this._tooltip(e), o = s.tooltip, this._addDescribedBy(e, o.attr("id")), o.find(".ui-tooltip-content").html(i), this.liveRegion.children().hide(), (i = q("<div>").html(o.find(".ui-tooltip-content").html())).removeAttr("name").find("[name]").removeAttr("name"), i.removeAttr("id").find("[id]").removeAttr("id"), i.appendTo(this.liveRegion), this.options.track && t && /^mouse/.test(t.type) ? (this._on(this.document, {
				mousemove: n
			}), n(t)) : o.position(q.extend({
				of: e
			}, this.options.position)), o.hide(), this._show(o, this.options.show), this.options.track && this.options.show && this.options.show.delay && (r = this.delayedShow = setInterval(function () {
				o.is(":visible") && (n(a.of), clearInterval(r))
			}, 13)), this._trigger("open", t, {
				tooltip: o
			})))
		},
		_registerCloseHandlers: function (t, e) {
			var i = {
				keyup: function (t) {
					t.keyCode === q.ui.keyCode.ESCAPE && ((t = q.Event(t)).currentTarget = e[0], this.close(t, !0))
				}
			};
			e[0] !== this.element[0] && (i.remove = function () {
				var t = this._find(e);
				t && this._removeTooltip(t.tooltip)
			}), t && "mouseover" !== t.type || (i.mouseleave = "close"), t && "focusin" !== t.type || (i.focusout = "close"), this._on(!0, e, i)
		},
		close: function (t) {
			var e, i = this,
				n = q(t ? t.currentTarget : this.element),
				s = this._find(n);
			s ? (e = s.tooltip, s.closing || (clearInterval(this.delayedShow), n.data("ui-tooltip-title") && !n.attr("title") && n.attr("title", n.data("ui-tooltip-title")), this._removeDescribedBy(n), s.hiding = !0, e.stop(!0), this._hide(e, this.options.hide, function () {
				i._removeTooltip(q(this))
			}), n.removeData("ui-tooltip-open"), this._off(n, "mouseleave focusout keyup"), n[0] !== this.element[0] && this._off(n, "remove"), this._off(this.document, "mousemove"), t && "mouseleave" === t.type && q.each(this.parents, function (t, e) {
				q(e.element).attr("title", e.title), delete i.parents[t]
			}), s.closing = !0, this._trigger("close", t, {
				tooltip: e
			}), s.hiding || (s.closing = !1))) : n.removeData("ui-tooltip-open")
		},
		_tooltip: function (t) {
			var e = q("<div>").attr("role", "tooltip"),
				i = q("<div>").appendTo(e),
				n = e.uniqueId().attr("id");
			return this._addClass(i, "ui-tooltip-content"), this._addClass(e, "ui-tooltip", "ui-widget ui-widget-content"), e.appendTo(this._appendTo(t)), this.tooltips[n] = {
				element: t,
				tooltip: e
			}
		},
		_find: function (t) {
			return t = t.data("ui-tooltip-id"), t ? this.tooltips[t] : null
		},
		_removeTooltip: function (t) {
			clearInterval(this.delayedShow), t.remove(), delete this.tooltips[t.attr("id")]
		},
		_appendTo: function (t) {
			return t = t.closest(".ui-front, dialog"), t = t.length ? t : this.document[0].body
		},
		_destroy: function () {
			var n = this;
			q.each(this.tooltips, function (t, e) {
				var i = q.Event("blur"),
					e = e.element;
				i.target = i.currentTarget = e[0], n.close(i, !0), q("#" + t).remove(), e.data("ui-tooltip-title") && (e.attr("title") || e.attr("title", e.data("ui-tooltip-title")), e.removeData("ui-tooltip-title"))
			}), this.liveRegion.remove()
		}
	}), !1 !== q.uiBackCompat && q.widget("ui.tooltip", q.ui.tooltip, {
		options: {
			tooltipClass: null
		},
		_tooltip: function () {
			var t = this._superApply(arguments);
			return this.options.tooltipClass && t.tooltip.addClass(this.options.tooltipClass), t
		}
	}), q.ui.tooltip
});
(function (l) {
	var h = {
		init: function (t) {
			var e = l.extend({
				items: 1,
				itemsOnPage: 1,
				pages: 0,
				displayedPages: 5,
				edges: 2,
				currentPage: 0,
				hrefTextPrefix: "#page-",
				hrefTextSuffix: "",
				prevText: "Prev",
				nextText: "Next",
				ellipseText: "&hellip;",
				cssStyle: "light-theme",
				listStyle: "",
				labelMap: [],
				selectOnClick: true,
				nextAtFront: false,
				invertPageOrder: false,
				useStartEdge: true,
				useEndEdge: true,
				onPageClick: function (t, e) { },
				onInit: function () { }
			}, t || {});
			var i = this;
			e.pages = e.pages ? e.pages : Math.ceil(e.items / e.itemsOnPage) ? Math.ceil(e.items / e.itemsOnPage) : 1;
			if (e.currentPage) e.currentPage = e.currentPage - 1;
			else e.currentPage = !e.invertPageOrder ? 0 : e.pages - 1;
			e.halfDisplayed = e.displayedPages / 2;
			this.each(function () {
				i.addClass(e.cssStyle + " simple-pagination").data("pagination", e);
				h._draw.call(i)
			});
			e.onInit();
			return this
		},
		selectPage: function (t) {
			h._selectPage.call(this, t - 1);
			return this
		},
		prevPage: function () {
			var t = this.data("pagination");
			if (!t.invertPageOrder) {
				if (t.currentPage > 0) {
					h._selectPage.call(this, t.currentPage - 1)
				}
			} else {
				if (t.currentPage < t.pages - 1) {
					h._selectPage.call(this, t.currentPage + 1)
				}
			}
			return this
		},
		nextPage: function () {
			var t = this.data("pagination");
			if (!t.invertPageOrder) {
				if (t.currentPage < t.pages - 1) {
					h._selectPage.call(this, t.currentPage + 1)
				}
			} else {
				if (t.currentPage > 0) {
					h._selectPage.call(this, t.currentPage - 1)
				}
			}
			return this
		},
		getPagesCount: function () {
			return this.data("pagination").pages
		},
		setPagesCount: function (t) {
			this.data("pagination").pages = t
		},
		getCurrentPage: function () {
			return this.data("pagination").currentPage + 1
		},
		destroy: function () {
			this.empty();
			return this
		},
		drawPage: function (t) {
			var e = this.data("pagination");
			e.currentPage = t - 1;
			this.data("pagination", e);
			h._draw.call(this);
			return this
		},
		redraw: function () {
			h._draw.call(this);
			return this
		},
		disable: function () {
			var t = this.data("pagination");
			t.disabled = true;
			this.data("pagination", t);
			h._draw.call(this);
			return this
		},
		enable: function () {
			var t = this.data("pagination");
			t.disabled = false;
			this.data("pagination", t);
			h._draw.call(this);
			return this
		},
		updateItems: function (t) {
			var e = this.data("pagination");
			e.items = t;
			e.pages = h._getPages(e);
			this.data("pagination", e);
			h._draw.call(this)
		},
		updateItemsOnPage: function (t) {
			var e = this.data("pagination");
			e.itemsOnPage = t;
			e.pages = h._getPages(e);
			this.data("pagination", e);
			h._selectPage.call(this, 0);
			return this
		},
		getItemsOnPage: function () {
			return this.data("pagination").itemsOnPage
		},
		_draw: function () {
			var t = this.data("pagination"),
				e = h._getInterval(t),
				i, n;
			h.destroy.call(this);
			n = typeof this.prop === "function" ? this.prop("tagName") : this.attr("tagName");
			var s = n === "UL" ? this : l("<ul" + (t.listStyle ? ' class="' + t.listStyle + '"' : "") + "></ul>").appendTo(this);
			if (t.prevText) {
				h._appendItem.call(this, !t.invertPageOrder ? t.currentPage - 1 : t.currentPage + 1, {
					text: t.prevText,
					classes: "prev"
				})
			}
			if (t.nextText && t.nextAtFront) {
				h._appendItem.call(this, !t.invertPageOrder ? t.currentPage + 1 : t.currentPage - 1, {
					text: t.nextText,
					classes: "next"
				})
			}
			if (!t.invertPageOrder) {
				if (e.start > 0 && t.edges > 0) {
					if (t.useStartEdge) {
						var o = Math.min(t.edges, e.start);
						for (i = 0; i < o; i++) {
							h._appendItem.call(this, i)
						}
					}
					if (t.edges < e.start && e.start - t.edges != 1) {
						s.append('<li class="disabled"><span class="ellipse">' + t.ellipseText + "</span></li>")
					} else if (e.start - t.edges == 1) {
						h._appendItem.call(this, t.edges)
					}
				}
			} else {
				if (e.end < t.pages && t.edges > 0) {
					if (t.useStartEdge) {
						var r = Math.max(t.pages - t.edges, e.end);
						for (i = t.pages - 1; i >= r; i--) {
							h._appendItem.call(this, i)
						}
					}
					if (t.pages - t.edges > e.end && t.pages - t.edges - e.end != 1) {
						s.append('<li class="disabled"><span class="ellipse">' + t.ellipseText + "</span></li>")
					} else if (t.pages - t.edges - e.end == 1) {
						h._appendItem.call(this, e.end)
					}
				}
			}
			if (!t.invertPageOrder) {
				for (i = e.start; i < e.end; i++) {
					h._appendItem.call(this, i)
				}
			} else {
				for (i = e.end - 1; i >= e.start; i--) {
					h._appendItem.call(this, i)
				}
			}
			if (!t.invertPageOrder) {
				if (e.end < t.pages && t.edges > 0) {
					if (t.pages - t.edges > e.end && t.pages - t.edges - e.end != 1) {
						s.append('<li class="disabled"><span class="ellipse">' + t.ellipseText + "</span></li>")
					} else if (t.pages - t.edges - e.end == 1) {
						h._appendItem.call(this, e.end)
					}
					if (t.useEndEdge) {
						var r = Math.max(t.pages - t.edges, e.end);
						for (i = r; i < t.pages; i++) {
							h._appendItem.call(this, i)
						}
					}
				}
			} else {
				if (e.start > 0 && t.edges > 0) {
					if (t.edges < e.start && e.start - t.edges != 1) {
						s.append('<li class="disabled"><span class="ellipse">' + t.ellipseText + "</span></li>")
					} else if (e.start - t.edges == 1) {
						h._appendItem.call(this, t.edges)
					}
					if (t.useEndEdge) {
						var o = Math.min(t.edges, e.start);
						for (i = o - 1; i >= 0; i--) {
							h._appendItem.call(this, i)
						}
					}
				}
			}
			if (t.nextText && !t.nextAtFront) {
				h._appendItem.call(this, !t.invertPageOrder ? t.currentPage + 1 : t.currentPage - 1, {
					text: t.nextText,
					classes: "next"
				})
			}
		},
		_getPages: function (t) {
			var e = Math.ceil(t.items / t.itemsOnPage);
			return e || 1
		},
		_getInterval: function (t) {
			return {
				start: Math.ceil(t.currentPage > t.halfDisplayed ? Math.max(Math.min(t.currentPage - t.halfDisplayed, t.pages - t.displayedPages), 0) : 0),
				end: Math.ceil(t.currentPage > t.halfDisplayed ? Math.min(t.currentPage + t.halfDisplayed, t.pages) : Math.min(t.displayedPages, t.pages))
			}
		},
		_appendItem: function (e, t) {
			var i = this,
				n, s, o = i.data("pagination"),
				r = l("<li></li>"),
				a = i.find("ul");
			e = e < 0 ? 0 : e < o.pages ? e : o.pages - 1;
			n = {
				text: e + 1,
				classes: ""
			};
			if (o.labelMap.length && o.labelMap[e]) {
				n.text = o.labelMap[e]
			}
			n = l.extend(n, t || {});
			if (e == o.currentPage || o.disabled) {
				if (o.disabled || n.classes === "prev" || n.classes === "next") {
					r.addClass("disabled")
				} else {
					r.addClass("active")
				}
				s = l('<span class="current">' + n.text + "</span>")
			} else {
				s = l('<a href="' + o.hrefTextPrefix + (e + 1) + o.hrefTextSuffix + '" class="page-link">' + n.text + "</a>");
				s.click(function (t) {
					return h._selectPage.call(i, e, t)
				})
			}
			if (n.classes) {
				s.addClass(n.classes)
			}
			r.append(s);
			if (a.length) {
				a.append(r)
			} else {
				i.append(r)
			}
		},
		_selectPage: function (t, e) {
			var i = this.data("pagination");
			i.currentPage = t;
			if (i.selectOnClick) {
				h._draw.call(this)
			}
			return i.onPageClick(t + 1, e)
		}
	};
	l.fn.pagination = function (t) {
		if (h[t] && t.charAt(0) != "_") {
			return h[t].apply(this, Array.prototype.slice.call(arguments, 1))
		} else if (typeof t === "object" || !t) {
			return h.init.apply(this, arguments)
		} else {
			l.error("Method " + t + " does not exist on jQuery.pagination")
		}
	}
})(jQuery);
(function ($) {
	$.extend({
		tablesorter: new function () {
			var parsers = [],
				widgets = [];
			this.defaults = {
				cssHeader: "header",
				cssAsc: "headerSortUp",
				cssDesc: "headerSortDown",
				cssChildRow: "expand-child",
				sortInitialOrder: "asc",
				sortMultiSortKey: "shiftKey",
				sortForce: null,
				sortAppend: null,
				sortLocaleCompare: true,
				textExtraction: "simple",
				parsers: {},
				widgets: [],
				widgetZebra: {
					css: ["even", "odd"]
				},
				headers: {},
				widthFixed: false,
				cancelSelection: true,
				sortList: [],
				headerList: [],
				dateFormat: "us",
				decimal: "/.|,/g",
				onRenderHeader: null,
				selectorHeaders: "thead th",
				debug: false
			};

			function benchmark(t, e) {
				log(t + "," + ((new Date).getTime() - e.getTime()) + "ms")
			}
			this.benchmark = benchmark;

			function log(t) {
				if (typeof console != "undefined" && typeof console.debug != "undefined") {
					console.log(t)
				} else {
					alert(t)
				}
			}

			function buildParserCache(t, e) {
				if (t.config.debug) {
					var i = ""
				}
				if (t.tBodies.length == 0) return;
				var n = t.tBodies[0].rows;
				if (n[0]) {
					var s = [],
						o = n[0].cells,
						r = o.length;
					for (var a = 0; a < r; a++) {
						var l = false;
						if ($.metadata && ($(e[a]).metadata() && $(e[a]).metadata().sorter)) {
							l = getParserById($(e[a]).metadata().sorter)
						} else if (t.config.headers[a] && t.config.headers[a].sorter) {
							l = getParserById(t.config.headers[a].sorter)
						}
						if (!l) {
							l = detectParserForColumn(t, n, -1, a)
						}
						if (t.config.debug) {
							i += "column:" + a + " parser:" + l.id + "\n"
						}
						s.push(l)
					}
				}
				if (t.config.debug) {
					log(i)
				}
				return s
			}

			function detectParserForColumn(t, e, i, n) {
				var s = parsers.length,
					o = false,
					r = false,
					a = true;
				while (r == "" && a) {
					i++;
					if (e[i]) {
						o = getNodeFromRowAndCellIndex(e, i, n);
						r = trimAndGetNodeText(t.config, o);
						if (t.config.debug) {
							log("Checking if value was empty on row:" + i)
						}
					} else {
						a = false
					}
				}
				for (var l = 1; l < s; l++) {
					if (parsers[l].is(r, t, o)) {
						return parsers[l]
					}
				}
				return parsers[0]
			}

			function getNodeFromRowAndCellIndex(t, e, i) {
				return t[e].cells[i]
			}

			function trimAndGetNodeText(t, e) {
				return $.trim(getElementText(t, e))
			}

			function getParserById(t) {
				var e = parsers.length;
				for (var i = 0; i < e; i++) {
					if (parsers[i].id.toLowerCase() == t.toLowerCase()) {
						return parsers[i]
					}
				}
				return false
			}

			function buildCache(t) {
				if (t.config.debug) {
					var e = new Date
				}
				var i = t.tBodies[0] && t.tBodies[0].rows.length || 0,
					n = t.tBodies[0].rows[0] && t.tBodies[0].rows[0].cells.length || 0,
					s = t.config.parsers,
					o = {
						row: [],
						normalized: []
					};
				for (var r = 0; r < i; ++r) {
					var a = $(t.tBodies[0].rows[r]),
						l = [];
					if (a.hasClass(t.config.cssChildRow)) {
						o.row[o.row.length - 1] = o.row[o.row.length - 1].add(a);
						continue
					}
					o.row.push(a);
					for (var h = 0; h < n; ++h) {
						l.push(s[h].format(getElementText(t.config, a[0].cells[h]), t, a[0].cells[h]))
					}
					l.push(o.normalized.length);
					o.normalized.push(l);
					l = null
				}
				if (t.config.debug) {
					benchmark("Building cache for " + i + " rows:", e)
				}
				return o
			}

			function getElementText(t, e) {
				var i = "";
				if (!e) return "";
				if (!t.supportsTextContent) t.supportsTextContent = e.textContent || false;
				if (t.textExtraction == "simple") {
					if (t.supportsTextContent) {
						i = e.textContent
					} else {
						if (e.childNodes[0] && e.childNodes[0].hasChildNodes()) {
							i = e.childNodes[0].innerHTML
						} else {
							i = e.innerHTML
						}
					}
				} else {
					if (typeof t.textExtraction == "function") {
						i = t.textExtraction(e)
					} else {
						i = $(e).text()
					}
				}
				return i
			}

			function appendToTable(t, e) {
				if (t.config.debug) {
					var i = new Date
				}
				var n = e,
					s = n.row,
					o = n.normalized,
					r = o.length,
					a = o[0].length - 1,
					l = $(t.tBodies[0]),
					h = [];
				for (var c = 0; c < r; c++) {
					var u = o[c][a];
					h.push(s[u]);
					if (!t.config.appender) {
						var d = s[u].length;
						for (var f = 0; f < d; f++) {
							l[0].appendChild(s[u][f])
						}
					}
				}
				if (t.config.appender) {
					t.config.appender(t, h)
				}
				h = null;
				if (t.config.debug) {
					benchmark("Rebuilt table:", i)
				}
				applyWidget(t);
				setTimeout(function () {
					$(t).trigger("sortEnd")
				}, 0)
			}

			function buildHeaders(i) {
				if (i.config.debug) {
					var t = new Date
				}
				var e = $.metadata ? true : false;
				var n = computeTableHeaderCellIndexes(i);
				$tableHeaders = $(i.config.selectorHeaders, i).each(function (t) {
					this.column = n[this.parentNode.rowIndex + "-" + this.cellIndex];
					this.order = formatSortingOrder(i.config.sortInitialOrder);
					this.count = this.order;
					if (checkHeaderMetadata(this) || checkHeaderOptions(i, t)) this.sortDisabled = true;
					if (checkHeaderOptionsSortingLocked(i, t)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(i, t);
					if (!this.sortDisabled) {
						var e = $(this).addClass(i.config.cssHeader);
						if (i.config.onRenderHeader) i.config.onRenderHeader.apply(e)
					}
					i.config.headerList[t] = this
				});
				if (i.config.debug) {
					benchmark("Built headers:", t);
					log($tableHeaders)
				}
				return $tableHeaders
			}

			function computeTableHeaderCellIndexes(t) {
				var e = [];
				var i = {};
				var n = t.getElementsByTagName("THEAD")[0];
				var s = n.getElementsByTagName("TR");
				for (var o = 0; o < s.length; o++) {
					var r = s[o].cells;
					for (var a = 0; a < r.length; a++) {
						var l = r[a];
						var h = l.parentNode.rowIndex;
						var c = h + "-" + l.cellIndex;
						var u = l.rowSpan || 1;
						var d = l.colSpan || 1;
						var f;
						if (typeof e[h] == "undefined") {
							e[h] = []
						}
						for (var p = 0; p < e[h].length + 1; p++) {
							if (typeof e[h][p] == "undefined") {
								f = p;
								break
							}
						}
						i[c] = f;
						for (var p = h; p < h + u; p++) {
							if (typeof e[p] == "undefined") {
								e[p] = []
							}
							var g = e[p];
							for (var m = f; m < f + d; m++) {
								g[m] = "x"
							}
						}
					}
				}
				return i
			}

			function checkCellColSpan(t, e, i) {
				var n = [],
					s = t.tHead.rows,
					o = s[i].cells;
				for (var r = 0; r < o.length; r++) {
					var a = o[r];
					if (a.colSpan > 1) {
						n = n.concat(checkCellColSpan(t, headerArr, i++))
					} else {
						if (t.tHead.length == 1 || (a.rowSpan > 1 || !s[i + 1])) {
							n.push(a)
						}
					}
				}
				return n
			}

			function checkHeaderMetadata(t) {
				if ($.metadata && $(t).metadata().sorter === false) {
					return true
				}
				return false
			}

			function checkHeaderOptions(t, e) {
				if (t.config.headers[e] && t.config.headers[e].sorter === false) {
					return true
				}
				return false
			}

			function checkHeaderOptionsSortingLocked(t, e) {
				if (t.config.headers[e] && t.config.headers[e].lockedOrder) return t.config.headers[e].lockedOrder;
				return false
			}

			function applyWidget(t) {
				var e = t.config.widgets;
				var i = e.length;
				for (var n = 0; n < i; n++) {
					getWidgetById(e[n]).format(t)
				}
			}

			function getWidgetById(t) {
				var e = widgets.length;
				for (var i = 0; i < e; i++) {
					if (widgets[i].id.toLowerCase() == t.toLowerCase()) {
						return widgets[i]
					}
				}
			}

			function formatSortingOrder(t) {
				if (typeof t != "Number") {
					return t.toLowerCase() == "desc" ? 1 : 0
				} else {
					return t == 1 ? 1 : 0
				}
			}

			function isValueInArray(t, e) {
				var i = e.length;
				for (var n = 0; n < i; n++) {
					if (e[n][0] == t) {
						return true
					}
				}
				return false
			}

			function setHeadersCss(t, e, i, n) {
				e.removeClass(n[0]).removeClass(n[1]);
				var s = [];
				e.each(function (t) {
					if (!this.sortDisabled) {
						s[this.column] = $(this)
					}
				});
				var o = i.length;
				for (var r = 0; r < o; r++) {
					s[i[r][0]].addClass(n[i[r][1]])
				}
			}

			function fixColumnWidth(t, e) {
				var i = t.config;
				if (i.widthFixed) {
					var n = $("<colgroup>");
					$("tr:first td", t.tBodies[0]).each(function () {
						n.append($("<col>").css("width", $(this).width()))
					});
					$(t).prepend(n)
				}
			}

			function updateHeaderSortCount(t, e) {
				var i = t.config,
					n = e.length;
				for (var s = 0; s < n; s++) {
					var o = e[s],
						r = i.headerList[o[0]];
					r.count = o[1];
					r.count++
				}
			}

			function multisort(table, sortList, cache) {
				if (table.config.debug) {
					var sortTime = new Date
				}
				var dynamicExp = "var sortWrapper = function(a,b) {",
					l = sortList.length;
				for (var i = 0; i < l; i++) {
					var c = sortList[i][0];
					var order = sortList[i][1];
					var s = table.config.parsers[c].type == "text" ? order == 0 ? makeSortFunction("text", "asc", c) : makeSortFunction("text", "desc", c) : order == 0 ? makeSortFunction("numeric", "asc", c) : makeSortFunction("numeric", "desc", c);
					var e = "e" + i;
					dynamicExp += "var " + e + " = " + s;
					dynamicExp += "if(" + e + ") { return " + e + "; } ";
					dynamicExp += "else { "
				}
				var orgOrderCol = cache.normalized[0].length - 1;
				dynamicExp += "return a[" + orgOrderCol + "]-b[" + orgOrderCol + "];";
				for (var i = 0; i < l; i++) {
					dynamicExp += "}; "
				}
				dynamicExp += "return 0; ";
				dynamicExp += "}; ";
				if (table.config.debug) {
					benchmark("Evaling expression:" + dynamicExp, new Date)
				}
				eval(dynamicExp);
				cache.normalized.sort(sortWrapper);
				if (table.config.debug) {
					benchmark("Sorting on " + sortList.toString() + " and dir " + order + " time:", sortTime)
				}
				return cache
			}

			function makeSortFunction(t, e, i) {
				var n = "a[" + i + "]",
					s = "b[" + i + "]";
				if (t == "text" && e == "asc") {
					return "(" + n + " == " + s + " ? 0 : (" + n + " === null ? Number.POSITIVE_INFINITY : (" + s + " === null ? Number.NEGATIVE_INFINITY : (" + n + " < " + s + ") ? -1 : 1 )));"
				} else if (t == "text" && e == "desc") {
					return "(" + n + " == " + s + " ? 0 : (" + n + " === null ? Number.POSITIVE_INFINITY : (" + s + " === null ? Number.NEGATIVE_INFINITY : (" + s + " < " + n + ") ? -1 : 1 )));"
				} else if (t == "numeric" && e == "asc") {
					return "(" + n + " === null && " + s + " === null) ? 0 :(" + n + " === null ? Number.POSITIVE_INFINITY : (" + s + " === null ? Number.NEGATIVE_INFINITY : " + n + " - " + s + "));"
				} else if (t == "numeric" && e == "desc") {
					return "(" + n + " === null && " + s + " === null) ? 0 :(" + n + " === null ? Number.POSITIVE_INFINITY : (" + s + " === null ? Number.NEGATIVE_INFINITY : " + s + " - " + n + "));"
				}
			}

			function makeSortText(t) {
				return "((a[" + t + "] < b[" + t + "]) ? -1 : ((a[" + t + "] > b[" + t + "]) ? 1 : 0));"
			}

			function makeSortTextDesc(t) {
				return "((b[" + t + "] < a[" + t + "]) ? -1 : ((b[" + t + "] > a[" + t + "]) ? 1 : 0));"
			}

			function makeSortNumeric(t) {
				return "a[" + t + "]-b[" + t + "];"
			}

			function makeSortNumericDesc(t) {
				return "b[" + t + "]-a[" + t + "];"
			}

			function sortText(t, e) {
				if (table.config.sortLocaleCompare) return t.localeCompare(e);
				return t < e ? -1 : t > e ? 1 : 0
			}

			function sortTextDesc(t, e) {
				if (table.config.sortLocaleCompare) return e.localeCompare(t);
				return e < t ? -1 : e > t ? 1 : 0
			}

			function sortNumeric(t, e) {
				return t - e
			}

			function sortNumericDesc(t, e) {
				return e - t
			}

			function getCachedSortType(t, e) {
				return t[e].type
			}
			this.construct = function (n) {
				return this.each(function () {
					if (!this.tHead || !this.tBodies) return;
					var l, t, h, c, u, e = 0,
						i;
					this.config = {};
					u = $.extend(this.config, $.tablesorter.defaults, n);
					l = $(this);
					$.data(this, "tablesorter", u);
					h = buildHeaders(this);
					this.config.parsers = buildParserCache(this, h);
					c = buildCache(this);
					var d = [u.cssDesc, u.cssAsc];
					fixColumnWidth(this);
					h.click(function (t) {
						var e = l[0].tBodies[0] && l[0].tBodies[0].rows.length || 0;
						if (!this.sortDisabled && e > 0) {
							l.trigger("sortStart");
							var i = $(this);
							var n = this.column;
							this.order = this.count++ % 2;
							if (this.lockedOrder) this.order = this.lockedOrder;
							if (!t[u.sortMultiSortKey]) {
								u.sortList = [];
								if (u.sortForce != null) {
									var s = u.sortForce;
									for (var o = 0; o < s.length; o++) {
										if (s[o][0] != n) {
											u.sortList.push(s[o])
										}
									}
								}
								u.sortList.push([n, this.order])
							} else {
								if (isValueInArray(n, u.sortList)) {
									for (var o = 0; o < u.sortList.length; o++) {
										var r = u.sortList[o],
											a = u.headerList[r[0]];
										if (r[0] == n) {
											a.count = r[1];
											a.count++;
											r[1] = a.count % 2
										}
									}
								} else {
									u.sortList.push([n, this.order])
								}
							}
							setTimeout(function () {
								setHeadersCss(l[0], h, u.sortList, d);
								appendToTable(l[0], multisort(l[0], u.sortList, c))
							}, 1);
							return false
						}
					}).mousedown(function () {
						if (u.cancelSelection) {
							this.onselectstart = function () {
								return false
							};
							return false
						}
					});
					l.bind("update", function () {
						var t = this;
						setTimeout(function () {
							t.config.parsers = buildParserCache(t, h);
							c = buildCache(t)
						}, 1)
					}).bind("updateCell", function (t, e) {
						var i = this.config;
						var n = [e.parentNode.rowIndex - 1, e.cellIndex];
						c.normalized[n[0]][n[1]] = i.parsers[n[1]].format(getElementText(i, e), e)
					}).bind("sorton", function (t, e) {
						$(this).trigger("sortStart");
						u.sortList = e;
						var i = u.sortList;
						updateHeaderSortCount(this, i);
						setHeadersCss(this, h, i, d);
						appendToTable(this, multisort(this, i, c))
					}).bind("appendCache", function () {
						appendToTable(this, c)
					}).bind("applyWidgetId", function (t, e) {
						getWidgetById(e).format(this)
					}).bind("applyWidgets", function () {
						applyWidget(this)
					});
					if ($.metadata && ($(this).metadata() && $(this).metadata().sortlist)) {
						u.sortList = $(this).metadata().sortlist
					}
					if (u.sortList.length > 0) {
						l.trigger("sorton", [u.sortList])
					}
					applyWidget(this)
				})
			};
			this.addParser = function (t) {
				var e = parsers.length,
					i = true;
				for (var n = 0; n < e; n++) {
					if (parsers[n].id.toLowerCase() == t.id.toLowerCase()) {
						i = false
					}
				}
				if (i) {
					parsers.push(t)
				}
			};
			this.addWidget = function (t) {
				widgets.push(t)
			};
			this.formatFloat = function (t) {
				var e = parseFloat(t);
				return isNaN(e) ? 0 : e
			};
			this.formatInt = function (t) {
				var e = parseInt(t);
				return isNaN(e) ? 0 : e
			};
			this.isDigit = function (t, e) {
				return /^[-+]?\d*$/.test($.trim(t.replace(/[,.']/g, "")))
			};
			this.clearTableBody = function (t) {
				if ($.browser.msie) {
					function e() {
						while (this.firstChild) this.removeChild(this.firstChild)
					}
					e.apply(t.tBodies[0])
				} else {
					t.tBodies[0].innerHTML = ""
				}
			}
		}
	});
	$.fn.extend({
		tablesorter: $.tablesorter.construct
	});
	var ts = $.tablesorter;
	ts.addParser({
		id: "text",
		is: function (t) {
			return true
		},
		format: function (t) {
			return $.trim(t.toLocaleLowerCase())
		},
		type: "text"
	});
	ts.addParser({
		id: "digit",
		is: function (t, e) {
			var i = e.config;
			return $.tablesorter.isDigit(t, i)
		},
		format: function (t) {
			return $.tablesorter.formatFloat(t)
		},
		type: "numeric"
	});
	ts.addParser({
		id: "currency",
		is: function (t) {
			return /^[£$€?.]/.test(t)
		},
		format: function (t) {
			return $.tablesorter.formatFloat(t.replace(new RegExp(/[£$€]/g), ""))
		},
		type: "numeric"
	});
	ts.addParser({
		id: "ipAddress",
		is: function (t) {
			return /^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(t)
		},
		format: function (t) {
			var e = t.split("."),
				i = "",
				n = e.length;
			for (var s = 0; s < n; s++) {
				var o = e[s];
				if (o.length == 2) {
					i += "0" + o
				} else {
					i += o
				}
			}
			return $.tablesorter.formatFloat(i)
		},
		type: "numeric"
	});
	ts.addParser({
		id: "url",
		is: function (t) {
			return /^(https?|ftp|file):\/\/$/.test(t)
		},
		format: function (t) {
			return jQuery.trim(t.replace(new RegExp(/(https?|ftp|file):\/\//), ""))
		},
		type: "text"
	});
	ts.addParser({
		id: "isoDate",
		is: function (t) {
			return /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(t)
		},
		format: function (t) {
			return $.tablesorter.formatFloat(t != "" ? new Date(t.replace(new RegExp(/-/g), "/")).getTime() : "0")
		},
		type: "numeric"
	});
	ts.addParser({
		id: "percent",
		is: function (t) {
			return /\%$/.test($.trim(t))
		},
		format: function (t) {
			return $.tablesorter.formatFloat(t.replace(new RegExp(/%/g), ""))
		},
		type: "numeric"
	});
	ts.addParser({
		id: "usLongDate",
		is: function (t) {
			return t.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/))
		},
		format: function (t) {
			return $.tablesorter.formatFloat(new Date(t).getTime())
		},
		type: "numeric"
	});
	ts.addParser({
		id: "shortDate",
		is: function (t) {
			return /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(t)
		},
		format: function (t, e) {
			var i = e.config;
			t = t.replace(/\-/g, "/");
			if (i.dateFormat == "us") {
				t = t.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$1/$2")
			} else if (i.dateFormat == "pt") {
				t = t.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$2/$1")
			} else if (i.dateFormat == "uk") {
				t = t.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$2/$1")
			} else if (i.dateFormat == "dd/mm/yy" || i.dateFormat == "dd-mm-yy") {
				t = t.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/, "$1/$2/$3")
			}
			return $.tablesorter.formatFloat(new Date(t).getTime())
		},
		type: "numeric"
	});
	ts.addParser({
		id: "time",
		is: function (t) {
			return /^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(t)
		},
		format: function (t) {
			return $.tablesorter.formatFloat(new Date("2000/01/01 " + t).getTime())
		},
		type: "numeric"
	});
	ts.addParser({
		id: "metadata",
		is: function (t) {
			return false
		},
		format: function (t, e, i) {
			var n = e.config,
				s = !n.parserMetadataName ? "sortValue" : n.parserMetadataName;
			return $(i).metadata()[s]
		},
		type: "numeric"
	});
	ts.addWidget({
		id: "zebra",
		format: function (e) {
			if (e.config.debug) {
				var t = new Date
			}
			var i, n = -1,
				s;
			$("tr:visible", e.tBodies[0]).each(function (t) {
				i = $(this);
				if (!i.hasClass(e.config.cssChildRow)) n++;
				s = n % 2 == 0;
				i.removeClass(e.config.widgetZebra.css[s ? 0 : 1]).addClass(e.config.widgetZebra.css[s ? 1 : 0])
			});
			if (e.config.debug) {
				$.tablesorter.benchmark("Applying Zebra widget", t)
			}
		}
	})
})(jQuery);
(function (t, e) {
	typeof exports === "object" && typeof module !== "undefined" ? module.exports = e() : typeof define === "function" && define.amd ? define(e) : t.moment = e()
})(this, function () {
	"use strict";
	var R;

	function h() {
		return R.apply(null, arguments)
	}

	function F(t) {
		R = t
	}

	function r(t) {
		return t instanceof Array || Object.prototype.toString.call(t) === "[object Array]"
	}

	function H(t) {
		return t != null && Object.prototype.toString.call(t) === "[object Object]"
	}

	function z(t) {
		var e;
		for (e in t) {
			return false
		}
		return true
	}

	function o(t) {
		return t === void 0
	}

	function W(t) {
		return typeof t === "number" || Object.prototype.toString.call(t) === "[object Number]"
	}

	function B(t) {
		return t instanceof Date || Object.prototype.toString.call(t) === "[object Date]"
	}

	function j(t, e) {
		var i = [],
			n;
		for (n = 0; n < t.length; ++n) {
			i.push(e(t[n], n))
		}
		return i
	}

	function a(t, e) {
		return Object.prototype.hasOwnProperty.call(t, e)
	}

	function l(t, e) {
		for (var i in e) {
			if (a(e, i)) {
				t[i] = e[i]
			}
		}
		if (a(e, "toString")) {
			t.toString = e.toString
		}
		if (a(e, "valueOf")) {
			t.valueOf = e.valueOf
		}
		return t
	}

	function c(t, e, i, n) {
		return qi(t, e, i, n, true).utc()
	}

	function Y() {
		return {
			empty: false,
			unusedTokens: [],
			unusedInput: [],
			overflow: -2,
			charsLeftOver: 0,
			nullInput: false,
			invalidMonth: null,
			invalidFormat: false,
			userInvalidated: false,
			iso: false,
			parsedDateParts: [],
			meridiem: null,
			rfc2822: false,
			weekdayMismatch: false
		}
	}

	function f(t) {
		if (t._pf == null) {
			t._pf = Y()
		}
		return t._pf
	}
	var V;
	if (Array.prototype.some) {
		V = Array.prototype.some
	} else {
		V = function (t) {
			var e = Object(this);
			var i = e.length >>> 0;
			for (var n = 0; n < i; n++) {
				if (n in e && t.call(this, e[n], n, e)) {
					return true
				}
			}
			return false
		}
	}
	var $ = V;

	function U(t) {
		if (t._isValid == null) {
			var e = f(t);
			var i = $.call(e.parsedDateParts, function (t) {
				return t != null
			});
			var n = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && i);
			if (t._strict) {
				n = n && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && e.bigHour === undefined
			}
			if (Object.isFrozen == null || !Object.isFrozen(t)) {
				t._isValid = n
			} else {
				return n
			}
		}
		return t._isValid
	}

	function q(t) {
		var e = c(NaN);
		if (t != null) {
			l(f(e), t)
		} else {
			f(e).userInvalidated = true
		}
		return e
	}
	var G = h.momentProperties = [];

	function K(t, e) {
		var i, n, s;
		if (!o(e._isAMomentObject)) {
			t._isAMomentObject = e._isAMomentObject
		}
		if (!o(e._i)) {
			t._i = e._i
		}
		if (!o(e._f)) {
			t._f = e._f
		}
		if (!o(e._l)) {
			t._l = e._l
		}
		if (!o(e._strict)) {
			t._strict = e._strict
		}
		if (!o(e._tzm)) {
			t._tzm = e._tzm
		}
		if (!o(e._isUTC)) {
			t._isUTC = e._isUTC
		}
		if (!o(e._offset)) {
			t._offset = e._offset
		}
		if (!o(e._pf)) {
			t._pf = f(e)
		}
		if (!o(e._locale)) {
			t._locale = e._locale
		}
		if (G.length > 0) {
			for (i = 0; i < G.length; i++) {
				n = G[i];
				s = e[n];
				if (!o(s)) {
					t[n] = s
				}
			}
		}
		return t
	}
	var X = false;

	function Z(t) {
		K(this, t);
		this._d = new Date(t._d != null ? t._d.getTime() : NaN);
		if (!this.isValid()) {
			this._d = new Date(NaN)
		}
		if (X === false) {
			X = true;
			h.updateOffset(this);
			X = false
		}
	}

	function s(t) {
		return t instanceof Z || t != null && t._isAMomentObject != null
	}

	function p(t) {
		if (t < 0) {
			return Math.ceil(t) || 0
		} else {
			return Math.floor(t)
		}
	}

	function u(t) {
		var e = +t,
			i = 0;
		if (e !== 0 && isFinite(e)) {
			i = p(e)
		}
		return i
	}

	function Q(t, e, i) {
		var n = Math.min(t.length, e.length),
			s = Math.abs(t.length - e.length),
			o = 0,
			r;
		for (r = 0; r < n; r++) {
			if (i && t[r] !== e[r] || !i && u(t[r]) !== u(e[r])) {
				o++
			}
		}
		return o + s
	}

	function J(t) {
		if (h.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
			console.warn("Deprecation warning: " + t)
		}
	}

	function t(s, o) {
		var r = true;
		return l(function () {
			if (h.deprecationHandler != null) {
				h.deprecationHandler(null, s)
			}
			if (r) {
				var t = [];
				var e;
				for (var i = 0; i < arguments.length; i++) {
					e = "";
					if (typeof arguments[i] === "object") {
						e += "\n[" + i + "] ";
						for (var n in arguments[0]) {
							e += n + ": " + arguments[0][n] + ", "
						}
						e = e.slice(0, -2)
					} else {
						e = arguments[i]
					}
					t.push(e)
				}
				J(s + "\nArguments: " + Array.prototype.slice.call(t).join("") + "\n" + (new Error).stack);
				r = false
			}
			return o.apply(this, arguments)
		}, o)
	}
	var tt = {};

	function et(t, e) {
		if (h.deprecationHandler != null) {
			h.deprecationHandler(t, e)
		}
		if (!tt[t]) {
			J(e);
			tt[t] = true
		}
	}
	h.suppressDeprecationWarnings = false;
	h.deprecationHandler = null;

	function d(t) {
		return t instanceof Function || Object.prototype.toString.call(t) === "[object Function]"
	}

	function it(t) {
		var e, i;
		for (i in t) {
			e = t[i];
			if (d(e)) {
				this[i] = e
			} else {
				this["_" + i] = e
			}
		}
		this._config = t;
		this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
	}

	function nt(t, e) {
		var i = l({}, t),
			n;
		for (n in e) {
			if (a(e, n)) {
				if (H(t[n]) && H(e[n])) {
					i[n] = {};
					l(i[n], t[n]);
					l(i[n], e[n])
				} else if (e[n] != null) {
					i[n] = e[n]
				} else {
					delete i[n]
				}
			}
		}
		for (n in t) {
			if (a(t, n) && !a(e, n) && H(t[n])) {
				i[n] = l({}, i[n])
			}
		}
		return i
	}

	function st(t) {
		if (t != null) {
			this.set(t)
		}
	}
	var ot;
	if (Object.keys) {
		ot = Object.keys
	} else {
		ot = function (t) {
			var e, i = [];
			for (e in t) {
				if (a(t, e)) {
					i.push(e)
				}
			}
			return i
		}
	}
	var rt = ot;
	var at = {
		sameDay: "[Today at] LT",
		nextDay: "[Tomorrow at] LT",
		nextWeek: "dddd [at] LT",
		lastDay: "[Yesterday at] LT",
		lastWeek: "[Last] dddd [at] LT",
		sameElse: "L"
	};

	function lt(t, e, i) {
		var n = this._calendar[t] || this._calendar["sameElse"];
		return d(n) ? n.call(e, i) : n
	}
	var ht = {
		LTS: "h:mm:ss A",
		LT: "h:mm A",
		L: "MM/DD/YYYY",
		LL: "MMMM D, YYYY",
		LLL: "MMMM D, YYYY h:mm A",
		LLLL: "dddd, MMMM D, YYYY h:mm A"
	};

	function ct(t) {
		var e = this._longDateFormat[t],
			i = this._longDateFormat[t.toUpperCase()];
		if (e || !i) {
			return e
		}
		this._longDateFormat[t] = i.replace(/MMMM|MM|DD|dddd/g, function (t) {
			return t.slice(1)
		});
		return this._longDateFormat[t]
	}
	var ut = "Invalid date";

	function dt() {
		return this._invalidDate
	}
	var ft = "%d";
	var pt = /\d{1,2}/;

	function gt(t) {
		return this._ordinal.replace("%d", t)
	}
	var mt = {
		future: "in %s",
		past: "%s ago",
		s: "a few seconds",
		ss: "%d seconds",
		m: "a minute",
		mm: "%d minutes",
		h: "an hour",
		hh: "%d hours",
		d: "a day",
		dd: "%d days",
		M: "a month",
		MM: "%d months",
		y: "a year",
		yy: "%d years"
	};

	function vt(t, e, i, n) {
		var s = this._relativeTime[i];
		return d(s) ? s(t, e, i, n) : s.replace(/%d/i, t)
	}

	function bt(t, e) {
		var i = this._relativeTime[t > 0 ? "future" : "past"];
		return d(i) ? i(e) : i.replace(/%s/i, e)
	}
	var _t = {};

	function e(t, e) {
		var i = t.toLowerCase();
		_t[i] = _t[i + "s"] = _t[e] = t
	}

	function g(t) {
		return typeof t === "string" ? _t[t] || _t[t.toLowerCase()] : undefined
	}

	function yt(t) {
		var e = {},
			i, n;
		for (n in t) {
			if (a(t, n)) {
				i = g(n);
				if (i) {
					e[i] = t[n]
				}
			}
		}
		return e
	}
	var xt = {};

	function i(t, e) {
		xt[t] = e
	}

	function wt(t) {
		var e = [];
		for (var i in t) {
			e.push({
				unit: i,
				priority: xt[i]
			})
		}
		e.sort(function (t, e) {
			return t.priority - e.priority
		});
		return e
	}

	function kt(e, i) {
		return function (t) {
			if (t != null) {
				Dt(this, e, t);
				h.updateOffset(this, i);
				return this
			} else {
				return Ct(this, e)
			}
		}
	}

	function Ct(t, e) {
		return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN
	}

	function Dt(t, e, i) {
		if (t.isValid()) {
			t._d["set" + (t._isUTC ? "UTC" : "") + e](i)
		}
	}

	function Mt(t) {
		t = g(t);
		if (d(this[t])) {
			return this[t]()
		}
		return this
	}

	function Tt(t, e) {
		if (typeof t === "object") {
			t = yt(t);
			var i = wt(t);
			for (var n = 0; n < i.length; n++) {
				this[i[n].unit](t[i[n].unit])
			}
		} else {
			t = g(t);
			if (d(this[t])) {
				return this[t](e)
			}
		}
		return this
	}

	function m(t, e, i) {
		var n = "" + Math.abs(t),
			s = e - n.length,
			o = t >= 0;
		return (o ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, s)).toString().substr(1) + n
	}
	var St = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	var Pt = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	var It = {};
	var Et = {};

	function n(t, e, i, n) {
		var s = n;
		if (typeof n === "string") {
			s = function () {
				return this[n]()
			}
		}
		if (t) {
			Et[t] = s
		}
		if (e) {
			Et[e[0]] = function () {
				return m(s.apply(this, arguments), e[1], e[2])
			}
		}
		if (i) {
			Et[i] = function () {
				return this.localeData().ordinal(s.apply(this, arguments), t)
			}
		}
	}

	function Ot(t) {
		if (t.match(/\[[\s\S]/)) {
			return t.replace(/^\[|\]$/g, "")
		}
		return t.replace(/\\/g, "")
	}

	function At(n) {
		var s = n.match(St),
			t, o;
		for (t = 0, o = s.length; t < o; t++) {
			if (Et[s[t]]) {
				s[t] = Et[s[t]]
			} else {
				s[t] = Ot(s[t])
			}
		}
		return function (t) {
			var e = "",
				i;
			for (i = 0; i < o; i++) {
				e += d(s[i]) ? s[i].call(t, n) : s[i]
			}
			return e
		}
	}

	function Lt(t, e) {
		if (!t.isValid()) {
			return t.localeData().invalidDate()
		}
		e = Nt(e, t.localeData());
		It[e] = It[e] || At(e);
		return It[e](t)
	}

	function Nt(t, e) {
		var i = 5;

		function n(t) {
			return e.longDateFormat(t) || t
		}
		Pt.lastIndex = 0;
		while (i >= 0 && Pt.test(t)) {
			t = t.replace(Pt, n);
			Pt.lastIndex = 0;
			i -= 1
		}
		return t
	}
	var Rt = /\d/;
	var v = /\d\d/;
	var Ft = /\d{3}/;
	var Ht = /\d{4}/;
	var zt = /[+-]?\d{6}/;
	var b = /\d\d?/;
	var Wt = /\d\d\d\d?/;
	var Bt = /\d\d\d\d\d\d?/;
	var jt = /\d{1,3}/;
	var Yt = /\d{1,4}/;
	var Vt = /[+-]?\d{1,6}/;
	var $t = /\d+/;
	var Ut = /[+-]?\d+/;
	var qt = /Z|[+-]\d\d:?\d\d/gi;
	var Gt = /Z|[+-]\d\d(?::?\d\d)?/gi;
	var Kt = /[+-]?\d+(\.\d{1,3})?/;
	var Xt = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
	var Zt = {};

	function _(t, i, n) {
		Zt[t] = d(i) ? i : function (t, e) {
			return t && n ? n : i
		}
	}

	function Qt(t, e) {
		if (!a(Zt, t)) {
			return new RegExp(Jt(t))
		}
		return Zt[t](e._strict, e._locale)
	}

	function Jt(t) {
		return te(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, e, i, n, s) {
			return e || i || n || s
		}))
	}

	function te(t) {
		return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
	}
	var ee = {};

	function y(t, i) {
		var e, n = i;
		if (typeof t === "string") {
			t = [t]
		}
		if (W(i)) {
			n = function (t, e) {
				e[i] = u(t)
			}
		}
		for (e = 0; e < t.length; e++) {
			ee[t[e]] = n
		}
	}

	function ie(t, s) {
		y(t, function (t, e, i, n) {
			i._w = i._w || {};
			s(t, i._w, i, n)
		})
	}

	function ne(t, e, i) {
		if (e != null && a(ee, t)) {
			ee[t](e, i._a, i, t)
		}
	}
	var x = 0;
	var w = 1;
	var k = 2;
	var C = 3;
	var D = 4;
	var M = 5;
	var se = 6;
	var oe = 7;
	var re = 8;
	var ae;
	if (Array.prototype.indexOf) {
		ae = Array.prototype.indexOf
	} else {
		ae = function (t) {
			var e;
			for (e = 0; e < this.length; ++e) {
				if (this[e] === t) {
					return e
				}
			}
			return -1
		}
	}
	var T = ae;

	function le(t, e) {
		return new Date(Date.UTC(t, e + 1, 0)).getUTCDate()
	}
	n("M", ["MM", 2], "Mo", function () {
		return this.month() + 1
	});
	n("MMM", 0, 0, function (t) {
		return this.localeData().monthsShort(this, t)
	});
	n("MMMM", 0, 0, function (t) {
		return this.localeData().months(this, t)
	});
	e("month", "M");
	i("month", 8);
	_("M", b);
	_("MM", b, v);
	_("MMM", function (t, e) {
		return e.monthsShortRegex(t)
	});
	_("MMMM", function (t, e) {
		return e.monthsRegex(t)
	});
	y(["M", "MM"], function (t, e) {
		e[w] = u(t) - 1
	});
	y(["MMM", "MMMM"], function (t, e, i, n) {
		var s = i._locale.monthsParse(t, n, i._strict);
		if (s != null) {
			e[w] = s
		} else {
			f(i).invalidMonth = t
		}
	});
	var he = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var ce = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");

	function ue(t, e) {
		if (!t) {
			return r(this._months) ? this._months : this._months["standalone"]
		}
		return r(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || he).test(e) ? "format" : "standalone"][t.month()]
	}
	var de = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

	function fe(t, e) {
		if (!t) {
			return r(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"]
		}
		return r(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[he.test(e) ? "format" : "standalone"][t.month()]
	}

	function pe(t, e, i) {
		var n, s, o, r = t.toLocaleLowerCase();
		if (!this._monthsParse) {
			this._monthsParse = [];
			this._longMonthsParse = [];
			this._shortMonthsParse = [];
			for (n = 0; n < 12; ++n) {
				o = c([2e3, n]);
				this._shortMonthsParse[n] = this.monthsShort(o, "").toLocaleLowerCase();
				this._longMonthsParse[n] = this.months(o, "").toLocaleLowerCase()
			}
		}
		if (i) {
			if (e === "MMM") {
				s = T.call(this._shortMonthsParse, r);
				return s !== -1 ? s : null
			} else {
				s = T.call(this._longMonthsParse, r);
				return s !== -1 ? s : null
			}
		} else {
			if (e === "MMM") {
				s = T.call(this._shortMonthsParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._longMonthsParse, r);
				return s !== -1 ? s : null
			} else {
				s = T.call(this._longMonthsParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._shortMonthsParse, r);
				return s !== -1 ? s : null
			}
		}
	}

	function ge(t, e, i) {
		var n, s, o;
		if (this._monthsParseExact) {
			return pe.call(this, t, e, i)
		}
		if (!this._monthsParse) {
			this._monthsParse = [];
			this._longMonthsParse = [];
			this._shortMonthsParse = []
		}
		for (n = 0; n < 12; n++) {
			s = c([2e3, n]);
			if (i && !this._longMonthsParse[n]) {
				this._longMonthsParse[n] = new RegExp("^" + this.months(s, "").replace(".", "") + "$", "i");
				this._shortMonthsParse[n] = new RegExp("^" + this.monthsShort(s, "").replace(".", "") + "$", "i")
			}
			if (!i && !this._monthsParse[n]) {
				o = "^" + this.months(s, "") + "|^" + this.monthsShort(s, "");
				this._monthsParse[n] = new RegExp(o.replace(".", ""), "i")
			}
			if (i && e === "MMMM" && this._longMonthsParse[n].test(t)) {
				return n
			} else if (i && e === "MMM" && this._shortMonthsParse[n].test(t)) {
				return n
			} else if (!i && this._monthsParse[n].test(t)) {
				return n
			}
		}
	}

	function me(t, e) {
		var i;
		if (!t.isValid()) {
			return t
		}
		if (typeof e === "string") {
			if (/^\d+$/.test(e)) {
				e = u(e)
			} else {
				e = t.localeData().monthsParse(e);
				if (!W(e)) {
					return t
				}
			}
		}
		i = Math.min(t.date(), le(t.year(), e));
		t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, i);
		return t
	}

	function ve(t) {
		if (t != null) {
			me(this, t);
			h.updateOffset(this, true);
			return this
		} else {
			return Ct(this, "Month")
		}
	}

	function be() {
		return le(this.year(), this.month())
	}
	var _e = Xt;

	function ye(t) {
		if (this._monthsParseExact) {
			if (!a(this, "_monthsRegex")) {
				ke.call(this)
			}
			if (t) {
				return this._monthsShortStrictRegex
			} else {
				return this._monthsShortRegex
			}
		} else {
			if (!a(this, "_monthsShortRegex")) {
				this._monthsShortRegex = _e
			}
			return this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex
		}
	}
	var xe = Xt;

	function we(t) {
		if (this._monthsParseExact) {
			if (!a(this, "_monthsRegex")) {
				ke.call(this)
			}
			if (t) {
				return this._monthsStrictRegex
			} else {
				return this._monthsRegex
			}
		} else {
			if (!a(this, "_monthsRegex")) {
				this._monthsRegex = xe
			}
			return this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex
		}
	}

	function ke() {
		function t(t, e) {
			return e.length - t.length
		}
		var e = [],
			i = [],
			n = [],
			s, o;
		for (s = 0; s < 12; s++) {
			o = c([2e3, s]);
			e.push(this.monthsShort(o, ""));
			i.push(this.months(o, ""));
			n.push(this.months(o, ""));
			n.push(this.monthsShort(o, ""))
		}
		e.sort(t);
		i.sort(t);
		n.sort(t);
		for (s = 0; s < 12; s++) {
			e[s] = te(e[s]);
			i[s] = te(i[s])
		}
		for (s = 0; s < 24; s++) {
			n[s] = te(n[s])
		}
		this._monthsRegex = new RegExp("^(" + n.join("|") + ")", "i");
		this._monthsShortRegex = this._monthsRegex;
		this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i");
		this._monthsShortStrictRegex = new RegExp("^(" + e.join("|") + ")", "i")
	}
	n("Y", 0, 0, function () {
		var t = this.year();
		return t <= 9999 ? "" + t : "+" + t
	});
	n(0, ["YY", 2], 0, function () {
		return this.year() % 100
	});
	n(0, ["YYYY", 4], 0, "year");
	n(0, ["YYYYY", 5], 0, "year");
	n(0, ["YYYYYY", 6, true], 0, "year");
	e("year", "y");
	i("year", 1);
	_("Y", Ut);
	_("YY", b, v);
	_("YYYY", Yt, Ht);
	_("YYYYY", Vt, zt);
	_("YYYYYY", Vt, zt);
	y(["YYYYY", "YYYYYY"], x);
	y("YYYY", function (t, e) {
		e[x] = t.length === 2 ? h.parseTwoDigitYear(t) : u(t)
	});
	y("YY", function (t, e) {
		e[x] = h.parseTwoDigitYear(t)
	});
	y("Y", function (t, e) {
		e[x] = parseInt(t, 10)
	});

	function Ce(t) {
		return De(t) ? 366 : 365
	}

	function De(t) {
		return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0
	}
	h.parseTwoDigitYear = function (t) {
		return u(t) + (u(t) > 68 ? 1900 : 2e3)
	};
	var Me = kt("FullYear", true);

	function Te() {
		return De(this.year())
	}

	function Se(t, e, i, n, s, o, r) {
		var a = new Date(t, e, i, n, s, o, r);
		if (t < 100 && t >= 0 && isFinite(a.getFullYear())) {
			a.setFullYear(t)
		}
		return a
	}

	function Pe(t) {
		var e = new Date(Date.UTC.apply(null, arguments));
		if (t < 100 && t >= 0 && isFinite(e.getUTCFullYear())) {
			e.setUTCFullYear(t)
		}
		return e
	}

	function Ie(t, e, i) {
		var n = 7 + e - i,
			s = (7 + Pe(t, 0, n).getUTCDay() - e) % 7;
		return -s + n - 1
	}

	function Ee(t, e, i, n, s) {
		var o = (7 + i - n) % 7,
			r = Ie(t, n, s),
			a = 1 + 7 * (e - 1) + o + r,
			l, h;
		if (a <= 0) {
			l = t - 1;
			h = Ce(l) + a
		} else if (a > Ce(t)) {
			l = t + 1;
			h = a - Ce(t)
		} else {
			l = t;
			h = a
		}
		return {
			year: l,
			dayOfYear: h
		}
	}

	function Oe(t, e, i) {
		var n = Ie(t.year(), e, i),
			s = Math.floor((t.dayOfYear() - n - 1) / 7) + 1,
			o, r;
		if (s < 1) {
			r = t.year() - 1;
			o = s + Ae(r, e, i)
		} else if (s > Ae(t.year(), e, i)) {
			o = s - Ae(t.year(), e, i);
			r = t.year() + 1
		} else {
			r = t.year();
			o = s
		}
		return {
			week: o,
			year: r
		}
	}

	function Ae(t, e, i) {
		var n = Ie(t, e, i),
			s = Ie(t + 1, e, i);
		return (Ce(t) - n + s) / 7
	}
	n("w", ["ww", 2], "wo", "week");
	n("W", ["WW", 2], "Wo", "isoWeek");
	e("week", "w");
	e("isoWeek", "W");
	i("week", 5);
	i("isoWeek", 5);
	_("w", b);
	_("ww", b, v);
	_("W", b);
	_("WW", b, v);
	ie(["w", "ww", "W", "WW"], function (t, e, i, n) {
		e[n.substr(0, 1)] = u(t)
	});

	function Le(t) {
		return Oe(t, this._week.dow, this._week.doy).week
	}
	var Ne = {
		dow: 0,
		doy: 6
	};

	function Re() {
		return this._week.dow
	}

	function Fe() {
		return this._week.doy
	}

	function He(t) {
		var e = this.localeData().week(this);
		return t == null ? e : this.add((t - e) * 7, "d")
	}

	function ze(t) {
		var e = Oe(this, 1, 4).week;
		return t == null ? e : this.add((t - e) * 7, "d")
	}
	n("d", 0, "do", "day");
	n("dd", 0, 0, function (t) {
		return this.localeData().weekdaysMin(this, t)
	});
	n("ddd", 0, 0, function (t) {
		return this.localeData().weekdaysShort(this, t)
	});
	n("dddd", 0, 0, function (t) {
		return this.localeData().weekdays(this, t)
	});
	n("e", 0, 0, "weekday");
	n("E", 0, 0, "isoWeekday");
	e("day", "d");
	e("weekday", "e");
	e("isoWeekday", "E");
	i("day", 11);
	i("weekday", 11);
	i("isoWeekday", 11);
	_("d", b);
	_("e", b);
	_("E", b);
	_("dd", function (t, e) {
		return e.weekdaysMinRegex(t)
	});
	_("ddd", function (t, e) {
		return e.weekdaysShortRegex(t)
	});
	_("dddd", function (t, e) {
		return e.weekdaysRegex(t)
	});
	ie(["dd", "ddd", "dddd"], function (t, e, i, n) {
		var s = i._locale.weekdaysParse(t, n, i._strict);
		if (s != null) {
			e.d = s
		} else {
			f(i).invalidWeekday = t
		}
	});
	ie(["d", "e", "E"], function (t, e, i, n) {
		e[n] = u(t)
	});

	function We(t, e) {
		if (typeof t !== "string") {
			return t
		}
		if (!isNaN(t)) {
			return parseInt(t, 10)
		}
		t = e.weekdaysParse(t);
		if (typeof t === "number") {
			return t
		}
		return null
	}

	function Be(t, e) {
		if (typeof t === "string") {
			return e.weekdaysParse(t) % 7 || 7
		}
		return isNaN(t) ? null : t
	}
	var je = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");

	function Ye(t, e) {
		if (!t) {
			return r(this._weekdays) ? this._weekdays : this._weekdays["standalone"]
		}
		return r(this._weekdays) ? this._weekdays[t.day()] : this._weekdays[this._weekdays.isFormat.test(e) ? "format" : "standalone"][t.day()]
	}
	var Ve = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");

	function $e(t) {
		return t ? this._weekdaysShort[t.day()] : this._weekdaysShort
	}
	var Ue = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");

	function qe(t) {
		return t ? this._weekdaysMin[t.day()] : this._weekdaysMin
	}

	function Ge(t, e, i) {
		var n, s, o, r = t.toLocaleLowerCase();
		if (!this._weekdaysParse) {
			this._weekdaysParse = [];
			this._shortWeekdaysParse = [];
			this._minWeekdaysParse = [];
			for (n = 0; n < 7; ++n) {
				o = c([2e3, 1]).day(n);
				this._minWeekdaysParse[n] = this.weekdaysMin(o, "").toLocaleLowerCase();
				this._shortWeekdaysParse[n] = this.weekdaysShort(o, "").toLocaleLowerCase();
				this._weekdaysParse[n] = this.weekdays(o, "").toLocaleLowerCase()
			}
		}
		if (i) {
			if (e === "dddd") {
				s = T.call(this._weekdaysParse, r);
				return s !== -1 ? s : null
			} else if (e === "ddd") {
				s = T.call(this._shortWeekdaysParse, r);
				return s !== -1 ? s : null
			} else {
				s = T.call(this._minWeekdaysParse, r);
				return s !== -1 ? s : null
			}
		} else {
			if (e === "dddd") {
				s = T.call(this._weekdaysParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._shortWeekdaysParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._minWeekdaysParse, r);
				return s !== -1 ? s : null
			} else if (e === "ddd") {
				s = T.call(this._shortWeekdaysParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._weekdaysParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._minWeekdaysParse, r);
				return s !== -1 ? s : null
			} else {
				s = T.call(this._minWeekdaysParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._weekdaysParse, r);
				if (s !== -1) {
					return s
				}
				s = T.call(this._shortWeekdaysParse, r);
				return s !== -1 ? s : null
			}
		}
	}

	function Ke(t, e, i) {
		var n, s, o;
		if (this._weekdaysParseExact) {
			return Ge.call(this, t, e, i)
		}
		if (!this._weekdaysParse) {
			this._weekdaysParse = [];
			this._minWeekdaysParse = [];
			this._shortWeekdaysParse = [];
			this._fullWeekdaysParse = []
		}
		for (n = 0; n < 7; n++) {
			s = c([2e3, 1]).day(n);
			if (i && !this._fullWeekdaysParse[n]) {
				this._fullWeekdaysParse[n] = new RegExp("^" + this.weekdays(s, "").replace(".", ".?") + "$", "i");
				this._shortWeekdaysParse[n] = new RegExp("^" + this.weekdaysShort(s, "").replace(".", ".?") + "$", "i");
				this._minWeekdaysParse[n] = new RegExp("^" + this.weekdaysMin(s, "").replace(".", ".?") + "$", "i")
			}
			if (!this._weekdaysParse[n]) {
				o = "^" + this.weekdays(s, "") + "|^" + this.weekdaysShort(s, "") + "|^" + this.weekdaysMin(s, "");
				this._weekdaysParse[n] = new RegExp(o.replace(".", ""), "i")
			}
			if (i && e === "dddd" && this._fullWeekdaysParse[n].test(t)) {
				return n
			} else if (i && e === "ddd" && this._shortWeekdaysParse[n].test(t)) {
				return n
			} else if (i && e === "dd" && this._minWeekdaysParse[n].test(t)) {
				return n
			} else if (!i && this._weekdaysParse[n].test(t)) {
				return n
			}
		}
	}

	function Xe(t) {
		if (!this.isValid()) {
			return t != null ? this : NaN
		}
		var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
		if (t != null) {
			t = We(t, this.localeData());
			return this.add(t - e, "d")
		} else {
			return e
		}
	}

	function Ze(t) {
		if (!this.isValid()) {
			return t != null ? this : NaN
		}
		var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
		return t == null ? e : this.add(t - e, "d")
	}

	function Qe(t) {
		if (!this.isValid()) {
			return t != null ? this : NaN
		}
		if (t != null) {
			var e = Be(t, this.localeData());
			return this.day(this.day() % 7 ? e : e - 7)
		} else {
			return this.day() || 7
		}
	}
	var Je = Xt;

	function ti(t) {
		if (this._weekdaysParseExact) {
			if (!a(this, "_weekdaysRegex")) {
				oi.call(this)
			}
			if (t) {
				return this._weekdaysStrictRegex
			} else {
				return this._weekdaysRegex
			}
		} else {
			if (!a(this, "_weekdaysRegex")) {
				this._weekdaysRegex = Je
			}
			return this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex
		}
	}
	var ei = Xt;

	function ii(t) {
		if (this._weekdaysParseExact) {
			if (!a(this, "_weekdaysRegex")) {
				oi.call(this)
			}
			if (t) {
				return this._weekdaysShortStrictRegex
			} else {
				return this._weekdaysShortRegex
			}
		} else {
			if (!a(this, "_weekdaysShortRegex")) {
				this._weekdaysShortRegex = ei
			}
			return this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex
		}
	}
	var ni = Xt;

	function si(t) {
		if (this._weekdaysParseExact) {
			if (!a(this, "_weekdaysRegex")) {
				oi.call(this)
			}
			if (t) {
				return this._weekdaysMinStrictRegex
			} else {
				return this._weekdaysMinRegex
			}
		} else {
			if (!a(this, "_weekdaysMinRegex")) {
				this._weekdaysMinRegex = ni
			}
			return this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex
		}
	}

	function oi() {
		function t(t, e) {
			return e.length - t.length
		}
		var e = [],
			i = [],
			n = [],
			s = [],
			o, r, a, l, h;
		for (o = 0; o < 7; o++) {
			r = c([2e3, 1]).day(o);
			a = this.weekdaysMin(r, "");
			l = this.weekdaysShort(r, "");
			h = this.weekdays(r, "");
			e.push(a);
			i.push(l);
			n.push(h);
			s.push(a);
			s.push(l);
			s.push(h)
		}
		e.sort(t);
		i.sort(t);
		n.sort(t);
		s.sort(t);
		for (o = 0; o < 7; o++) {
			i[o] = te(i[o]);
			n[o] = te(n[o]);
			s[o] = te(s[o])
		}
		this._weekdaysRegex = new RegExp("^(" + s.join("|") + ")", "i");
		this._weekdaysShortRegex = this._weekdaysRegex;
		this._weekdaysMinRegex = this._weekdaysRegex;
		this._weekdaysStrictRegex = new RegExp("^(" + n.join("|") + ")", "i");
		this._weekdaysShortStrictRegex = new RegExp("^(" + i.join("|") + ")", "i");
		this._weekdaysMinStrictRegex = new RegExp("^(" + e.join("|") + ")", "i")
	}

	function ri() {
		return this.hours() % 12 || 12
	}

	function ai() {
		return this.hours() || 24
	}
	n("H", ["HH", 2], 0, "hour");
	n("h", ["hh", 2], 0, ri);
	n("k", ["kk", 2], 0, ai);
	n("hmm", 0, 0, function () {
		return "" + ri.apply(this) + m(this.minutes(), 2)
	});
	n("hmmss", 0, 0, function () {
		return "" + ri.apply(this) + m(this.minutes(), 2) + m(this.seconds(), 2)
	});
	n("Hmm", 0, 0, function () {
		return "" + this.hours() + m(this.minutes(), 2)
	});
	n("Hmmss", 0, 0, function () {
		return "" + this.hours() + m(this.minutes(), 2) + m(this.seconds(), 2)
	});

	function li(t, e) {
		n(t, 0, 0, function () {
			return this.localeData().meridiem(this.hours(), this.minutes(), e)
		})
	}
	li("a", true);
	li("A", false);
	e("hour", "h");
	i("hour", 13);

	function hi(t, e) {
		return e._meridiemParse
	}
	_("a", hi);
	_("A", hi);
	_("H", b);
	_("h", b);
	_("k", b);
	_("HH", b, v);
	_("hh", b, v);
	_("kk", b, v);
	_("hmm", Wt);
	_("hmmss", Bt);
	_("Hmm", Wt);
	_("Hmmss", Bt);
	y(["H", "HH"], C);
	y(["k", "kk"], function (t, e, i) {
		var n = u(t);
		e[C] = n === 24 ? 0 : n
	});
	y(["a", "A"], function (t, e, i) {
		i._isPm = i._locale.isPM(t);
		i._meridiem = t
	});
	y(["h", "hh"], function (t, e, i) {
		e[C] = u(t);
		f(i).bigHour = true
	});
	y("hmm", function (t, e, i) {
		var n = t.length - 2;
		e[C] = u(t.substr(0, n));
		e[D] = u(t.substr(n));
		f(i).bigHour = true
	});
	y("hmmss", function (t, e, i) {
		var n = t.length - 4;
		var s = t.length - 2;
		e[C] = u(t.substr(0, n));
		e[D] = u(t.substr(n, 2));
		e[M] = u(t.substr(s));
		f(i).bigHour = true
	});
	y("Hmm", function (t, e, i) {
		var n = t.length - 2;
		e[C] = u(t.substr(0, n));
		e[D] = u(t.substr(n))
	});
	y("Hmmss", function (t, e, i) {
		var n = t.length - 4;
		var s = t.length - 2;
		e[C] = u(t.substr(0, n));
		e[D] = u(t.substr(n, 2));
		e[M] = u(t.substr(s))
	});

	function ci(t) {
		return (t + "").toLowerCase().charAt(0) === "p"
	}
	var ui = /[ap]\.?m?\.?/i;

	function di(t, e, i) {
		if (t > 11) {
			return i ? "pm" : "PM"
		} else {
			return i ? "am" : "AM"
		}
	}
	var fi = kt("Hours", true);
	var pi = {
		calendar: at,
		longDateFormat: ht,
		invalidDate: ut,
		ordinal: ft,
		dayOfMonthOrdinalParse: pt,
		relativeTime: mt,
		months: ce,
		monthsShort: de,
		week: Ne,
		weekdays: je,
		weekdaysMin: Ue,
		weekdaysShort: Ve,
		meridiemParse: ui
	};
	var S = {};
	var gi = {};
	var mi;

	function vi(t) {
		return t ? t.toLowerCase().replace("_", "-") : t
	}

	function bi(t) {
		var e = 0,
			i, n, s, o;
		while (e < t.length) {
			o = vi(t[e]).split("-");
			i = o.length;
			n = vi(t[e + 1]);
			n = n ? n.split("-") : null;
			while (i > 0) {
				s = _i(o.slice(0, i).join("-"));
				if (s) {
					return s
				}
				if (n && n.length >= i && Q(o, n, true) >= i - 1) {
					break
				}
				i--
			}
			e++
		}
		return null
	}

	function _i(t) {
		var e = null;
		if (!S[t] && typeof module !== "undefined" && module && module.exports) {
			try {
				e = mi._abbr;
				require("./locale/" + t);
				yi(e)
			} catch (t) { }
		}
		return S[t]
	}

	function yi(t, e) {
		var i;
		if (t) {
			if (o(e)) {
				i = ki(t)
			} else {
				i = xi(t, e)
			}
			if (i) {
				mi = i
			}
		}
		return mi._abbr
	}

	function xi(t, e) {
		if (e !== null) {
			var i = pi;
			e.abbr = t;
			if (S[t] != null) {
				et("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change " + "an existing locale. moment.defineLocale(localeName, " + "config) should only be used for creating a new locale " + "See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
				i = S[t]._config
			} else if (e.parentLocale != null) {
				if (S[e.parentLocale] != null) {
					i = S[e.parentLocale]._config
				} else {
					if (!gi[e.parentLocale]) {
						gi[e.parentLocale] = []
					}
					gi[e.parentLocale].push({
						name: t,
						config: e
					});
					return null
				}
			}
			S[t] = new st(nt(i, e));
			if (gi[t]) {
				gi[t].forEach(function (t) {
					xi(t.name, t.config)
				})
			}
			yi(t);
			return S[t]
		} else {
			delete S[t];
			return null
		}
	}

	function wi(t, e) {
		if (e != null) {
			var i, n = pi;
			if (S[t] != null) {
				n = S[t]._config
			}
			e = nt(n, e);
			i = new st(e);
			i.parentLocale = S[t];
			S[t] = i;
			yi(t)
		} else {
			if (S[t] != null) {
				if (S[t].parentLocale != null) {
					S[t] = S[t].parentLocale
				} else if (S[t] != null) {
					delete S[t]
				}
			}
		}
		return S[t]
	}

	function ki(t) {
		var e;
		if (t && t._locale && t._locale._abbr) {
			t = t._locale._abbr
		}
		if (!t) {
			return mi
		}
		if (!r(t)) {
			e = _i(t);
			if (e) {
				return e
			}
			t = [t]
		}
		return bi(t)
	}

	function Ci() {
		return rt(S)
	}

	function Di(t) {
		var e;
		var i = t._a;
		if (i && f(t).overflow === -2) {
			e = i[w] < 0 || i[w] > 11 ? w : i[k] < 1 || i[k] > le(i[x], i[w]) ? k : i[C] < 0 || i[C] > 24 || i[C] === 24 && (i[D] !== 0 || i[M] !== 0 || i[se] !== 0) ? C : i[D] < 0 || i[D] > 59 ? D : i[M] < 0 || i[M] > 59 ? M : i[se] < 0 || i[se] > 999 ? se : -1;
			if (f(t)._overflowDayOfYear && (e < x || e > k)) {
				e = k
			}
			if (f(t)._overflowWeeks && e === -1) {
				e = oe
			}
			if (f(t)._overflowWeekday && e === -1) {
				e = re
			}
			f(t).overflow = e
		}
		return t
	}
	var Mi = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var Ti = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var Si = /Z|[+-]\d\d(?::?\d\d)?/;
	var Pi = [
		["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
		["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
		["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
		["GGGG-[W]WW", /\d{4}-W\d\d/, false],
		["YYYY-DDD", /\d{4}-\d{3}/],
		["YYYY-MM", /\d{4}-\d\d/, false],
		["YYYYYYMMDD", /[+-]\d{10}/],
		["YYYYMMDD", /\d{8}/],
		["GGGG[W]WWE", /\d{4}W\d{3}/],
		["GGGG[W]WW", /\d{4}W\d{2}/, false],
		["YYYYDDD", /\d{7}/]
	];
	var Ii = [
		["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
		["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
		["HH:mm:ss", /\d\d:\d\d:\d\d/],
		["HH:mm", /\d\d:\d\d/],
		["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
		["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
		["HHmmss", /\d\d\d\d\d\d/],
		["HHmm", /\d\d\d\d/],
		["HH", /\d\d/]
	];
	var Ei = /^\/?Date\((\-?\d+)/i;

	function Oi(t) {
		var e, i, n = t._i,
			s = Mi.exec(n) || Ti.exec(n),
			o, r, a, l;
		if (s) {
			f(t).iso = true;
			for (e = 0, i = Pi.length; e < i; e++) {
				if (Pi[e][1].exec(s[1])) {
					r = Pi[e][0];
					o = Pi[e][2] !== false;
					break
				}
			}
			if (r == null) {
				t._isValid = false;
				return
			}
			if (s[3]) {
				for (e = 0, i = Ii.length; e < i; e++) {
					if (Ii[e][1].exec(s[3])) {
						a = (s[2] || " ") + Ii[e][0];
						break
					}
				}
				if (a == null) {
					t._isValid = false;
					return
				}
			}
			if (!o && a != null) {
				t._isValid = false;
				return
			}
			if (s[4]) {
				if (Si.exec(s[4])) {
					l = "Z"
				} else {
					t._isValid = false;
					return
				}
			}
			t._f = r + (a || "") + (l || "");
			Wi(t)
		} else {
			t._isValid = false
		}
	}
	var Ai = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

	function Li(t) {
		var e, i, n, s, o, r;
		var a = {
			" GMT": " +0000",
			" EDT": " -0400",
			" EST": " -0500",
			" CDT": " -0500",
			" CST": " -0600",
			" MDT": " -0600",
			" MST": " -0700",
			" PDT": " -0700",
			" PST": " -0800"
		};
		var l = "YXWVUTSRQPONZABCDEFGHIKLM";
		var h, c;
		e = t._i.replace(/\([^\)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s|\s$/g, "");
		i = Ai.exec(e);
		if (i) {
			n = i[1] ? "ddd" + (i[1].length === 5 ? ", " : " ") : "";
			s = "D MMM " + (i[2].length > 10 ? "YYYY " : "YY ");
			o = "HH:mm" + (i[4] ? ":ss" : "");
			if (i[1]) {
				var u = new Date(i[2]);
				var d = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][u.getDay()];
				if (i[1].substr(0, 3) !== d) {
					f(t).weekdayMismatch = true;
					t._isValid = false;
					return
				}
			}
			switch (i[5].length) {
				case 2:
					if (c === 0) {
						h = " +0000"
					} else {
						c = l.indexOf(i[5][1].toUpperCase()) - 12;
						h = (c < 0 ? " -" : " +") + ("" + c).replace(/^-?/, "0").match(/..$/)[0] + "00"
					}
					break;
				case 4:
					h = a[i[5]];
					break;
				default:
					h = a[" GMT"]
			}
			i[5] = h;
			t._i = i.splice(1).join("");
			r = " ZZ";
			t._f = n + s + o + r;
			Wi(t);
			f(t).rfc2822 = true
		} else {
			t._isValid = false
		}
	}

	function Ni(t) {
		var e = Ei.exec(t._i);
		if (e !== null) {
			t._d = new Date(+e[1]);
			return
		}
		Oi(t);
		if (t._isValid === false) {
			delete t._isValid
		} else {
			return
		}
		Li(t);
		if (t._isValid === false) {
			delete t._isValid
		} else {
			return
		}
		h.createFromInputFallback(t)
	}
	h.createFromInputFallback = t("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " + "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " + "discouraged and will be removed in an upcoming major release. Please refer to " + "http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (t) {
		t._d = new Date(t._i + (t._useUTC ? " UTC" : ""))
	});

	function Ri(t, e, i) {
		if (t != null) {
			return t
		}
		if (e != null) {
			return e
		}
		return i
	}

	function Fi(t) {
		var e = new Date(h.now());
		if (t._useUTC) {
			return [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()]
		}
		return [e.getFullYear(), e.getMonth(), e.getDate()]
	}

	function Hi(t) {
		var e, i, n = [],
			s, o;
		if (t._d) {
			return
		}
		s = Fi(t);
		if (t._w && t._a[k] == null && t._a[w] == null) {
			zi(t)
		}
		if (t._dayOfYear != null) {
			o = Ri(t._a[x], s[x]);
			if (t._dayOfYear > Ce(o) || t._dayOfYear === 0) {
				f(t)._overflowDayOfYear = true
			}
			i = Pe(o, 0, t._dayOfYear);
			t._a[w] = i.getUTCMonth();
			t._a[k] = i.getUTCDate()
		}
		for (e = 0; e < 3 && t._a[e] == null; ++e) {
			t._a[e] = n[e] = s[e]
		}
		for (; e < 7; e++) {
			t._a[e] = n[e] = t._a[e] == null ? e === 2 ? 1 : 0 : t._a[e]
		}
		if (t._a[C] === 24 && t._a[D] === 0 && t._a[M] === 0 && t._a[se] === 0) {
			t._nextDay = true;
			t._a[C] = 0
		}
		t._d = (t._useUTC ? Pe : Se).apply(null, n);
		if (t._tzm != null) {
			t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm)
		}
		if (t._nextDay) {
			t._a[C] = 24
		}
	}

	function zi(t) {
		var e, i, n, s, o, r, a, l;
		e = t._w;
		if (e.GG != null || e.W != null || e.E != null) {
			o = 1;
			r = 4;
			i = Ri(e.GG, t._a[x], Oe(P(), 1, 4).year);
			n = Ri(e.W, 1);
			s = Ri(e.E, 1);
			if (s < 1 || s > 7) {
				l = true
			}
		} else {
			o = t._locale._week.dow;
			r = t._locale._week.doy;
			var h = Oe(P(), o, r);
			i = Ri(e.gg, t._a[x], h.year);
			n = Ri(e.w, h.week);
			if (e.d != null) {
				s = e.d;
				if (s < 0 || s > 6) {
					l = true
				}
			} else if (e.e != null) {
				s = e.e + o;
				if (e.e < 0 || e.e > 6) {
					l = true
				}
			} else {
				s = o
			}
		}
		if (n < 1 || n > Ae(i, o, r)) {
			f(t)._overflowWeeks = true
		} else if (l != null) {
			f(t)._overflowWeekday = true
		} else {
			a = Ee(i, n, s, o, r);
			t._a[x] = a.year;
			t._dayOfYear = a.dayOfYear
		}
	}
	h.ISO_8601 = function () { };
	h.RFC_2822 = function () { };

	function Wi(t) {
		if (t._f === h.ISO_8601) {
			Oi(t);
			return
		}
		if (t._f === h.RFC_2822) {
			Li(t);
			return
		}
		t._a = [];
		f(t).empty = true;
		var e = "" + t._i,
			i, n, s, o, r, a = e.length,
			l = 0;
		s = Nt(t._f, t._locale).match(St) || [];
		for (i = 0; i < s.length; i++) {
			o = s[i];
			n = (e.match(Qt(o, t)) || [])[0];
			if (n) {
				r = e.substr(0, e.indexOf(n));
				if (r.length > 0) {
					f(t).unusedInput.push(r)
				}
				e = e.slice(e.indexOf(n) + n.length);
				l += n.length
			}
			if (Et[o]) {
				if (n) {
					f(t).empty = false
				} else {
					f(t).unusedTokens.push(o)
				}
				ne(o, n, t)
			} else if (t._strict && !n) {
				f(t).unusedTokens.push(o)
			}
		}
		f(t).charsLeftOver = a - l;
		if (e.length > 0) {
			f(t).unusedInput.push(e)
		}
		if (t._a[C] <= 12 && f(t).bigHour === true && t._a[C] > 0) {
			f(t).bigHour = undefined
		}
		f(t).parsedDateParts = t._a.slice(0);
		f(t).meridiem = t._meridiem;
		t._a[C] = Bi(t._locale, t._a[C], t._meridiem);
		Hi(t);
		Di(t)
	}

	function Bi(t, e, i) {
		var n;
		if (i == null) {
			return e
		}
		if (t.meridiemHour != null) {
			return t.meridiemHour(e, i)
		} else if (t.isPM != null) {
			n = t.isPM(i);
			if (n && e < 12) {
				e += 12
			}
			if (!n && e === 12) {
				e = 0
			}
			return e
		} else {
			return e
		}
	}

	function ji(t) {
		var e, i, n, s, o;
		if (t._f.length === 0) {
			f(t).invalidFormat = true;
			t._d = new Date(NaN);
			return
		}
		for (s = 0; s < t._f.length; s++) {
			o = 0;
			e = K({}, t);
			if (t._useUTC != null) {
				e._useUTC = t._useUTC
			}
			e._f = t._f[s];
			Wi(e);
			if (!U(e)) {
				continue
			}
			o += f(e).charsLeftOver;
			o += f(e).unusedTokens.length * 10;
			f(e).score = o;
			if (n == null || o < n) {
				n = o;
				i = e
			}
		}
		l(t, i || e)
	}

	function Yi(t) {
		if (t._d) {
			return
		}
		var e = yt(t._i);
		t._a = j([e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], function (t) {
			return t && parseInt(t, 10)
		});
		Hi(t)
	}

	function Vi(t) {
		var e = new Z(Di($i(t)));
		if (e._nextDay) {
			e.add(1, "d");
			e._nextDay = undefined
		}
		return e
	}

	function $i(t) {
		var e = t._i,
			i = t._f;
		t._locale = t._locale || ki(t._l);
		if (e === null || i === undefined && e === "") {
			return q({
				nullInput: true
			})
		}
		if (typeof e === "string") {
			t._i = e = t._locale.preparse(e)
		}
		if (s(e)) {
			return new Z(Di(e))
		} else if (B(e)) {
			t._d = e
		} else if (r(i)) {
			ji(t)
		} else if (i) {
			Wi(t)
		} else {
			Ui(t)
		}
		if (!U(t)) {
			t._d = null
		}
		return t
	}

	function Ui(t) {
		var e = t._i;
		if (o(e)) {
			t._d = new Date(h.now())
		} else if (B(e)) {
			t._d = new Date(e.valueOf())
		} else if (typeof e === "string") {
			Ni(t)
		} else if (r(e)) {
			t._a = j(e.slice(0), function (t) {
				return parseInt(t, 10)
			});
			Hi(t)
		} else if (H(e)) {
			Yi(t)
		} else if (W(e)) {
			t._d = new Date(e)
		} else {
			h.createFromInputFallback(t)
		}
	}

	function qi(t, e, i, n, s) {
		var o = {};
		if (i === true || i === false) {
			n = i;
			i = undefined
		}
		if (H(t) && z(t) || r(t) && t.length === 0) {
			t = undefined
		}
		o._isAMomentObject = true;
		o._useUTC = o._isUTC = s;
		o._l = i;
		o._i = t;
		o._f = e;
		o._strict = n;
		return Vi(o)
	}

	function P(t, e, i, n) {
		return qi(t, e, i, n, false)
	}
	var Gi = t("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
		var t = P.apply(null, arguments);
		if (this.isValid() && t.isValid()) {
			return t < this ? this : t
		} else {
			return q()
		}
	});
	var Ki = t("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
		var t = P.apply(null, arguments);
		if (this.isValid() && t.isValid()) {
			return t > this ? this : t
		} else {
			return q()
		}
	});

	function Xi(t, e) {
		var i, n;
		if (e.length === 1 && r(e[0])) {
			e = e[0]
		}
		if (!e.length) {
			return P()
		}
		i = e[0];
		for (n = 1; n < e.length; ++n) {
			if (!e[n].isValid() || e[n][t](i)) {
				i = e[n]
			}
		}
		return i
	}

	function Zi() {
		var t = [].slice.call(arguments, 0);
		return Xi("isBefore", t)
	}

	function Qi() {
		var t = [].slice.call(arguments, 0);
		return Xi("isAfter", t)
	}
	var Ji = function () {
		return Date.now ? Date.now() : +new Date
	};
	var tn = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

	function en(t) {
		for (var e in t) {
			if (!(tn.indexOf(e) !== -1 && (t[e] == null || !isNaN(t[e])))) {
				return false
			}
		}
		var i = false;
		for (var n = 0; n < tn.length; ++n) {
			if (t[tn[n]]) {
				if (i) {
					return false
				}
				if (parseFloat(t[tn[n]]) !== u(t[tn[n]])) {
					i = true
				}
			}
		}
		return true
	}

	function nn() {
		return this._isValid
	}

	function sn() {
		return I(NaN)
	}

	function on(t) {
		var e = yt(t),
			i = e.year || 0,
			n = e.quarter || 0,
			s = e.month || 0,
			o = e.week || 0,
			r = e.day || 0,
			a = e.hour || 0,
			l = e.minute || 0,
			h = e.second || 0,
			c = e.millisecond || 0;
		this._isValid = en(e);
		this._milliseconds = +c + h * 1e3 + l * 6e4 + a * 1e3 * 60 * 60;
		this._days = +r + o * 7;
		this._months = +s + n * 3 + i * 12;
		this._data = {};
		this._locale = ki();
		this._bubble()
	}

	function rn(t) {
		return t instanceof on
	}

	function an(t) {
		if (t < 0) {
			return Math.round(-1 * t) * -1
		} else {
			return Math.round(t)
		}
	}

	function ln(t, i) {
		n(t, 0, 0, function () {
			var t = this.utcOffset();
			var e = "+";
			if (t < 0) {
				t = -t;
				e = "-"
			}
			return e + m(~~(t / 60), 2) + i + m(~~t % 60, 2)
		})
	}
	ln("Z", ":");
	ln("ZZ", "");
	_("Z", Gt);
	_("ZZ", Gt);
	y(["Z", "ZZ"], function (t, e, i) {
		i._useUTC = true;
		i._tzm = cn(Gt, t)
	});
	var hn = /([\+\-]|\d\d)/gi;

	function cn(t, e) {
		var i = (e || "").match(t);
		if (i === null) {
			return null
		}
		var n = i[i.length - 1] || [];
		var s = (n + "").match(hn) || ["-", 0, 0];
		var o = +(s[1] * 60) + u(s[2]);
		return o === 0 ? 0 : s[0] === "+" ? o : -o
	}

	function un(t, e) {
		var i, n;
		if (e._isUTC) {
			i = e.clone();
			n = (s(t) || B(t) ? t.valueOf() : P(t).valueOf()) - i.valueOf();
			i._d.setTime(i._d.valueOf() + n);
			h.updateOffset(i, false);
			return i
		} else {
			return P(t).local()
		}
	}

	function dn(t) {
		return -Math.round(t._d.getTimezoneOffset() / 15) * 15
	}
	h.updateOffset = function () { };

	function fn(t, e, i) {
		var n = this._offset || 0,
			s;
		if (!this.isValid()) {
			return t != null ? this : NaN
		}
		if (t != null) {
			if (typeof t === "string") {
				t = cn(Gt, t);
				if (t === null) {
					return this
				}
			} else if (Math.abs(t) < 16 && !i) {
				t = t * 60
			}
			if (!this._isUTC && e) {
				s = dn(this)
			}
			this._offset = t;
			this._isUTC = true;
			if (s != null) {
				this.add(s, "m")
			}
			if (n !== t) {
				if (!e || this._changeInProgress) {
					In(this, I(t - n, "m"), 1, false)
				} else if (!this._changeInProgress) {
					this._changeInProgress = true;
					h.updateOffset(this, true);
					this._changeInProgress = null
				}
			}
			return this
		} else {
			return this._isUTC ? n : dn(this)
		}
	}

	function pn(t, e) {
		if (t != null) {
			if (typeof t !== "string") {
				t = -t
			}
			this.utcOffset(t, e);
			return this
		} else {
			return -this.utcOffset()
		}
	}

	function gn(t) {
		return this.utcOffset(0, t)
	}

	function mn(t) {
		if (this._isUTC) {
			this.utcOffset(0, t);
			this._isUTC = false;
			if (t) {
				this.subtract(dn(this), "m")
			}
		}
		return this
	}

	function vn() {
		if (this._tzm != null) {
			this.utcOffset(this._tzm, false, true)
		} else if (typeof this._i === "string") {
			var t = cn(qt, this._i);
			if (t != null) {
				this.utcOffset(t)
			} else {
				this.utcOffset(0, true)
			}
		}
		return this
	}

	function bn(t) {
		if (!this.isValid()) {
			return false
		}
		t = t ? P(t).utcOffset() : 0;
		return (this.utcOffset() - t) % 60 === 0
	}

	function _n() {
		return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
	}

	function yn() {
		if (!o(this._isDSTShifted)) {
			return this._isDSTShifted
		}
		var t = {};
		K(t, this);
		t = $i(t);
		if (t._a) {
			var e = t._isUTC ? c(t._a) : P(t._a);
			this._isDSTShifted = this.isValid() && Q(t._a, e.toArray()) > 0
		} else {
			this._isDSTShifted = false
		}
		return this._isDSTShifted
	}

	function xn() {
		return this.isValid() ? !this._isUTC : false
	}

	function wn() {
		return this.isValid() ? this._isUTC : false
	}

	function kn() {
		return this.isValid() ? this._isUTC && this._offset === 0 : false
	}
	var Cn = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
	var Dn = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

	function I(t, e) {
		var i = t,
			n = null,
			s, o, r;
		if (rn(t)) {
			i = {
				ms: t._milliseconds,
				d: t._days,
				M: t._months
			}
		} else if (W(t)) {
			i = {};
			if (e) {
				i[e] = t
			} else {
				i.milliseconds = t
			}
		} else if (!!(n = Cn.exec(t))) {
			s = n[1] === "-" ? -1 : 1;
			i = {
				y: 0,
				d: u(n[k]) * s,
				h: u(n[C]) * s,
				m: u(n[D]) * s,
				s: u(n[M]) * s,
				ms: u(an(n[se] * 1e3)) * s
			}
		} else if (!!(n = Dn.exec(t))) {
			s = n[1] === "-" ? -1 : 1;
			i = {
				y: Mn(n[2], s),
				M: Mn(n[3], s),
				w: Mn(n[4], s),
				d: Mn(n[5], s),
				h: Mn(n[6], s),
				m: Mn(n[7], s),
				s: Mn(n[8], s)
			}
		} else if (i == null) {
			i = {}
		} else if (typeof i === "object" && ("from" in i || "to" in i)) {
			r = Sn(P(i.from), P(i.to));
			i = {};
			i.ms = r.milliseconds;
			i.M = r.months
		}
		o = new on(i);
		if (rn(t) && a(t, "_locale")) {
			o._locale = t._locale
		}
		return o
	}
	I.fn = on.prototype;
	I.invalid = sn;

	function Mn(t, e) {
		var i = t && parseFloat(t.replace(",", "."));
		return (isNaN(i) ? 0 : i) * e
	}

	function Tn(t, e) {
		var i = {
			milliseconds: 0,
			months: 0
		};
		i.months = e.month() - t.month() + (e.year() - t.year()) * 12;
		if (t.clone().add(i.months, "M").isAfter(e)) {
			--i.months
		}
		i.milliseconds = +e - +t.clone().add(i.months, "M");
		return i
	}

	function Sn(t, e) {
		var i;
		if (!(t.isValid() && e.isValid())) {
			return {
				milliseconds: 0,
				months: 0
			}
		}
		e = un(e, t);
		if (t.isBefore(e)) {
			i = Tn(t, e)
		} else {
			i = Tn(e, t);
			i.milliseconds = -i.milliseconds;
			i.months = -i.months
		}
		return i
	}

	function Pn(s, o) {
		return function (t, e) {
			var i, n;
			if (e !== null && !isNaN(+e)) {
				et(o, "moment()." + o + "(period, number) is deprecated. Please use moment()." + o + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
				n = t;
				t = e;
				e = n
			}
			t = typeof t === "string" ? +t : t;
			i = I(t, e);
			In(this, i, s);
			return this
		}
	}

	function In(t, e, i, n) {
		var s = e._milliseconds,
			o = an(e._days),
			r = an(e._months);
		if (!t.isValid()) {
			return
		}
		n = n == null ? true : n;
		if (s) {
			t._d.setTime(t._d.valueOf() + s * i)
		}
		if (o) {
			Dt(t, "Date", Ct(t, "Date") + o * i)
		}
		if (r) {
			me(t, Ct(t, "Month") + r * i)
		}
		if (n) {
			h.updateOffset(t, o || r)
		}
	}
	var En = Pn(1, "add");
	var On = Pn(-1, "subtract");

	function An(t, e) {
		var i = t.diff(e, "days", true);
		return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse"
	}

	function Ln(t, e) {
		var i = t || P(),
			n = un(i, this).startOf("day"),
			s = h.calendarFormat(this, n) || "sameElse";
		var o = e && (d(e[s]) ? e[s].call(this, i) : e[s]);
		return this.format(o || this.localeData().calendar(s, this, P(i)))
	}

	function Nn() {
		return new Z(this)
	}

	function Rn(t, e) {
		var i = s(t) ? t : P(t);
		if (!(this.isValid() && i.isValid())) {
			return false
		}
		e = g(!o(e) ? e : "millisecond");
		if (e === "millisecond") {
			return this.valueOf() > i.valueOf()
		} else {
			return i.valueOf() < this.clone().startOf(e).valueOf()
		}
	}

	function Fn(t, e) {
		var i = s(t) ? t : P(t);
		if (!(this.isValid() && i.isValid())) {
			return false
		}
		e = g(!o(e) ? e : "millisecond");
		if (e === "millisecond") {
			return this.valueOf() < i.valueOf()
		} else {
			return this.clone().endOf(e).valueOf() < i.valueOf()
		}
	}

	function Hn(t, e, i, n) {
		n = n || "()";
		return (n[0] === "(" ? this.isAfter(t, i) : !this.isBefore(t, i)) && (n[1] === ")" ? this.isBefore(e, i) : !this.isAfter(e, i))
	}

	function zn(t, e) {
		var i = s(t) ? t : P(t),
			n;
		if (!(this.isValid() && i.isValid())) {
			return false
		}
		e = g(e || "millisecond");
		if (e === "millisecond") {
			return this.valueOf() === i.valueOf()
		} else {
			n = i.valueOf();
			return this.clone().startOf(e).valueOf() <= n && n <= this.clone().endOf(e).valueOf()
		}
	}

	function Wn(t, e) {
		return this.isSame(t, e) || this.isAfter(t, e)
	}

	function Bn(t, e) {
		return this.isSame(t, e) || this.isBefore(t, e)
	}

	function jn(t, e, i) {
		var n, s, o, r;
		if (!this.isValid()) {
			return NaN
		}
		n = un(t, this);
		if (!n.isValid()) {
			return NaN
		}
		s = (n.utcOffset() - this.utcOffset()) * 6e4;
		e = g(e);
		if (e === "year" || e === "month" || e === "quarter") {
			r = Yn(this, n);
			if (e === "quarter") {
				r = r / 3
			} else if (e === "year") {
				r = r / 12
			}
		} else {
			o = this - n;
			r = e === "second" ? o / 1e3 : e === "minute" ? o / 6e4 : e === "hour" ? o / 36e5 : e === "day" ? (o - s) / 864e5 : e === "week" ? (o - s) / 6048e5 : o
		}
		return i ? r : p(r)
	}

	function Yn(t, e) {
		var i = (e.year() - t.year()) * 12 + (e.month() - t.month()),
			n = t.clone().add(i, "months"),
			s, o;
		if (e - n < 0) {
			s = t.clone().add(i - 1, "months");
			o = (e - n) / (n - s)
		} else {
			s = t.clone().add(i + 1, "months");
			o = (e - n) / (s - n)
		}
		return -(i + o) || 0
	}
	h.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
	h.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";

	function Vn() {
		return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
	}

	function $n() {
		if (!this.isValid()) {
			return null
		}
		var t = this.clone().utc();
		if (t.year() < 0 || t.year() > 9999) {
			return Lt(t, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
		}
		if (d(Date.prototype.toISOString)) {
			return this.toDate().toISOString()
		}
		return Lt(t, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
	}

	function Un() {
		if (!this.isValid()) {
			return "moment.invalid(/* " + this._i + " */)"
		}
		var t = "moment";
		var e = "";
		if (!this.isLocal()) {
			t = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
			e = "Z"
		}
		var i = "[" + t + '("]';
		var n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
		var s = "-MM-DD[T]HH:mm:ss.SSS";
		var o = e + '[")]';
		return this.format(i + n + s + o)
	}

	function qn(t) {
		if (!t) {
			t = this.isUtc() ? h.defaultFormatUtc : h.defaultFormat
		}
		var e = Lt(this, t);
		return this.localeData().postformat(e)
	}

	function Gn(t, e) {
		if (this.isValid() && (s(t) && t.isValid() || P(t).isValid())) {
			return I({
				to: this,
				from: t
			}).locale(this.locale()).humanize(!e)
		} else {
			return this.localeData().invalidDate()
		}
	}

	function Kn(t) {
		return this.from(P(), t)
	}

	function Xn(t, e) {
		if (this.isValid() && (s(t) && t.isValid() || P(t).isValid())) {
			return I({
				from: this,
				to: t
			}).locale(this.locale()).humanize(!e)
		} else {
			return this.localeData().invalidDate()
		}
	}

	function Zn(t) {
		return this.to(P(), t)
	}

	function Qn(t) {
		var e;
		if (t === undefined) {
			return this._locale._abbr
		} else {
			e = ki(t);
			if (e != null) {
				this._locale = e
			}
			return this
		}
	}
	var Jn = t("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (t) {
		if (t === undefined) {
			return this.localeData()
		} else {
			return this.locale(t)
		}
	});

	function ts() {
		return this._locale
	}

	function es(t) {
		t = g(t);
		switch (t) {
			case "year":
				this.month(0);
			case "quarter":
			case "month":
				this.date(1);
			case "week":
			case "isoWeek":
			case "day":
			case "date":
				this.hours(0);
			case "hour":
				this.minutes(0);
			case "minute":
				this.seconds(0);
			case "second":
				this.milliseconds(0)
		}
		if (t === "week") {
			this.weekday(0)
		}
		if (t === "isoWeek") {
			this.isoWeekday(1)
		}
		if (t === "quarter") {
			this.month(Math.floor(this.month() / 3) * 3)
		}
		return this
	}

	function is(t) {
		t = g(t);
		if (t === undefined || t === "millisecond") {
			return this
		}
		if (t === "date") {
			t = "day"
		}
		return this.startOf(t).add(1, t === "isoWeek" ? "week" : t).subtract(1, "ms")
	}

	function ns() {
		return this._d.valueOf() - (this._offset || 0) * 6e4
	}

	function ss() {
		return Math.floor(this.valueOf() / 1e3)
	}

	function os() {
		return new Date(this.valueOf())
	}

	function rs() {
		var t = this;
		return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()]
	}

	function as() {
		var t = this;
		return {
			years: t.year(),
			months: t.month(),
			date: t.date(),
			hours: t.hours(),
			minutes: t.minutes(),
			seconds: t.seconds(),
			milliseconds: t.milliseconds()
		}
	}

	function ls() {
		return this.isValid() ? this.toISOString() : null
	}

	function hs() {
		return U(this)
	}

	function cs() {
		return l({}, f(this))
	}

	function us() {
		return f(this).overflow
	}

	function ds() {
		return {
			input: this._i,
			format: this._f,
			locale: this._locale,
			isUTC: this._isUTC,
			strict: this._strict
		}
	}
	n(0, ["gg", 2], 0, function () {
		return this.weekYear() % 100
	});
	n(0, ["GG", 2], 0, function () {
		return this.isoWeekYear() % 100
	});

	function fs(t, e) {
		n(0, [t, t.length], 0, e)
	}
	fs("gggg", "weekYear");
	fs("ggggg", "weekYear");
	fs("GGGG", "isoWeekYear");
	fs("GGGGG", "isoWeekYear");
	e("weekYear", "gg");
	e("isoWeekYear", "GG");
	i("weekYear", 1);
	i("isoWeekYear", 1);
	_("G", Ut);
	_("g", Ut);
	_("GG", b, v);
	_("gg", b, v);
	_("GGGG", Yt, Ht);
	_("gggg", Yt, Ht);
	_("GGGGG", Vt, zt);
	_("ggggg", Vt, zt);
	ie(["gggg", "ggggg", "GGGG", "GGGGG"], function (t, e, i, n) {
		e[n.substr(0, 2)] = u(t)
	});
	ie(["gg", "GG"], function (t, e, i, n) {
		e[n] = h.parseTwoDigitYear(t)
	});

	function ps(t) {
		return bs.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
	}

	function gs(t) {
		return bs.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4)
	}

	function ms() {
		return Ae(this.year(), 1, 4)
	}

	function vs() {
		var t = this.localeData()._week;
		return Ae(this.year(), t.dow, t.doy)
	}

	function bs(t, e, i, n, s) {
		var o;
		if (t == null) {
			return Oe(this, n, s).year
		} else {
			o = Ae(t, n, s);
			if (e > o) {
				e = o
			}
			return _s.call(this, t, e, i, n, s)
		}
	}

	function _s(t, e, i, n, s) {
		var o = Ee(t, e, i, n, s),
			r = Pe(o.year, 0, o.dayOfYear);
		this.year(r.getUTCFullYear());
		this.month(r.getUTCMonth());
		this.date(r.getUTCDate());
		return this
	}
	n("Q", 0, "Qo", "quarter");
	e("quarter", "Q");
	i("quarter", 7);
	_("Q", Rt);
	y("Q", function (t, e) {
		e[w] = (u(t) - 1) * 3
	});

	function ys(t) {
		return t == null ? Math.ceil((this.month() + 1) / 3) : this.month((t - 1) * 3 + this.month() % 3)
	}
	n("D", ["DD", 2], "Do", "date");
	e("date", "D");
	i("date", 9);
	_("D", b);
	_("DD", b, v);
	_("Do", function (t, e) {
		return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient
	});
	y(["D", "DD"], k);
	y("Do", function (t, e) {
		e[k] = u(t.match(b)[0], 10)
	});
	var xs = kt("Date", true);
	n("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
	e("dayOfYear", "DDD");
	i("dayOfYear", 4);
	_("DDD", jt);
	_("DDDD", Ft);
	y(["DDD", "DDDD"], function (t, e, i) {
		i._dayOfYear = u(t)
	});

	function ws(t) {
		var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
		return t == null ? e : this.add(t - e, "d")
	}
	n("m", ["mm", 2], 0, "minute");
	e("minute", "m");
	i("minute", 14);
	_("m", b);
	_("mm", b, v);
	y(["m", "mm"], D);
	var ks = kt("Minutes", false);
	n("s", ["ss", 2], 0, "second");
	e("second", "s");
	i("second", 15);
	_("s", b);
	_("ss", b, v);
	y(["s", "ss"], M);
	var Cs = kt("Seconds", false);
	n("S", 0, 0, function () {
		return ~~(this.millisecond() / 100)
	});
	n(0, ["SS", 2], 0, function () {
		return ~~(this.millisecond() / 10)
	});
	n(0, ["SSS", 3], 0, "millisecond");
	n(0, ["SSSS", 4], 0, function () {
		return this.millisecond() * 10
	});
	n(0, ["SSSSS", 5], 0, function () {
		return this.millisecond() * 100
	});
	n(0, ["SSSSSS", 6], 0, function () {
		return this.millisecond() * 1e3
	});
	n(0, ["SSSSSSS", 7], 0, function () {
		return this.millisecond() * 1e4
	});
	n(0, ["SSSSSSSS", 8], 0, function () {
		return this.millisecond() * 1e5
	});
	n(0, ["SSSSSSSSS", 9], 0, function () {
		return this.millisecond() * 1e6
	});
	e("millisecond", "ms");
	i("millisecond", 16);
	_("S", jt, Rt);
	_("SS", jt, v);
	_("SSS", jt, Ft);
	var Ds;
	for (Ds = "SSSS"; Ds.length <= 9; Ds += "S") {
		_(Ds, $t)
	}

	function Ms(t, e) {
		e[se] = u(("0." + t) * 1e3)
	}
	for (Ds = "S"; Ds.length <= 9; Ds += "S") {
		y(Ds, Ms)
	}
	var Ts = kt("Milliseconds", false);
	n("z", 0, 0, "zoneAbbr");
	n("zz", 0, 0, "zoneName");

	function Ss() {
		return this._isUTC ? "UTC" : ""
	}

	function Ps() {
		return this._isUTC ? "Coordinated Universal Time" : ""
	}
	var E = Z.prototype;
	E.add = En;
	E.calendar = Ln;
	E.clone = Nn;
	E.diff = jn;
	E.endOf = is;
	E.format = qn;
	E.from = Gn;
	E.fromNow = Kn;
	E.to = Xn;
	E.toNow = Zn;
	E.get = Mt;
	E.invalidAt = us;
	E.isAfter = Rn;
	E.isBefore = Fn;
	E.isBetween = Hn;
	E.isSame = zn;
	E.isSameOrAfter = Wn;
	E.isSameOrBefore = Bn;
	E.isValid = hs;
	E.lang = Jn;
	E.locale = Qn;
	E.localeData = ts;
	E.max = Ki;
	E.min = Gi;
	E.parsingFlags = cs;
	E.set = Tt;
	E.startOf = es;
	E.subtract = On;
	E.toArray = rs;
	E.toObject = as;
	E.toDate = os;
	E.toISOString = $n;
	E.inspect = Un;
	E.toJSON = ls;
	E.toString = Vn;
	E.unix = ss;
	E.valueOf = ns;
	E.creationData = ds;
	E.year = Me;
	E.isLeapYear = Te;
	E.weekYear = ps;
	E.isoWeekYear = gs;
	E.quarter = E.quarters = ys;
	E.month = ve;
	E.daysInMonth = be;
	E.week = E.weeks = He;
	E.isoWeek = E.isoWeeks = ze;
	E.weeksInYear = vs;
	E.isoWeeksInYear = ms;
	E.date = xs;
	E.day = E.days = Xe;
	E.weekday = Ze;
	E.isoWeekday = Qe;
	E.dayOfYear = ws;
	E.hour = E.hours = fi;
	E.minute = E.minutes = ks;
	E.second = E.seconds = Cs;
	E.millisecond = E.milliseconds = Ts;
	E.utcOffset = fn;
	E.utc = gn;
	E.local = mn;
	E.parseZone = vn;
	E.hasAlignedHourOffset = bn;
	E.isDST = _n;
	E.isLocal = xn;
	E.isUtcOffset = wn;
	E.isUtc = kn;
	E.isUTC = kn;
	E.zoneAbbr = Ss;
	E.zoneName = Ps;
	E.dates = t("dates accessor is deprecated. Use date instead.", xs);
	E.months = t("months accessor is deprecated. Use month instead", ve);
	E.years = t("years accessor is deprecated. Use year instead", Me);
	E.zone = t("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", pn);
	E.isDSTShifted = t("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", yn);

	function Is(t) {
		return P(t * 1e3)
	}

	function Es() {
		return P.apply(null, arguments).parseZone()
	}

	function Os(t) {
		return t
	}
	var O = st.prototype;
	O.calendar = lt;
	O.longDateFormat = ct;
	O.invalidDate = dt;
	O.ordinal = gt;
	O.preparse = Os;
	O.postformat = Os;
	O.relativeTime = vt;
	O.pastFuture = bt;
	O.set = it;
	O.months = ue;
	O.monthsShort = fe;
	O.monthsParse = ge;
	O.monthsRegex = we;
	O.monthsShortRegex = ye;
	O.week = Le;
	O.firstDayOfYear = Fe;
	O.firstDayOfWeek = Re;
	O.weekdays = Ye;
	O.weekdaysMin = qe;
	O.weekdaysShort = $e;
	O.weekdaysParse = Ke;
	O.weekdaysRegex = ti;
	O.weekdaysShortRegex = ii;
	O.weekdaysMinRegex = si;
	O.isPM = ci;
	O.meridiem = di;

	function As(t, e, i, n) {
		var s = ki();
		var o = c().set(n, e);
		return s[i](o, t)
	}

	function Ls(t, e, i) {
		if (W(t)) {
			e = t;
			t = undefined
		}
		t = t || "";
		if (e != null) {
			return As(t, e, i, "month")
		}
		var n;
		var s = [];
		for (n = 0; n < 12; n++) {
			s[n] = As(t, n, i, "month")
		}
		return s
	}

	function Ns(t, e, i, n) {
		if (typeof t === "boolean") {
			if (W(e)) {
				i = e;
				e = undefined
			}
			e = e || ""
		} else {
			e = t;
			i = e;
			t = false;
			if (W(e)) {
				i = e;
				e = undefined
			}
			e = e || ""
		}
		var s = ki(),
			o = t ? s._week.dow : 0;
		if (i != null) {
			return As(e, (i + o) % 7, n, "day")
		}
		var r;
		var a = [];
		for (r = 0; r < 7; r++) {
			a[r] = As(e, (r + o) % 7, n, "day")
		}
		return a
	}

	function Rs(t, e) {
		return Ls(t, e, "months")
	}

	function Fs(t, e) {
		return Ls(t, e, "monthsShort")
	}

	function Hs(t, e, i) {
		return Ns(t, e, i, "weekdays")
	}

	function zs(t, e, i) {
		return Ns(t, e, i, "weekdaysShort")
	}

	function Ws(t, e, i) {
		return Ns(t, e, i, "weekdaysMin")
	}
	yi("en", {
		dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
		ordinal: function (t) {
			var e = t % 10,
				i = u(t % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th";
			return t + i
		}
	});
	h.lang = t("moment.lang is deprecated. Use moment.locale instead.", yi);
	h.langData = t("moment.langData is deprecated. Use moment.localeData instead.", ki);
	var A = Math.abs;

	function Bs() {
		var t = this._data;
		this._milliseconds = A(this._milliseconds);
		this._days = A(this._days);
		this._months = A(this._months);
		t.milliseconds = A(t.milliseconds);
		t.seconds = A(t.seconds);
		t.minutes = A(t.minutes);
		t.hours = A(t.hours);
		t.months = A(t.months);
		t.years = A(t.years);
		return this
	}

	function js(t, e, i, n) {
		var s = I(e, i);
		t._milliseconds += n * s._milliseconds;
		t._days += n * s._days;
		t._months += n * s._months;
		return t._bubble()
	}

	function Ys(t, e) {
		return js(this, t, e, 1)
	}

	function Vs(t, e) {
		return js(this, t, e, -1)
	}

	function $s(t) {
		if (t < 0) {
			return Math.floor(t)
		} else {
			return Math.ceil(t)
		}
	}

	function Us() {
		var t = this._milliseconds;
		var e = this._days;
		var i = this._months;
		var n = this._data;
		var s, o, r, a, l;
		if (!(t >= 0 && e >= 0 && i >= 0 || t <= 0 && e <= 0 && i <= 0)) {
			t += $s(Gs(i) + e) * 864e5;
			e = 0;
			i = 0
		}
		n.milliseconds = t % 1e3;
		s = p(t / 1e3);
		n.seconds = s % 60;
		o = p(s / 60);
		n.minutes = o % 60;
		r = p(o / 60);
		n.hours = r % 24;
		e += p(r / 24);
		l = p(qs(e));
		i += l;
		e -= $s(Gs(l));
		a = p(i / 12);
		i %= 12;
		n.days = e;
		n.months = i;
		n.years = a;
		return this
	}

	function qs(t) {
		return t * 4800 / 146097
	}

	function Gs(t) {
		return t * 146097 / 4800
	}

	function Ks(t) {
		if (!this.isValid()) {
			return NaN
		}
		var e;
		var i;
		var n = this._milliseconds;
		t = g(t);
		if (t === "month" || t === "year") {
			e = this._days + n / 864e5;
			i = this._months + qs(e);
			return t === "month" ? i : i / 12
		} else {
			e = this._days + Math.round(Gs(this._months));
			switch (t) {
				case "week":
					return e / 7 + n / 6048e5;
				case "day":
					return e + n / 864e5;
				case "hour":
					return e * 24 + n / 36e5;
				case "minute":
					return e * 1440 + n / 6e4;
				case "second":
					return e * 86400 + n / 1e3;
				case "millisecond":
					return Math.floor(e * 864e5) + n;
				default:
					throw new Error("Unknown unit " + t)
			}
		}
	}

	function Xs() {
		if (!this.isValid()) {
			return NaN
		}
		return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + u(this._months / 12) * 31536e6
	}

	function Zs(t) {
		return function () {
			return this.as(t)
		}
	}
	var Qs = Zs("ms");
	var Js = Zs("s");
	var to = Zs("m");
	var eo = Zs("h");
	var io = Zs("d");
	var no = Zs("w");
	var so = Zs("M");
	var oo = Zs("y");

	function ro(t) {
		t = g(t);
		return this.isValid() ? this[t + "s"]() : NaN
	}

	function ao(t) {
		return function () {
			return this.isValid() ? this._data[t] : NaN
		}
	}
	var lo = ao("milliseconds");
	var ho = ao("seconds");
	var co = ao("minutes");
	var uo = ao("hours");
	var fo = ao("days");
	var po = ao("months");
	var go = ao("years");

	function mo() {
		return p(this.days() / 7)
	}
	var vo = Math.round;
	var L = {
		ss: 44,
		s: 45,
		m: 45,
		h: 22,
		d: 26,
		M: 11
	};

	function bo(t, e, i, n, s) {
		return s.relativeTime(e || 1, !!i, t, n)
	}

	function _o(t, e, i) {
		var n = I(t).abs();
		var s = vo(n.as("s"));
		var o = vo(n.as("m"));
		var r = vo(n.as("h"));
		var a = vo(n.as("d"));
		var l = vo(n.as("M"));
		var h = vo(n.as("y"));
		var c = s <= L.ss && ["s", s] || s < L.s && ["ss", s] || o <= 1 && ["m"] || o < L.m && ["mm", o] || r <= 1 && ["h"] || r < L.h && ["hh", r] || a <= 1 && ["d"] || a < L.d && ["dd", a] || l <= 1 && ["M"] || l < L.M && ["MM", l] || h <= 1 && ["y"] || ["yy", h];
		c[2] = e;
		c[3] = +t > 0;
		c[4] = i;
		return bo.apply(null, c)
	}

	function yo(t) {
		if (t === undefined) {
			return vo
		}
		if (typeof t === "function") {
			vo = t;
			return true
		}
		return false
	}

	function xo(t, e) {
		if (L[t] === undefined) {
			return false
		}
		if (e === undefined) {
			return L[t]
		}
		L[t] = e;
		if (t === "s") {
			L.ss = e - 1
		}
		return true
	}

	function wo(t) {
		if (!this.isValid()) {
			return this.localeData().invalidDate()
		}
		var e = this.localeData();
		var i = _o(this, !t, e);
		if (t) {
			i = e.pastFuture(+this, i)
		}
		return e.postformat(i)
	}
	var ko = Math.abs;

	function Co() {
		if (!this.isValid()) {
			return this.localeData().invalidDate()
		}
		var t = ko(this._milliseconds) / 1e3;
		var e = ko(this._days);
		var i = ko(this._months);
		var n, s, o;
		n = p(t / 60);
		s = p(n / 60);
		t %= 60;
		n %= 60;
		o = p(i / 12);
		i %= 12;
		var r = o;
		var a = i;
		var l = e;
		var h = s;
		var c = n;
		var u = t;
		var d = this.asSeconds();
		if (!d) {
			return "P0D"
		}
		return (d < 0 ? "-" : "") + "P" + (r ? r + "Y" : "") + (a ? a + "M" : "") + (l ? l + "D" : "") + (h || c || u ? "T" : "") + (h ? h + "H" : "") + (c ? c + "M" : "") + (u ? u + "S" : "")
	}
	var N = on.prototype;
	N.isValid = nn;
	N.abs = Bs;
	N.add = Ys;
	N.subtract = Vs;
	N.as = Ks;
	N.asMilliseconds = Qs;
	N.asSeconds = Js;
	N.asMinutes = to;
	N.asHours = eo;
	N.asDays = io;
	N.asWeeks = no;
	N.asMonths = so;
	N.asYears = oo;
	N.valueOf = Xs;
	N._bubble = Us;
	N.get = ro;
	N.milliseconds = lo;
	N.seconds = ho;
	N.minutes = co;
	N.hours = uo;
	N.days = fo;
	N.weeks = mo;
	N.months = po;
	N.years = go;
	N.humanize = wo;
	N.toISOString = Co;
	N.toString = Co;
	N.toJSON = Co;
	N.locale = Qn;
	N.localeData = ts;
	N.toIsoString = t("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Co);
	N.lang = Jn;
	n("X", 0, 0, "unix");
	n("x", 0, 0, "valueOf");
	_("x", Ut);
	_("X", Kt);
	y("X", function (t, e, i) {
		i._d = new Date(parseFloat(t, 10) * 1e3)
	});
	y("x", function (t, e, i) {
		i._d = new Date(u(t))
	});
	h.version = "2.18.1";
	F(P);
	h.fn = E;
	h.min = Zi;
	h.max = Qi;
	h.now = Ji;
	h.utc = c;
	h.unix = Is;
	h.months = Rs;
	h.isDate = B;
	h.locale = yi;
	h.invalid = q;
	h.duration = I;
	h.isMoment = s;
	h.weekdays = Hs;
	h.parseZone = Es;
	h.localeData = ki;
	h.isDuration = rn;
	h.monthsShort = Fs;
	h.weekdaysMin = Ws;
	h.defineLocale = xi;
	h.updateLocale = wi;
	h.locales = Ci;
	h.weekdaysShort = zs;
	h.normalizeUnits = g;
	h.relativeTimeRounding = yo;
	h.relativeTimeThreshold = xo;
	h.calendarFormat = An;
	h.prototype = E;
	return h
});
! function (t, e) {
	"object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.template = e() : t.template = e()
}(this, function () {
	return function (i) {
		function n(t) {
			if (s[t]) return s[t].exports;
			var e = s[t] = {
				i: t,
				l: !1,
				exports: {}
			};
			return i[t].call(e.exports, e, e.exports, n), e.l = !0, e.exports
		}
		var s = {};
		return n.m = i, n.c = s, n.d = function (t, e, i) {
			n.o(t, e) || Object.defineProperty(t, e, {
				configurable: !1,
				enumerable: !0,
				get: i
			})
		}, n.n = function (t) {
			var e = t && t.__esModule ? function () {
				return t.default
			} : function () {
				return t
			};
			return n.d(e, "a", e), e
		}, n.o = function (t, e) {
			return Object.prototype.hasOwnProperty.call(t, e)
		}, n.p = "", n(n.s = 6)
	}([function (e, t, i) {
		(function (t) {
			e.exports = !1;
			try {
				e.exports = "[object process]" === Object.prototype.toString.call(t.process)
			} catch (t) { }
		}).call(t, i(4))
	}, function (t, e, i) {
		"use strict";
		var u = i(8),
			d = i(3),
			f = i(23),
			p = function (t, e) {
				e.onerror(t, e);
				var i = function () {
					return "{Template Error}"
				};
				return i.mappings = [], i.sourcesContent = [], i
			},
			n = function n(t) {
				var s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				"string" != typeof t ? s = t : s.source = t, s = d.$extend(s), t = s.source, !0 === s.debug && (s.cache = !1, s.minimize = !1, s.compileDebug = !0), s.compileDebug && (s.minimize = !1), s.filename && (s.filename = s.resolveFilename(s.filename, s));
				var e = s.filename,
					i = s.cache,
					o = s.caches;
				if (i && e) {
					var r = o.get(e);
					if (r) return r
				}
				if (!t) try {
					t = s.loader(e, s), s.source = t
				} catch (n) {
					var a = new f({
						name: "CompileError",
						path: e,
						message: "template not found: " + n.message,
						stack: n.stack
					});
					if (s.bail) throw a;
					return p(a, s)
				}
				var l = void 0,
					h = new u(s);
				try {
					l = h.build()
				} catch (a) {
					if (a = new f(a), s.bail) throw a;
					return p(a, s)
				}
				var c = function (e, i) {
					try {
						return l(e, i)
					} catch (t) {
						if (!s.compileDebug) return s.cache = !1, s.compileDebug = !0, n(s)(e, i);
						if (t = new f(t), s.bail) throw t;
						return p(t, s)()
					}
				};
				return c.mappings = l.mappings, c.sourcesContent = l.sourcesContent, c.toString = function () {
					return l.toString()
				}, i && e && o.set(e, c), c
			};
		n.Compiler = u, t.exports = n
	}, function (t, e) {
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, e.matchToToken = function (t) {
			var e = {
				type: "invalid",
				value: t[0]
			};
			return t[1] ? (e.type = "string", e.closed = !(!t[3] && !t[4])) : t[5] ? e.type = "comment" : t[6] ? (e.type = "comment", e.closed = !!t[7]) : t[8] ? e.type = "regex" : t[9] ? e.type = "number" : t[10] ? e.type = "name" : t[11] ? e.type = "punctuator" : t[12] && (e.type = "whitespace"), e
		}
	}, function (t, e, i) {
		"use strict";

		function n() {
			this.$extend = function (t) {
				return t = t || {}, r(t, t instanceof n ? t : this)
			}
		}
		var s = i(0),
			o = i(12),
			r = i(13),
			a = i(14),
			l = i(15),
			h = i(16),
			c = i(17),
			u = i(18),
			d = i(19),
			f = i(20),
			p = i(22),
			g = {
				source: null,
				filename: null,
				rules: [d, u],
				escape: !0,
				debug: !!s && "production" !== process.env.NODE_ENV,
				bail: !0,
				cache: !0,
				minimize: !0,
				compileDebug: !1,
				resolveFilename: p,
				include: a,
				htmlMinifier: f,
				htmlMinifierOptions: {
					collapseWhitespace: !0,
					minifyCSS: !0,
					minifyJS: !0,
					ignoreCustomFragments: []
				},
				onerror: l,
				loader: c,
				caches: h,
				root: "/",
				extname: ".art",
				ignore: [],
				imports: o
			};
		n.prototype = g, t.exports = new n
	}, function (t, e) {
		var i;
		i = function () {
			return this
		}();
		try {
			i = i || Function("return this")() || (0, eval)("this")
		} catch (t) {
			"object" == typeof window && (i = window)
		}
		t.exports = i
	}, function (t, e) { }, function (t, e, i) {
		"use strict";
		var n = i(7),
			s = i(1),
			o = i(24),
			r = function (t, e) {
				return e instanceof Object ? n({
					filename: t
				}, e) : s({
					filename: t,
					source: e
				})
			};
		r.render = n, r.compile = s, r.defaults = o, t.exports = r
	}, function (t, e, i) {
		"use strict";
		var n = i(1),
			s = function (t, e, i) {
				return n(t, i)(e)
			};
		t.exports = s
	}, function (t, e, i) {
		"use strict";

		function l(t, e) {
			if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
		}
		var n = i(9),
			_ = i(11),
			y = "$data",
			x = "$imports",
			h = "print",
			w = "include",
			k = "extend",
			c = "block",
			C = "$$out",
			D = "$$line",
			M = "$$blocks",
			u = "$$slice",
			T = "$$from",
			S = "$$options",
			P = function (t, e) {
				return t.hasOwnProperty(e)
			},
			I = JSON.stringify,
			s = function () {
				function a(t) {
					var e, i, n = this;
					l(this, a);
					var s = t.source,
						o = t.minimize,
						r = t.htmlMinifier;
					if (this.options = t, this.stacks = [], this.context = [], this.scripts = [], this.CONTEXT_MAP = {}, this.ignore = [y, x, S].concat(t.ignore), this.internal = (e = {}, e[C] = "''", e[D] = "[0,0]", e[M] = "arguments[1]||{}", e[T] = "null", e[h] = "function(){var s=''.concat.apply('',arguments);" + C + "+=s;return s}", e[w] = "function(src,data){var s=" + S + ".include(src,data||" + y + ",arguments[2]||" + M + "," + S + ");" + C + "+=s;return s}", e[k] = "function(from){" + T + "=from}", e[u] = "function(c,p,s){p=" + C + ";" + C + "='';c();s=" + C + ";" + C + "=p+s;return s}", e[c] = "function(){var a=arguments,s;if(typeof a[0]==='function'){return " + u + "(a[0])}else if(" + T + "){" + M + "[a[0]]=" + u + "(a[1])}else{s=" + M + "[a[0]];if(typeof s==='string'){" + C + "+=s}else{s=" + u + "(a[1])}return s}}", e), this.dependencies = (i = {}, i[h] = [C], i[w] = [C, S, y, M], i[k] = [T, w], i[c] = [u, T, C, M], i), this.importContext(C), t.compileDebug && this.importContext(D), o) try {
						s = r(s, t)
					} catch (t) { }
					this.source = s, this.getTplTokens(s, t.rules, this).forEach(function (t) {
						t.type === _.TYPE_STRING ? n.parseString(t) : n.parseExpression(t)
					})
				}
				return a.prototype.getTplTokens = function () {
					return _.apply(void 0, arguments)
				}, a.prototype.getEsTokens = function (t) {
					return n(t)
				}, a.prototype.getVariables = function (t) {
					var e = !1;
					return t.filter(function (t) {
						return "whitespace" !== t.type && "comment" !== t.type
					}).filter(function (t) {
						return "name" === t.type && !e || (e = "punctuator" === t.type && "." === t.value, !1)
					}).map(function (t) {
						return t.value
					})
				}, a.prototype.importContext = function (t) {
					var e = this,
						i = "",
						n = this.internal,
						s = this.dependencies,
						o = this.ignore,
						r = this.context,
						a = this.options,
						l = a.imports,
						h = this.CONTEXT_MAP;
					P(h, t) || -1 !== o.indexOf(t) || (P(n, t) ? (i = n[t], P(s, t) && s[t].forEach(function (t) {
						return e.importContext(t)
					})) : i = "$escape" === t || "$each" === t || P(l, t) ? x + "." + t : y + "." + t, h[t] = i, r.push({
						name: t,
						value: i
					}))
				}, a.prototype.parseString = function (t) {
					var e = t.value;
					if (e) {
						var i = C + "+=" + I(e);
						this.scripts.push({
							source: e,
							tplToken: t,
							code: i
						})
					}
				}, a.prototype.parseExpression = function (t) {
					var e = this,
						i = t.value,
						n = t.script,
						s = n.output,
						o = this.options.escape,
						r = n.code;
					s && (r = !1 === o || s === _.TYPE_RAW ? C + "+=" + n.code : C + "+=$escape(" + n.code + ")");
					var a = this.getEsTokens(r);
					this.getVariables(a).forEach(function (t) {
						return e.importContext(t)
					}), this.scripts.push({
						source: i,
						tplToken: t,
						code: r
					})
				}, a.prototype.checkExpression = function (t) {
					for (var e = [
						[/^\s*}[\w\W]*?{?[\s;]*$/, ""],
						[/(^[\w\W]*?\([\w\W]*?(?:=>|\([\w\W]*?\))\s*{[\s;]*$)/, "$1})"],
						[/(^[\w\W]*?\([\w\W]*?\)\s*{[\s;]*$)/, "$1}"]
					], i = 0; i < e.length;) {
						if (e[i][0].test(t)) {
							var n;
							t = (n = t).replace.apply(n, e[i]);
							break
						}
						i++
					}
					try {
						return new Function(t), !0
					} catch (t) {
						return !1
					}
				}, a.prototype.build = function () {
					var t = this.options,
						e = this.context,
						i = this.scripts,
						o = this.stacks,
						n = this.source,
						s = t.filename,
						r = t.imports,
						a = [],
						l = P(this.CONTEXT_MAP, k),
						h = 0,
						c = function (t, e) {
							var i = e.line,
								n = e.start,
								s = {
									generated: {
										line: o.length + h + 1,
										column: 1
									},
									original: {
										line: i + 1,
										column: n + 1
									}
								};
							return h += t.split(/\n/).length - 1, s
						},
						u = function (t) {
							return t.replace(/^[\t ]+|[\t ]$/g, "")
						};
					o.push("function(" + y + "){"), o.push("'use strict'"), o.push(y + "=" + y + "||{}"), o.push("var " + e.map(function (t) {
						return t.name + "=" + t.value
					}).join(",")), t.compileDebug ? (o.push("try{"), i.forEach(function (t) {
						t.tplToken.type === _.TYPE_EXPRESSION && o.push(D + "=[" + [t.tplToken.line, t.tplToken.start].join(",") + "]"), a.push(c(t.code, t.tplToken)), o.push(u(t.code))
					}), o.push("}catch(error){"), o.push("throw {" + ["name:'RuntimeError'", "path:" + I(s), "message:error.message", "line:" + D + "[0]+1", "column:" + D + "[1]+1", "source:" + I(n), "stack:error.stack"].join(",") + "}"), o.push("}")) : i.forEach(function (t) {
						a.push(c(t.code, t.tplToken)), o.push(u(t.code))
					}), l && (o.push(C + "=''"), o.push(w + "(" + T + "," + y + "," + M + ")")), o.push("return " + C), o.push("}");
					var d = o.join("\n");
					try {
						var f = new Function(x, S, "return " + d)(r, t);
						return f.mappings = a, f.sourcesContent = [n], f
					} catch (t) {
						for (var p = 0, g = 0, m = 0, v = void 0; p < i.length;) {
							var b = i[p];
							if (!this.checkExpression(b.code)) {
								g = b.tplToken.line, m = b.tplToken.start, v = b.code;
								break
							}
							p++
						}
						throw {
							name: "CompileError",
							path: s,
							message: t.message,
							line: g + 1,
							column: m + 1,
							source: n,
							generated: v,
							stack: t.stack
						}
					}
				}, a
			}();
		s.CONSTS = {
			DATA: y,
			IMPORTS: x,
			PRINT: h,
			INCLUDE: w,
			EXTEND: k,
			BLOCK: c,
			OPTIONS: S,
			OUT: C,
			LINE: D,
			BLOCKS: M,
			SLICE: u,
			FROM: T,
			ESCAPE: "$escape",
			EACH: "$each"
		}, t.exports = s
	}, function (t, e, i) {
		"use strict";
		var n = i(10),
			s = i(2).default,
			o = i(2).matchToToken,
			r = function (t) {
				return t.match(s).map(function (t) {
					return s.lastIndex = 0, o(s.exec(t))
				}).map(function (t) {
					return "name" === t.type && n(t.value) && (t.type = "keyword"), t
				})
			};
		t.exports = r
	}, function (t, e, i) {
		"use strict";
		var n = {
			abstract: !0,
			await: !0,
			boolean: !0,
			break: !0,
			byte: !0,
			case: !0,
			catch: !0,
			char: !0,
			class: !0,
			const: !0,
			continue: !0,
			debugger: !0,
			default: !0,
			delete: !0,
			do: !0,
			double: !0,
			else: !0,
			enum: !0,
			export: !0,
			extends: !0,
			false: !0,
			final: !0,
			finally: !0,
			float: !0,
			for: !0,
			function: !0,
			goto: !0,
			if: !0,
			implements: !0,
			import: !0,
			in: !0,
			instanceof: !0,
			int: !0,
			interface: !0,
			let: !0,
			long: !0,
			native: !0,
			new: !0,
			null: !0,
			package: !0,
			private: !0,
			protected: !0,
			public: !0,
			return: !0,
			short: !0,
			static: !0,
			super: !0,
			switch: !0,
			synchronized: !0,
			this: !0,
			throw: !0,
			transient: !0,
			true: !0,
			try: !0,
			typeof: !0,
			var: !0,
			void: !0,
			volatile: !0,
			while: !0,
			with: !0,
			yield: !0
		};
		t.exports = function (t) {
			return n.hasOwnProperty(t)
		}
	}, function (t, e, i) {
		"use strict";

		function x(t, e, i, n) {
			var s = new String(t);
			return s.line = e, s.start = i, s.end = n, s
		}
		var n = function (t, e) {
			for (var _ = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, y = [{
				type: "string",
				value: t,
				line: 0,
				start: 0,
				end: t.length
			}], i = 0; i < e.length; i++) ! function (t) {
				for (var e = t.test.ignoreCase ? "ig" : "g", i = t.test.source + "|^$|[\\w\\W]", n = new RegExp(i, e), s = 0; s < y.length; s++)
					if ("string" === y[s].type) {
						for (var o = y[s].line, r = y[s].start, a = y[s].end, l = y[s].value.match(n), h = [], c = 0; c < l.length; c++) {
							var u = l[c];
							t.test.lastIndex = 0;
							var d = t.test.exec(u),
								f = d ? "expression" : "string",
								p = h[h.length - 1],
								g = p || y[s],
								m = g.value;
							r = g.line === o ? p ? p.end : r : m.length - m.lastIndexOf("\n") - 1, a = r + u.length;
							var v = {
								type: f,
								value: u,
								line: o,
								start: r,
								end: a
							};
							if ("string" === f) p && "string" === p.type ? (p.value += u, p.end += u.length) : h.push(v);
							else {
								d[0] = new x(d[0], o, r, a);
								var b = t.use.apply(_, d);
								v.script = b, h.push(v)
							}
							o += u.split(/\n/).length - 1
						}
						y.splice.apply(y, [s, 1].concat(h)), s += h.length - 1
					}
			}(e[i]);
			return y
		};
		n.TYPE_STRING = "string", n.TYPE_EXPRESSION = "expression", n.TYPE_RAW = "raw", n.TYPE_ESCAPE = "escape", t.exports = n
	}, function (o, t, r) {
		"use strict";
		(function (t) {
			function e(t) {
				return "string" != typeof t && (t = void 0 === t || null === t ? "" : "function" == typeof t ? e(t.call(t)) : JSON.stringify(t)), t
			}

			function i(t) {
				var e = "" + t,
					i = a.exec(e);
				if (!i) return t;
				var n = "",
					s = void 0,
					o = void 0,
					r = void 0;
				for (s = i.index, o = 0; s < e.length; s++) {
					switch (e.charCodeAt(s)) {
						case 34:
							r = "&#34;";
							break;
						case 38:
							r = "&#38;";
							break;
						case 39:
							r = "&#39;";
							break;
						case 60:
							r = "&#60;";
							break;
						case 62:
							r = "&#62;";
							break;
						default:
							continue
					}
					o !== s && (n += e.substring(o, s)), o = s + 1, n += r
				}
				return o !== s ? n + e.substring(o, s) : n
			}
			var n = r(0),
				s = Object.create(n ? t : window),
				a = /["&'<>]/;
			s.$escape = function (t) {
				return i(e(t))
			}, s.$each = function (t, e) {
				if (Array.isArray(t))
					for (var i = 0, n = t.length; i < n; i++) e(t[i], i);
				else
					for (var s in t) e(t[s], s)
			}, o.exports = s
		}).call(t, r(4))
	}, function (t, e, i) {
		"use strict";
		var n = Object.prototype.toString,
			r = function (t) {
				return null === t ? "Null" : n.call(t).slice(8, -1)
			},
			s = function t(e, i) {
				var n = void 0,
					s = r(e);
				if ("Object" === s ? n = Object.create(i || {}) : "Array" === s && (n = [].concat(i || [])), n) {
					for (var o in e) e.hasOwnProperty(o) && (n[o] = t(e[o], n[o]));
					return n
				}
				return e
			};
		t.exports = s
	}, function (t, e, o) {
		"use strict";
		var i = function (t, e, i, n) {
			var s = o(1);
			return n = n.$extend({
				filename: n.resolveFilename(t, n),
				bail: !0,
				source: null
			}), s(n)(e, i)
		};
		t.exports = i
	}, function (t, e, i) {
		"use strict";
		var n = function (t) {
			console.error(t.name, t.message)
		};
		t.exports = n
	}, function (t, e, i) {
		"use strict";
		var n = {
			__data: Object.create(null),
			set: function (t, e) {
				this.__data[t] = e
			},
			get: function (t) {
				return this.__data[t]
			},
			reset: function () {
				this.__data = {}
			}
		};
		t.exports = n
	}, function (t, e, i) {
		"use strict";
		var n = i(0),
			s = function (t) {
				if (n) return i(5).readFileSync(t, "utf8");
				var e = document.getElementById(t);
				return e.value || e.innerHTML
			};
		t.exports = s
	}, function (t, e, i) {
		"use strict";
		var g = {
			test: /{{([@#]?)[ \t]*(\/?)([\w\W]*?)[ \t]*}}/,
			use: function (i, t, e, n) {
				var s = this,
					o = s.options,
					r = s.getEsTokens(n),
					a = r.map(function (t) {
						return t.value
					}),
					l = {},
					h = void 0,
					c = !!t && "raw",
					u = e + a.shift(),
					d = function (t, e) {
						console.warn((o.filename || "anonymous") + ":" + (i.line + 1) + ":" + (i.start + 1) + "\nTemplate upgrade: {{" + t + "}} -> {{" + e + "}}")
					};
				switch ("#" === t && d("#value", "@value"), u) {
					case "set":
						n = "var " + a.join("").trim();
						break;
					case "if":
						n = "if(" + a.join("").trim() + "){";
						break;
					case "else":
						var f = a.indexOf("if");
						~f ? (a.splice(0, f + 1), n = "}else if(" + a.join("").trim() + "){") : n = "}else{";
						break;
					case "/if":
						n = "}";
						break;
					case "each":
						h = g._split(r), h.shift(), "as" === h[1] && (d("each object as value index", "each object value index"), h.splice(1, 1)), n = "$each(" + (h[0] || "$data") + ",function(" + (h[1] || "$value") + "," + (h[2] || "$index") + "){";
						break;
					case "/each":
						n = "})";
						break;
					case "block":
						h = g._split(r), h.shift(), n = "block(" + h.join(",").trim() + ",function(){";
						break;
					case "/block":
						n = "})";
						break;
					case "echo":
						u = "print", d("echo value", "value");
					case "print":
					case "include":
					case "extend":
						if (0 !== a.join("").trim().indexOf("(")) {
							h = g._split(r), h.shift(), n = u + "(" + h.join(",") + ")";
							break
						}
					default:
						if (~a.indexOf("|")) {
							var p = r.reduce(function (t, e) {
								var i = e.value,
									n = e.type;
								return "|" === i ? t.push([]) : "whitespace" !== n && "comment" !== n && (t.length || t.push([]), ":" === i && 1 === t[t.length - 1].length ? d("value | filter: argv", "value | filter argv") : t[t.length - 1].push(e)), t
							}, []).map(function (t) {
								return g._split(t)
							});
							n = p.reduce(function (t, e) {
								var i = e.shift();
								return e.unshift(t), "$imports." + i + "(" + e.join(",") + ")"
							}, p.shift().join(" ").trim())
						}
						c = c || "escape"
				}
				return l.code = n, l.output = c, l
			},
			_split: function (t) {
				t = t.filter(function (t) {
					var e = t.type;
					return "whitespace" !== e && "comment" !== e
				});
				for (var e = 0, i = t.shift(), n = /\]|\)/, s = [
					[i]
				]; e < t.length;) {
					var o = t[e];
					"punctuator" === o.type || "punctuator" === i.type && !n.test(i.value) ? s[s.length - 1].push(o) : s.push([o]), i = o, e++
				}
				return s.map(function (t) {
					return t.map(function (t) {
						return t.value
					}).join("")
				})
			}
		};
		t.exports = g
	}, function (t, e, i) {
		"use strict";
		var n = {
			test: /<%(#?)((?:==|=#|[=-])?)[ \t]*([\w\W]*?)[ \t]*(-?)%>/,
			use: function (t, e, i, n) {
				return i = {
					"-": "raw",
					"=": "escape",
					"": !1,
					"==": "raw",
					"=#": "raw"
				}[i], e && (n = "/*" + n + "*/", i = !1), {
					code: n,
					output: i
				}
			}
		};
		t.exports = n
	}, function (t, e, r) {
		"use strict";
		var a = r(0),
			i = function (t, e) {
				if (a) {
					var i, n = r(21).minify,
						s = e.htmlMinifierOptions,
						o = e.rules.map(function (t) {
							return t.test
						});
					(i = s.ignoreCustomFragments).push.apply(i, o), t = n(t, s)
				}
				return t
			};
		t.exports = i
	}, function (t, e) {
		! function (t) {
			t.noop = function () { }
		}("object" == typeof t && "object" == typeof t.exports ? t.exports : window)
	}, function (t, e, l) {
		"use strict";
		var h = l(0),
			c = /^\.+\//,
			i = function (t, e) {
				if (h) {
					var i = l(5),
						n = e.root,
						s = e.extname;
					if (c.test(t)) {
						var o = e.filename,
							r = !o || t === o,
							a = r ? n : i.dirname(o);
						t = i.resolve(a, t)
					} else t = i.resolve(n, t);
					i.extname(t) || (t += s)
				}
				return t
			};
		t.exports = i
	}, function (t, e, i) {
		"use strict";

		function s(t, e) {
			if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
		}

		function o(t, e) {
			if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			return !e || "object" != typeof e && "function" != typeof e ? t : e
		}

		function r(t, e) {
			if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
			t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
		}

		function a(t) {
			var e = t.name,
				i = t.source,
				n = t.path,
				s = t.line,
				o = t.column,
				r = t.generated,
				a = t.message;
			if (!i) return a;
			var l = i.split(/\n/),
				h = Math.max(s - 3, 0),
				c = Math.min(l.length, s + 3),
				u = l.slice(h, c).map(function (t, e) {
					var i = e + h + 1;
					return (i === s ? " >> " : "    ") + i + "| " + t
				}).join("\n");
			return (n || "anonymous") + ":" + s + ":" + o + "\n" + u + "\n\n" + e + ": " + a + (r ? "\n   generated: " + r : "")
		}
		var n = function (i) {
			function n(t) {
				s(this, n);
				var e = o(this, i.call(this, t.message));
				return e.name = "TemplateError", e.message = a(t), Error.captureStackTrace && Error.captureStackTrace(e, e.constructor), e
			}
			return r(n, i), n
		}(Error);
		t.exports = n
	}, function (t, e, i) {
		"use strict";
		t.exports = i(3)
	}])
});
! function (n) {
	var s = "undefined" != typeof window,
		o = s ? window : this,
		t = function () {
			return n(s, o)
		};
	"undefined" != typeof define && define.amd ? define("IDValidator", [], t) : "function" == typeof define && define.cmd ? define(function (t, e, i) {
		i.exports = n(s, o)
	}) : "undefined" != typeof module && module.exports ? module.exports = n(s, o) : o.IDValidator = n(s, o)
}(function (t, e) {
	var s = {
		error: {
			longNumber: "长数字存在精度问题，请使用字符串传值！ Long number is not allowed, because the precision of the Number In JavaScript."
		}
	},
		_ = {
			checkArg: function (t, e) {
				var i = typeof t;
				switch (i) {
					case "number":
						if (t = t.toString(), t.length > 15) return this.error(s.error.longNumber), !1;
						break;
					case "string":
						break;
					default:
						return !1
				}
				if (t = t.toUpperCase(), e && !isNaN(e) && (e = parseInt(e), t.length !== e)) return !1;
				var n = null;
				if (18 === t.length) n = {
					body: t.slice(0, 17),
					checkBit: t.slice(-1),
					type: 18
				};
				else {
					if (15 !== t.length) return !1;
					n = {
						body: t,
						type: 15
					}
				}
				return n
			},
			checkAddr: function (t, e) {
				var i = this.getAddrInfo(t, e);
				return i !== !1
			},
			getAddrInfo: function (t, e) {
				if (e = e || null, null === e) return t;
				if (e.hasOwnProperty(t)) return e[t];
				var i;
				return i = t.slice(0, 4) + "00", e.hasOwnProperty(i) ? e[i] + "未知地区" : (i = t.slice(0, 2) + "0000", e.hasOwnProperty(i) ? e[i] + "未知地区" : !1)
			},
			checkBirth: function (t) {
				var e, i, n;
				if (8 == t.length) e = parseInt(t.slice(0, 4), 10), i = parseInt(t.slice(4, 6), 10), n = parseInt(t.slice(-2), 10);
				else {
					if (6 != t.length) return !1;
					e = parseInt("19" + t.slice(0, 2), 10), i = parseInt(t.slice(2, 4), 10), n = parseInt(t.slice(-2), 10)
				}
				return !(i > 12 || 0 === i || n > 31 || 0 === n)
			},
			checkOrder: function (t) {
				return !0
			},
			weight: function (t) {
				return Math.pow(2, t - 1) % 11
			},
			rand: function (t, e) {
				return e = e || 1, Math.round(Math.random() * (t - e)) + e
			},
			str_pad: function (t, e, i, n) {
				if (t = t.toString(), e = e || 2, i = i || "0", n = n || !1, t.length >= e) return t;
				for (var s = 0, o = e - t.length; o > s; s++) n ? t += i : t = i + t;
				return t
			},
			error: function (t) {
				var e = new Error;
				throw e.message = "IDValidator: " + t, e
			}
		},
		i = function (t) {
			"undefined" != typeof t && (this.GB2260 = t), this.cache = {}
		};
	return i.prototype = {
		isValid: function (t, e) {
			var i = this.GB2260 || null,
				n = _.checkArg(t, e);
			if (n === !1) return !1;
			if (this.cache.hasOwnProperty(t) && "undefined" != typeof this.cache[t].valid) return this.cache[t].valid;
			this.cache.hasOwnProperty(t) || (this.cache[t] = {});
			var s = n.body.slice(0, 6),
				o = 18 === n.type ? n.body.slice(6, 14) : n.body.slice(6, 12),
				r = n.body.slice(-3);
			if (!(_.checkAddr(s, i) && _.checkBirth(o) && _.checkOrder(r))) return this.cache[t].valid = !1, !1;
			if (15 === n.type) return this.cache[t].valid = !0, !0;
			for (var a = [], l = 18; l > 1; l--) {
				var h = _.weight(l);
				a[l] = h
			}
			for (var c = 0, u = n.body.split(""), d = 0; d < u.length; d++) c += parseInt(u[d], 10) * a[18 - d];
			var f = 12 - c % 11;
			return 10 == f ? f = "X" : f > 10 && (f %= 11), f = "number" == typeof f ? f.toString() : f, f !== n.checkBit ? (this.cache[t].valid = !1, !1) : (this.cache[t].valid = !0, !0)
		},
		getInfo: function (t, e) {
			var i = this.GB2260 || null;
			if (this.isValid(t, e) === !1) return !1;
			var n = _.checkArg(t);
			if ("undefined" != typeof this.cache[t].info) return this.cache[t].info;
			var s = n.body.slice(0, 6),
				o = 18 === n.type ? n.body.slice(6, 14) : n.body.slice(6, 12),
				r = n.body.slice(-3),
				a = {};
			return a.addrCode = s, null !== i && (a.addr = _.getAddrInfo(s, i)), a.birth = 18 === n.type ? [o.slice(0, 4), o.slice(4, 6), o.slice(-2)].join("-") : ["19" + o.slice(0, 2), o.slice(2, 4), o.slice(-2)].join("-"), a.sex = r % 2 === 0 ? 0 : 1, a.length = n.type, 18 === n.type && (a.checkBit = n.checkBit), this.cache[t].info = a, a
		},
		makeID: function (t) {
			var e = this.GB2260 || null,
				i = null;
			if (null !== e)
				for (var n = 0; null === i;) {
					if (n > 10) {
						i = 110101;
						break
					}
					var s = _.str_pad(_.rand(50), 2, "0"),
						o = _.str_pad(_.rand(20), 2, "0"),
						r = _.str_pad(_.rand(20), 2, "0"),
						a = [s, o, r].join("");
					if (e[a]) {
						i = a;
						break
					}
				} else i = 110101;
			var l = _.str_pad(_.rand(99, 50), 2, "0"),
				h = _.str_pad(_.rand(12, 1), 2, "0"),
				c = _.str_pad(_.rand(28, 1), 2, "0");
			if (t) return i + l + h + c + _.str_pad(_.rand(999, 1), 3, "1");
			l = "19" + l;
			for (var u = i + l + h + c + _.str_pad(_.rand(999, 1), 3, "1"), d = [], f = 18; f > 1; f--) {
				var p = _.weight(f);
				d[f] = p
			}
			for (var g = 0, m = u.split(""), v = 0; v < m.length; v++) g += parseInt(m[v], 10) * d[18 - v];
			var b = 12 - g % 11;
			return 10 == b ? b = "X" : b > 10 && (b %= 11), b = "number" == typeof b ? b.toString() : b, u + b
		}
	}, i
});
! function (n) {
	var t = "undefined" != typeof window,
		e = t ? window : this;
	"undefined" != typeof define && define.amd ? define([], n()) : "function" == typeof define && define.cmd ? define(function (t, e, i) {
		i.exports = n()
	}) : "undefined" != typeof module && module.exports ? module.exports = n() : e.GB2260 = n()
}(function () {
	var t = {
		11e4: "北京市",
		110100: "北京市市辖区",
		110101: "北京市东城区",
		110102: "北京市西城区",
		110103: "北京市崇文区",
		110104: "北京市宣武区",
		110105: "北京市朝阳区",
		110106: "北京市丰台区",
		110107: "北京市石景山区",
		110108: "北京市海淀区",
		110109: "北京市门头沟区",
		110111: "北京市房山区",
		110112: "北京市通州区",
		110113: "北京市顺义区",
		110200: "北京市县",
		110221: "北京市昌平县",
		110224: "北京市大兴县",
		110226: "北京市平谷县",
		110227: "北京市怀柔县",
		110228: "北京市密云县",
		110229: "北京市延庆县",
		12e4: "天津市",
		120100: "天津市市辖区",
		120101: "天津市和平区",
		120102: "天津市河东区",
		120103: "天津市河西区",
		120104: "天津市南开区",
		120105: "天津市河北区",
		120106: "天津市红桥区",
		120107: "天津市塘沽区",
		120108: "天津市汉沽区",
		120109: "天津市大港区",
		120110: "天津市东丽区",
		120111: "天津市西青区",
		120112: "天津市津南区",
		120113: "天津市北辰区",
		120200: "天津市县",
		120221: "天津市宁河县",
		120222: "天津市武清县",
		120223: "天津市静海县",
		120224: "天津市宝坻县",
		120225: "天津市蓟县",
		13e4: "河北省",
		130100: "河北省石家庄市",
		130101: "河北省石家庄市市辖区",
		130102: "河北省石家庄市长安区",
		130103: "河北省石家庄市桥东区",
		130104: "河北省石家庄市桥西区",
		130105: "河北省石家庄市新华区",
		130106: "河北省石家庄市郊区",
		130107: "河北省石家庄市井陉矿区",
		130121: "河北省石家庄市井陉县",
		130123: "河北省石家庄市正定县",
		130124: "河北省石家庄市栾城县",
		130125: "河北省石家庄市行唐县",
		130126: "河北省石家庄市灵寿县",
		130127: "河北省石家庄市高邑县",
		130128: "河北省石家庄市深泽县",
		130129: "河北省石家庄市赞皇县",
		130130: "河北省石家庄市无极县",
		130131: "河北省石家庄市平山县",
		130132: "河北省石家庄市元氏县",
		130133: "河北省石家庄市赵县",
		130181: "河北省石家庄市辛集市",
		130182: "河北省石家庄市藁城市",
		130183: "河北省石家庄市晋州市",
		130184: "河北省石家庄市新乐市",
		130185: "河北省石家庄市鹿泉市",
		130200: "河北省唐山市",
		130201: "河北省唐山市市辖区",
		130202: "河北省唐山市路南区",
		130203: "河北省唐山市路北区",
		130204: "河北省唐山市古冶区",
		130205: "河北省唐山市开平区",
		130206: "河北省唐山市新区",
		130221: "河北省唐山市丰润县",
		130223: "河北省唐山市滦县",
		130224: "河北省唐山市滦南县",
		130225: "河北省唐山市乐亭县",
		130227: "河北省唐山市迁西县",
		130229: "河北省唐山市玉田县",
		130230: "河北省唐山市唐海县",
		130281: "河北省唐山市遵化市",
		130282: "河北省唐山市丰南市",
		130283: "河北省唐山市迁安市",
		130300: "河北省秦皇岛市秦皇岛市",
		130301: "河北省秦皇岛市市辖区",
		130302: "河北省秦皇岛市海港区",
		130303: "河北省秦皇岛市山海关区",
		130304: "河北省秦皇岛市北戴河区",
		130321: "河北省秦皇岛市青龙满族自治县",
		130322: "河北省秦皇岛市昌黎县",
		130323: "河北省秦皇岛市抚宁县",
		130324: "河北省秦皇岛市卢龙县",
		130400: "河北省邯郸市邯郸市",
		130401: "河北省邯郸市市辖区",
		130402: "河北省邯郸市邯山区",
		130403: "河北省邯郸市丛台区",
		130404: "河北省邯郸市复兴区",
		130406: "河北省邯郸市峰峰矿区",
		130421: "河北省邯郸市邯郸县",
		130423: "河北省邯郸市临漳县",
		130424: "河北省邯郸市成安县",
		130425: "河北省邯郸市大名县",
		130426: "河北省邯郸市涉县",
		130427: "河北省邯郸市磁县",
		130428: "河北省邯郸市肥乡县",
		130429: "河北省邯郸市永年县",
		130430: "河北省邯郸市邱县",
		130431: "河北省邯郸市鸡泽县",
		130432: "河北省邯郸市广平县",
		130433: "河北省邯郸市馆陶县",
		130434: "河北省邯郸市魏县",
		130435: "河北省邯郸市曲周县",
		130481: "河北省邯郸市武安市",
		130500: "河北省邢台市",
		130501: "河北省邢台市市辖区",
		130502: "河北省邢台市桥东区",
		130503: "河北省邢台市桥西区",
		130521: "河北省邢台市邢台县",
		130522: "河北省邢台市临城县",
		130523: "河北省邢台市内丘县",
		130524: "河北省邢台市柏乡县",
		130525: "河北省邢台市隆尧县",
		130526: "河北省邢台市任县",
		130527: "河北省邢台市南和县",
		130528: "河北省邢台市宁晋县",
		130529: "河北省邢台市巨鹿县",
		130530: "河北省邢台市新河县",
		130531: "河北省邢台市广宗县",
		130532: "河北省邢台市平乡县",
		130533: "河北省邢台市威县",
		130534: "河北省邢台市清河县",
		130535: "河北省邢台市临西县",
		130581: "河北省邢台市南宫市",
		130582: "河北省邢台市沙河市",
		130600: "河北省保定市",
		130601: "河北省保定市市辖区",
		130602: "河北省保定市新市区",
		130603: "河北省保定市北市区",
		130604: "河北省保定市南市区",
		130621: "河北省保定市满城县",
		130622: "河北省保定市清苑县",
		130623: "河北省保定市涞水县",
		130624: "河北省保定市阜平县",
		130625: "河北省保定市徐水县",
		130626: "河北省保定市定兴县",
		130627: "河北省保定市唐县",
		130628: "河北省保定市高阳县",
		130629: "河北省保定市容城县",
		130630: "河北省保定市涞源县",
		130631: "河北省保定市望都县",
		130632: "河北省保定市安新县",
		130633: "河北省保定市易县",
		130634: "河北省保定市曲阳县",
		130635: "河北省保定市蠡县",
		130636: "河北省保定市顺平县",
		130637: "河北省保定市博野县",
		130638: "河北省保定市雄县",
		130681: "河北省保定市涿州市",
		130682: "河北省保定市定州市",
		130683: "河北省保定市安国市",
		130684: "河北省保定市高碑店市",
		130700: "河北省张家口市",
		130701: "河北省张家口市市辖区",
		130702: "河北省张家口市桥东区",
		130703: "河北省张家口市桥西区",
		130705: "河北省张家口市宣化区",
		130706: "河北省张家口市下花园区",
		130721: "河北省张家口市宣化县",
		130722: "河北省张家口市张北县",
		130723: "河北省张家口市康保县",
		130724: "河北省张家口市沽源县",
		130725: "河北省张家口市尚义县",
		130726: "河北省张家口市蔚县",
		130727: "河北省张家口市阳原县",
		130728: "河北省张家口市怀安县",
		130729: "河北省张家口市万全县",
		130730: "河北省张家口市怀来县",
		130731: "河北省张家口市涿鹿县",
		130732: "河北省张家口市赤城县",
		130733: "河北省张家口市崇礼县",
		130800: "河北省承德市",
		130801: "河北省承德市市辖区",
		130802: "河北省承德市双桥区",
		130803: "河北省承德市双滦区",
		130804: "河北省承德市鹰手营子矿区",
		130821: "河北省承德市承德县",
		130822: "河北省承德市兴隆县",
		130823: "河北省承德市平泉县",
		130824: "河北省承德市滦平县",
		130825: "河北省承德市隆化县",
		130826: "河北省承德市丰宁满族自治县",
		130827: "河北省承德市宽城满族自治县",
		130828: "河北省承德市围场满族蒙古族自治县",
		130900: "河北省沧州市",
		130901: "河北省沧州市市辖区",
		130902: "河北省沧州市新华区",
		130903: "河北省沧州市运河区",
		130921: "河北省沧州市沧县",
		130922: "河北省沧州市青县",
		130923: "河北省沧州市东光县",
		130924: "河北省沧州市海兴县",
		130925: "河北省沧州市盐山县",
		130926: "河北省沧州市肃宁县",
		130927: "河北省沧州市南皮县",
		130928: "河北省沧州市吴桥县",
		130929: "河北省沧州市献县",
		130930: "河北省沧州市孟村回族自治县",
		130981: "河北省沧州市泊头市",
		130982: "河北省沧州市任丘市",
		130983: "河北省沧州市黄骅市",
		130984: "河北省沧州市河间市",
		131e3: "河北省廊坊市",
		131001: "河北省廊坊市市辖区",
		131002: "河北省廊坊市安次区",
		131022: "河北省廊坊市固安县",
		131023: "河北省廊坊市永清县",
		131024: "河北省廊坊市香河县",
		131025: "河北省廊坊市大城县",
		131026: "河北省廊坊市文安县",
		131028: "河北省廊坊市大厂回族自治县",
		131081: "河北省廊坊市霸州市",
		131082: "河北省廊坊市三河市",
		131100: "河北省衡水市",
		131101: "河北省衡水市市辖区",
		131102: "河北省衡水市桃城区",
		131121: "河北省衡水市枣强县",
		131122: "河北省衡水市武邑县",
		131123: "河北省衡水市武强县",
		131124: "河北省衡水市饶阳县",
		131125: "河北省衡水市安平县",
		131126: "河北省衡水市故城县",
		131127: "河北省衡水市景县",
		131128: "河北省衡水市阜城县",
		131181: "河北省衡水市冀州市",
		131182: "河北省衡水市深州市",
		14e4: "山西省",
		140100: "山西省太原市",
		140101: "山西省太原市市辖区",
		140105: "山西省太原市小店区",
		140106: "山西省太原市迎泽区",
		140107: "山西省太原市杏花岭区",
		140108: "山西省太原市尖草坪区",
		140109: "山西省太原市万柏林区",
		140110: "山西省太原市晋源区",
		140121: "山西省太原市清徐县",
		140122: "山西省太原市阳曲县",
		140123: "山西省太原市娄烦县",
		140181: "山西省太原市古交市",
		140200: "山西省大同市",
		140201: "山西省大同市市辖区",
		140202: "山西省大同市城区",
		140203: "山西省大同市矿区",
		140211: "山西省大同市南郊区",
		140212: "山西省大同市新荣区",
		140221: "山西省大同市阳高县",
		140222: "山西省大同市天镇县",
		140223: "山西省大同市广灵县",
		140224: "山西省大同市灵丘县",
		140225: "山西省大同市浑源县",
		140226: "山西省大同市左云县",
		140227: "山西省大同市大同县",
		140300: "山西省阳泉市",
		140301: "山西省阳泉市市辖区",
		140302: "山西省阳泉市城区",
		140303: "山西省阳泉市矿区",
		140311: "山西省阳泉市郊区",
		140321: "山西省阳泉市平定县",
		140322: "山西省阳泉市盂县",
		140400: "山西省长治市",
		140401: "山西省长治市市辖区",
		140402: "山西省长治市城区",
		140411: "山西省长治市郊区",
		140421: "山西省长治市长治县",
		140423: "山西省长治市襄垣县",
		140424: "山西省长治市屯留县",
		140425: "山西省长治市平顺县",
		140426: "山西省长治市黎城县",
		140427: "山西省长治市壶关县",
		140428: "山西省长治市长子县",
		140429: "山西省长治市武乡县",
		140430: "山西省长治市沁县",
		140431: "山西省长治市沁源县",
		140481: "山西省长治市潞城市",
		140500: "山西省晋城市",
		140501: "山西省晋城市市辖区",
		140502: "山西省晋城市城区",
		140521: "山西省晋城市沁水县",
		140522: "山西省晋城市阳城县",
		140524: "山西省晋城市陵川县",
		140525: "山西省晋城市泽州县",
		140581: "山西省晋城市高平市",
		140600: "山西省晋城市朔州市",
		140601: "山西省晋城市市辖区",
		140602: "山西省晋城市朔城区",
		140603: "山西省晋城市平鲁区",
		140621: "山西省晋城市山阴县",
		140622: "山西省晋城市应县",
		140623: "山西省晋城市右玉县",
		140624: "山西省晋城市怀仁县",
		142200: "山西省忻州地区",
		142201: "山西省忻州地区忻州市",
		142202: "山西省忻州地区原平市",
		142222: "山西省忻州地区定襄县",
		142223: "山西省忻州地区五台县",
		142225: "山西省忻州地区代县",
		142226: "山西省忻州地区繁峙县",
		142227: "山西省忻州地区宁武县",
		142228: "山西省忻州地区静乐县",
		142229: "山西省忻州地区神池县",
		142230: "山西省忻州地区五寨县",
		142231: "山西省忻州地区岢岚县",
		142232: "山西省忻州地区河曲县",
		142233: "山西省忻州地区保德县",
		142234: "山西省忻州地区偏关县",
		142300: "山西省忻州地区吕梁地区",
		142301: "山西省忻州地区孝义市",
		142302: "山西省忻州地区离石市",
		142303: "山西省忻州地区汾阳市",
		142322: "山西省忻州地区文水县",
		142323: "山西省忻州地区交城县",
		142325: "山西省忻州地区兴县",
		142326: "山西省忻州地区临县",
		142327: "山西省忻州地区柳林县",
		142328: "山西省忻州地区石楼县",
		142329: "山西省忻州地区岚县",
		142330: "山西省忻州地区方山县",
		142332: "山西省忻州地区中阳县",
		142333: "山西省忻州地区交口县",
		142400: "山西省晋中地区",
		142401: "山西省晋中地区榆次市",
		142402: "山西省晋中地区介休市",
		142421: "山西省晋中地区榆社县",
		142422: "山西省晋中地区左权县",
		142423: "山西省晋中地区和顺县",
		142424: "山西省晋中地区昔阳县",
		142427: "山西省晋中地区寿阳县",
		142429: "山西省晋中地区太谷县",
		142430: "山西省晋中地区祁县",
		142431: "山西省晋中地区平遥县",
		142433: "山西省晋中地区灵石县",
		142600: "山西省临汾地区",
		142601: "山西省临汾地区临汾市",
		142602: "山西省临汾地区侯马市",
		142603: "山西省临汾地区霍州市",
		142621: "山西省临汾地区曲沃县",
		142622: "山西省临汾地区翼城县",
		142623: "山西省临汾地区襄汾县",
		142625: "山西省临汾地区洪洞县",
		142627: "山西省临汾地区古县",
		142628: "山西省临汾地区安泽县",
		142629: "山西省临汾地区浮山县",
		142630: "山西省临汾地区吉县",
		142631: "山西省临汾地区乡宁县",
		142632: "山西省临汾地区蒲县",
		142633: "山西省临汾地区大宁县",
		142634: "山西省临汾地区永和县",
		142635: "山西省临汾地区隰县",
		142636: "山西省临汾地区汾西县",
		142700: "山西省运城地区",
		142701: "山西省运城地区运城市",
		142702: "山西省运城地区永济市",
		142703: "山西省运城地区河津市",
		142723: "山西省运城地区芮城县",
		142724: "山西省运城地区临猗县",
		142725: "山西省运城地区万荣县",
		142726: "山西省运城地区新绛县",
		142727: "山西省运城地区稷山县",
		142729: "山西省运城地区闻喜县",
		142730: "山西省运城地区夏县",
		142731: "山西省运城地区绛县",
		142732: "山西省运城地区平陆县",
		142733: "山西省运城地区垣曲县",
		15e4: "内蒙古自治区",
		150100: "内蒙古自治区呼和浩特市",
		150101: "内蒙古自治区呼和浩特市市辖区",
		150102: "内蒙古自治区呼和浩特市新城区",
		150103: "内蒙古自治区呼和浩特市回民区",
		150104: "内蒙古自治区呼和浩特市玉泉区",
		150105: "内蒙古自治区呼和浩特市郊区",
		150121: "内蒙古自治区呼和浩特市土默特左旗",
		150122: "内蒙古自治区呼和浩特市托克托县",
		150123: "内蒙古自治区呼和浩特市和林格尔县",
		150124: "内蒙古自治区呼和浩特市清水河县",
		150125: "内蒙古自治区呼和浩特市武川县",
		150200: "内蒙古自治区包头市",
		150201: "内蒙古自治区包头市市辖区",
		150202: "内蒙古自治区包头市东河区",
		150203: "内蒙古自治区包头市昆都伦区",
		150204: "内蒙古自治区包头市青山区",
		150205: "内蒙古自治区包头市石拐矿区",
		150206: "内蒙古自治区包头市白云矿区",
		150207: "内蒙古自治区包头市郊区",
		150221: "内蒙古自治区包头市土默特右旗",
		150222: "内蒙古自治区包头市固阳县",
		150223: "内蒙古自治区包头市达尔罕茂明安联合旗",
		150300: "内蒙古自治区乌海市",
		150301: "内蒙古自治区乌海市市辖区",
		150302: "内蒙古自治区乌海市海勃湾区",
		150303: "内蒙古自治区乌海市海南区",
		150304: "内蒙古自治区乌海市乌达区",
		150400: "内蒙古自治区赤峰市",
		150401: "内蒙古自治区赤峰市市辖区",
		150402: "内蒙古自治区赤峰市红山区",
		150403: "内蒙古自治区赤峰市元宝山区",
		150404: "内蒙古自治区赤峰市松山区",
		150421: "内蒙古自治区赤峰市阿鲁科尔沁旗",
		150422: "内蒙古自治区赤峰市巴林左旗",
		150423: "内蒙古自治区赤峰市巴林右旗",
		150424: "内蒙古自治区赤峰市林西县",
		150425: "内蒙古自治区赤峰市克什克腾旗",
		150426: "内蒙古自治区赤峰市翁牛特旗",
		150428: "内蒙古自治区赤峰市喀喇沁旗",
		150429: "内蒙古自治区赤峰市宁城县",
		150430: "内蒙古自治区赤峰市敖汉旗",
		152100: "内蒙古自治区呼伦贝尔盟",
		152101: "内蒙古自治区呼伦贝尔盟海拉尔市",
		152102: "内蒙古自治区呼伦贝尔盟满洲里市",
		152103: "内蒙古自治区呼伦贝尔盟扎兰屯市",
		152104: "内蒙古自治区呼伦贝尔盟牙克石市",
		152105: "内蒙古自治区呼伦贝尔盟根河市",
		152106: "内蒙古自治区呼伦贝尔盟额尔古纳市",
		152122: "内蒙古自治区呼伦贝尔盟阿荣旗",
		152123: "内蒙古自治区呼伦贝尔盟莫力达瓦达斡尔族自治旗",
		152127: "内蒙古自治区呼伦贝尔盟鄂伦春自治旗",
		152128: "内蒙古自治区呼伦贝尔盟鄂温克族自治旗",
		152129: "内蒙古自治区呼伦贝尔盟新巴尔虎右旗",
		152130: "内蒙古自治区呼伦贝尔盟新巴尔虎左旗",
		152131: "内蒙古自治区呼伦贝尔盟陈巴尔虎旗",
		152200: "内蒙古自治区兴安盟",
		152201: "内蒙古自治区兴安盟乌兰浩特市",
		152202: "内蒙古自治区兴安盟阿尔山市",
		152221: "内蒙古自治区兴安盟科尔沁右翼前旗",
		152222: "内蒙古自治区兴安盟科尔沁右翼中旗",
		152223: "内蒙古自治区兴安盟扎赉特旗",
		152224: "内蒙古自治区兴安盟突泉县",
		152300: "内蒙古自治区哲里木盟",
		152301: "内蒙古自治区哲里木盟通辽市",
		152302: "内蒙古自治区哲里木盟霍林郭勒市",
		152322: "内蒙古自治区哲里木盟科尔沁左翼中旗",
		152323: "内蒙古自治区哲里木盟科尔沁左翼后旗",
		152324: "内蒙古自治区哲里木盟开鲁县",
		152325: "内蒙古自治区哲里木盟库伦旗",
		152326: "内蒙古自治区哲里木盟奈曼旗",
		152327: "内蒙古自治区哲里木盟扎鲁特旗",
		152500: "内蒙古自治区锡林郭勒盟",
		152501: "内蒙古自治区锡林郭勒盟二连浩特市",
		152502: "内蒙古自治区锡林郭勒盟锡林浩特市",
		152522: "内蒙古自治区锡林郭勒盟阿巴嘎旗",
		152523: "内蒙古自治区锡林郭勒盟苏尼特左旗",
		152524: "内蒙古自治区锡林郭勒盟苏尼特右旗",
		152525: "内蒙古自治区锡林郭勒盟东乌珠穆沁旗",
		152526: "内蒙古自治区锡林郭勒盟西乌珠穆沁旗",
		152527: "内蒙古自治区锡林郭勒盟太仆寺旗",
		152528: "内蒙古自治区锡林郭勒盟镶黄旗",
		152529: "内蒙古自治区锡林郭勒盟正镶白旗",
		152530: "内蒙古自治区锡林郭勒盟正蓝旗",
		152531: "内蒙古自治区锡林郭勒盟多伦县",
		152600: "内蒙古自治区乌兰察布盟",
		152601: "内蒙古自治区乌兰察布盟集宁市",
		152602: "内蒙古自治区乌兰察布盟丰镇市",
		152624: "内蒙古自治区乌兰察布盟卓资县",
		152625: "内蒙古自治区乌兰察布盟化德县",
		152626: "内蒙古自治区乌兰察布盟商都县",
		152627: "内蒙古自治区乌兰察布盟兴和县",
		152629: "内蒙古自治区乌兰察布盟凉城县",
		152630: "内蒙古自治区乌兰察布盟察哈尔右翼前旗",
		152631: "内蒙古自治区乌兰察布盟察哈尔右翼中旗",
		152632: "内蒙古自治区乌兰察布盟察哈尔右翼后旗",
		152634: "内蒙古自治区乌兰察布盟四子王旗",
		152700: "内蒙古自治区伊克昭盟",
		152701: "内蒙古自治区伊克昭盟东胜市",
		152722: "内蒙古自治区伊克昭盟达拉特旗",
		152723: "内蒙古自治区伊克昭盟准格尔旗",
		152724: "内蒙古自治区伊克昭盟鄂托克前旗",
		152725: "内蒙古自治区伊克昭盟鄂托克旗",
		152726: "内蒙古自治区伊克昭盟杭锦旗",
		152727: "内蒙古自治区伊克昭盟乌审旗",
		152728: "内蒙古自治区伊克昭盟伊金霍洛旗",
		152800: "内蒙古自治区巴彦淖尔盟",
		152801: "内蒙古自治区巴彦淖尔盟临河市",
		152822: "内蒙古自治区巴彦淖尔盟五原县",
		152823: "内蒙古自治区巴彦淖尔盟磴口县",
		152824: "内蒙古自治区巴彦淖尔盟乌拉特前旗",
		152825: "内蒙古自治区巴彦淖尔盟乌拉特中旗",
		152826: "内蒙古自治区巴彦淖尔盟乌拉特后旗",
		152827: "内蒙古自治区巴彦淖尔盟杭锦后旗",
		152900: "内蒙古自治区阿拉善盟",
		152921: "内蒙古自治区阿拉善盟阿拉善左旗",
		152922: "内蒙古自治区阿拉善盟阿拉善右旗",
		152923: "内蒙古自治区阿拉善盟额济纳旗",
		21e4: "辽宁省",
		210100: "辽宁省沈阳市",
		210101: "辽宁省沈阳市市辖区",
		210102: "辽宁省沈阳市和平区",
		210103: "辽宁省沈阳市沈河区",
		210104: "辽宁省沈阳市大东区",
		210105: "辽宁省沈阳市皇姑区",
		210106: "辽宁省沈阳市铁西区",
		210111: "辽宁省沈阳市苏家屯区",
		210112: "辽宁省沈阳市东陵区",
		210113: "辽宁省沈阳市新城子区",
		210114: "辽宁省沈阳市于洪区",
		210122: "辽宁省沈阳市辽中县",
		210123: "辽宁省沈阳市康平县",
		210124: "辽宁省沈阳市法库县",
		210181: "辽宁省沈阳市新民市",
		210200: "辽宁省大连市",
		210201: "辽宁省大连市市辖区",
		210202: "辽宁省大连市中山区",
		210203: "辽宁省大连市西岗区",
		210204: "辽宁省大连市沙河口区",
		210211: "辽宁省大连市甘井子区",
		210212: "辽宁省大连市旅顺口区",
		210213: "辽宁省大连市金州区",
		210224: "辽宁省大连市长海县",
		210281: "辽宁省大连市瓦房店市",
		210282: "辽宁省大连市普兰店市",
		210283: "辽宁省大连市庄河市",
		210300: "辽宁省鞍山市",
		210301: "辽宁省鞍山市市辖区",
		210302: "辽宁省鞍山市铁东区",
		210303: "辽宁省鞍山市铁西区",
		210304: "辽宁省鞍山市立山区",
		210311: "辽宁省鞍山市千山区",
		210321: "辽宁省鞍山市台安县",
		210323: "辽宁省鞍山市岫岩满族自治县",
		210381: "辽宁省鞍山市海城市",
		210400: "辽宁省抚顺市",
		210401: "辽宁省抚顺市市辖区",
		210402: "辽宁省抚顺市新抚区",
		210403: "辽宁省抚顺市露天区",
		210404: "辽宁省抚顺市望花区",
		210411: "辽宁省抚顺市顺城区",
		210421: "辽宁省抚顺市抚顺县",
		210422: "辽宁省抚顺市新宾满族自治县",
		210423: "辽宁省抚顺市清原满族自治县",
		210500: "辽宁省本溪市",
		210501: "辽宁省本溪市市辖区",
		210502: "辽宁省本溪市平山区",
		210503: "辽宁省本溪市溪湖区",
		210504: "辽宁省本溪市明山区",
		210505: "辽宁省本溪市南芬区",
		210521: "辽宁省本溪市本溪满族自治县",
		210522: "辽宁省本溪市桓仁满族自治县",
		210600: "辽宁省丹东市",
		210601: "辽宁省丹东市市辖区",
		210602: "辽宁省丹东市元宝区",
		210603: "辽宁省丹东市振兴区",
		210604: "辽宁省丹东市振安区",
		210624: "辽宁省丹东市宽甸满族自治县",
		210681: "辽宁省丹东市东港市",
		210682: "辽宁省丹东市凤城市",
		210700: "辽宁省锦州市",
		210701: "辽宁省锦州市市辖区",
		210702: "辽宁省锦州市古塔区",
		210703: "辽宁省锦州市凌河区",
		210711: "辽宁省锦州市太和区",
		210726: "辽宁省锦州市黑山县",
		210727: "辽宁省锦州市义县",
		210781: "辽宁省锦州市凌海市",
		210782: "辽宁省锦州市北宁市",
		210800: "辽宁省营口市",
		210801: "辽宁省营口市市辖区",
		210802: "辽宁省营口市站前区",
		210803: "辽宁省营口市西市区",
		210804: "辽宁省营口市鲅鱼圈区",
		210811: "辽宁省营口市老边区",
		210881: "辽宁省营口市盖州市",
		210882: "辽宁省营口市大石桥市",
		210900: "辽宁省阜新市",
		210901: "辽宁省阜新市市辖区",
		210902: "辽宁省阜新市海州区",
		210903: "辽宁省阜新市新邱区",
		210904: "辽宁省阜新市太平区",
		210905: "辽宁省阜新市清河门区",
		210911: "辽宁省阜新市细河区",
		210921: "辽宁省阜新市阜新蒙古族自治县",
		210922: "辽宁省阜新市彰武县",
		211e3: "辽宁省辽阳市",
		211001: "辽宁省辽阳市市辖区",
		211002: "辽宁省辽阳市白塔区",
		211003: "辽宁省辽阳市文圣区",
		211004: "辽宁省辽阳市宏伟区",
		211005: "辽宁省辽阳市弓长岭区",
		211011: "辽宁省辽阳市太子河区",
		211021: "辽宁省辽阳市辽阳县",
		211081: "辽宁省辽阳市灯塔市",
		211100: "辽宁省盘锦市",
		211101: "辽宁省盘锦市市辖区",
		211102: "辽宁省盘锦市双台子区",
		211103: "辽宁省盘锦市兴隆台区",
		211121: "辽宁省盘锦市大洼县",
		211122: "辽宁省盘锦市盘山县",
		211200: "辽宁省铁岭市",
		211201: "辽宁省铁岭市市辖区",
		211202: "辽宁省铁岭市银州区",
		211204: "辽宁省铁岭市清河区",
		211221: "辽宁省铁岭市铁岭县",
		211223: "辽宁省铁岭市西丰县",
		211224: "辽宁省铁岭市昌图县",
		211281: "辽宁省铁岭市铁法市",
		211282: "辽宁省铁岭市开原市",
		211300: "辽宁省朝阳市",
		211301: "辽宁省朝阳市市辖区",
		211302: "辽宁省朝阳市双塔区",
		211303: "辽宁省朝阳市龙城区",
		211321: "辽宁省朝阳市朝阳县",
		211322: "辽宁省朝阳市建平县",
		211324: "辽宁省朝阳市喀喇沁左翼蒙古族自治县",
		211381: "辽宁省朝阳市北票市",
		211382: "辽宁省朝阳市凌源市",
		211400: "辽宁省葫芦岛市",
		211401: "辽宁省葫芦岛市市辖区",
		211402: "辽宁省葫芦岛市连山区",
		211403: "辽宁省葫芦岛市龙港区",
		211404: "辽宁省葫芦岛市南票区",
		211421: "辽宁省葫芦岛市绥中县",
		211422: "辽宁省葫芦岛市建昌县",
		211481: "辽宁省葫芦岛市兴城市",
		22e4: "吉林省",
		220100: "吉林省长春市",
		220101: "吉林省长春市市辖区",
		220102: "吉林省长春市南关区",
		220103: "吉林省长春市宽城区",
		220104: "吉林省长春市朝阳区",
		220105: "吉林省长春市二道区",
		220106: "吉林省长春市绿园区",
		220112: "吉林省长春市双阳区",
		220122: "吉林省长春市农安县",
		220181: "吉林省长春市九台市",
		220182: "吉林省长春市榆树市",
		220183: "吉林省长春市德惠市",
		220200: "吉林省吉林市",
		220201: "吉林省吉林市市辖区",
		220202: "吉林省吉林市昌邑区",
		220203: "吉林省吉林市龙潭区",
		220204: "吉林省吉林市船营区",
		220211: "吉林省吉林市丰满区",
		220221: "吉林省吉林市永吉县",
		220281: "吉林省吉林市蛟河市",
		220282: "吉林省吉林市桦甸市",
		220283: "吉林省吉林市舒兰市",
		220284: "吉林省吉林市磐石市",
		220300: "吉林省四平市",
		220301: "吉林省四平市市辖区",
		220302: "吉林省四平市铁西区",
		220303: "吉林省四平市铁东区",
		220322: "吉林省四平市梨树县",
		220323: "吉林省四平市伊通满族自治县",
		220381: "吉林省四平市公主岭市",
		220382: "吉林省四平市双辽市",
		220400: "吉林省辽源市",
		220401: "吉林省辽源市市辖区",
		220402: "吉林省辽源市龙山区",
		220403: "吉林省辽源市西安区",
		220421: "吉林省辽源市东丰县",
		220422: "吉林省辽源市东辽县",
		220500: "吉林省通化市",
		220501: "吉林省通化市市辖区",
		220502: "吉林省通化市东昌区",
		220503: "吉林省通化市二道江区",
		220521: "吉林省通化市通化县",
		220523: "吉林省通化市辉南县",
		220524: "吉林省通化市柳河县",
		220581: "吉林省通化市梅河口市",
		220582: "吉林省通化市集安市",
		220600: "吉林省白山市",
		220601: "吉林省白山市市辖区",
		220602: "吉林省白山市八道江区",
		220621: "吉林省白山市抚松县",
		220622: "吉林省白山市靖宇县",
		220623: "吉林省白山市长白朝鲜族自治县",
		220625: "吉林省白山市江源县",
		220681: "吉林省白山市临江市",
		220700: "吉林省松原市",
		220701: "吉林省松原市市辖区",
		220702: "吉林省松原市宁江区",
		220721: "吉林省松原市前郭尔罗斯蒙古族自治县",
		220722: "吉林省松原市长岭县",
		220723: "吉林省松原市乾安县",
		220724: "吉林省松原市扶余县",
		220800: "吉林省白城市",
		220801: "吉林省白城市市辖区",
		220802: "吉林省白城市洮北区",
		220821: "吉林省白城市镇赉县",
		220822: "吉林省白城市通榆县",
		220881: "吉林省白城市洮南市",
		220882: "吉林省白城市大安市",
		222400: "吉林省延边朝鲜族自治州",
		222401: "吉林省延边朝鲜族自治州延吉市",
		222402: "吉林省延边朝鲜族自治州图们市",
		222403: "吉林省延边朝鲜族自治州敦化市",
		222404: "吉林省延边朝鲜族自治州珲春市",
		222405: "吉林省延边朝鲜族自治州龙井市",
		222406: "吉林省延边朝鲜族自治州和龙市",
		222424: "吉林省延边朝鲜族自治州汪清县",
		222426: "吉林省延边朝鲜族自治州安图县",
		23e4: "黑龙江省",
		230100: "黑龙江省哈尔滨市",
		230101: "黑龙江省哈尔滨市市辖区",
		230102: "黑龙江省哈尔滨市道里区",
		230103: "黑龙江省哈尔滨市南岗区",
		230104: "黑龙江省哈尔滨市道外区",
		230105: "黑龙江省哈尔滨市太平区",
		230106: "黑龙江省哈尔滨市香坊区",
		230107: "黑龙江省哈尔滨市动力区",
		230108: "黑龙江省哈尔滨市平房区",
		230121: "黑龙江省哈尔滨市呼兰县",
		230123: "黑龙江省哈尔滨市依兰县",
		230124: "黑龙江省哈尔滨市方正县",
		230125: "黑龙江省哈尔滨市宾县",
		230126: "黑龙江省哈尔滨市巴彦县",
		230127: "黑龙江省哈尔滨市木兰县",
		230128: "黑龙江省哈尔滨市通河县",
		230129: "黑龙江省哈尔滨市延寿县",
		230181: "黑龙江省哈尔滨市阿城市",
		230182: "黑龙江省哈尔滨市双城市",
		230183: "黑龙江省哈尔滨市尚志市",
		230184: "黑龙江省哈尔滨市五常市",
		230200: "黑龙江省齐齐哈尔市",
		230201: "黑龙江省齐齐哈尔市市辖区",
		230202: "黑龙江省齐齐哈尔市龙沙区",
		230203: "黑龙江省齐齐哈尔市建华区",
		230204: "黑龙江省齐齐哈尔市铁锋区",
		230205: "黑龙江省齐齐哈尔市昂昂溪区",
		230206: "黑龙江省齐齐哈尔市富拉尔基区",
		230207: "黑龙江省齐齐哈尔市碾子山区",
		230208: "黑龙江省齐齐哈尔市梅里斯达斡尔族区",
		230221: "黑龙江省齐齐哈尔市龙江县",
		230223: "黑龙江省齐齐哈尔市依安县",
		230224: "黑龙江省齐齐哈尔市泰来县",
		230225: "黑龙江省齐齐哈尔市甘南县",
		230227: "黑龙江省齐齐哈尔市富裕县",
		230229: "黑龙江省齐齐哈尔市克山县",
		230230: "黑龙江省齐齐哈尔市克东县",
		230231: "黑龙江省齐齐哈尔市拜泉县",
		230281: "黑龙江省齐齐哈尔市讷河市",
		230300: "黑龙江省鸡西市",
		230301: "黑龙江省鸡西市市辖区",
		230302: "黑龙江省鸡西市鸡冠区",
		230303: "黑龙江省鸡西市恒山区",
		230304: "黑龙江省鸡西市滴道区",
		230305: "黑龙江省鸡西市梨树区",
		230306: "黑龙江省鸡西市城子河区",
		230307: "黑龙江省鸡西市麻山区",
		230321: "黑龙江省鸡西市鸡东县",
		230381: "黑龙江省鸡西市虎林市",
		230382: "黑龙江省鸡西市密山市",
		230400: "黑龙江省鹤岗市",
		230401: "黑龙江省鹤岗市市辖区",
		230402: "黑龙江省鹤岗市向阳区",
		230403: "黑龙江省鹤岗市工农区",
		230404: "黑龙江省鹤岗市南山区",
		230405: "黑龙江省鹤岗市兴安区",
		230406: "黑龙江省鹤岗市东山区",
		230407: "黑龙江省鹤岗市兴山区",
		230421: "黑龙江省鹤岗市萝北县",
		230422: "黑龙江省鹤岗市绥滨县",
		230500: "黑龙江省双鸭山市",
		230501: "黑龙江省双鸭山市市辖区",
		230502: "黑龙江省双鸭山市尖山区",
		230503: "黑龙江省双鸭山市岭东区",
		230505: "黑龙江省双鸭山市四方台区",
		230506: "黑龙江省双鸭山市宝山区",
		230521: "黑龙江省双鸭山市集贤县",
		230522: "黑龙江省双鸭山市友谊县",
		230523: "黑龙江省双鸭山市宝清县",
		230524: "黑龙江省双鸭山市饶河县",
		230600: "黑龙江省大庆市",
		230601: "黑龙江省大庆市市辖区",
		230602: "黑龙江省大庆市萨尔图区",
		230603: "黑龙江省大庆市龙凤区",
		230604: "黑龙江省大庆市让胡路区",
		230605: "黑龙江省大庆市红岗区",
		230606: "黑龙江省大庆市大同区",
		230621: "黑龙江省大庆市肇州县",
		230622: "黑龙江省大庆市肇源县",
		230623: "黑龙江省大庆市林甸县",
		230624: "黑龙江省大庆市杜尔伯特蒙古族自治县",
		230700: "黑龙江省伊春市",
		230701: "黑龙江省伊春市市辖区",
		230702: "黑龙江省伊春市伊春区",
		230703: "黑龙江省伊春市南岔区",
		230704: "黑龙江省伊春市友好区",
		230705: "黑龙江省伊春市西林区",
		230706: "黑龙江省伊春市翠峦区",
		230707: "黑龙江省伊春市新青区",
		230708: "黑龙江省伊春市美溪区",
		230709: "黑龙江省伊春市金山屯区",
		230710: "黑龙江省伊春市五营区",
		230711: "黑龙江省伊春市乌马河区",
		230712: "黑龙江省伊春市汤旺河区",
		230713: "黑龙江省伊春市带岭区",
		230714: "黑龙江省伊春市乌伊岭区",
		230715: "黑龙江省伊春市红星区",
		230716: "黑龙江省伊春市上甘岭区",
		230722: "黑龙江省伊春市嘉荫县",
		230781: "黑龙江省伊春市铁力市",
		230800: "黑龙江省佳木斯市",
		230801: "黑龙江省佳木斯市市辖区",
		230802: "黑龙江省佳木斯市永红区",
		230803: "黑龙江省佳木斯市向阳区",
		230804: "黑龙江省佳木斯市前进区",
		230805: "黑龙江省佳木斯市东风区",
		230811: "黑龙江省佳木斯市郊区",
		230822: "黑龙江省佳木斯市桦南县",
		230826: "黑龙江省佳木斯市桦川县",
		230828: "黑龙江省佳木斯市汤原县",
		230833: "黑龙江省佳木斯市抚远县",
		230881: "黑龙江省佳木斯市同江市",
		230882: "黑龙江省佳木斯市富锦市",
		230900: "黑龙江省七台河市",
		230901: "黑龙江省七台河市市辖区",
		230902: "黑龙江省七台河市新兴区",
		230903: "黑龙江省七台河市桃山区",
		230904: "黑龙江省七台河市茄子河区",
		230921: "黑龙江省七台河市勃利县",
		231e3: "黑龙江省牡丹江市",
		231001: "黑龙江省牡丹江市市辖区",
		231002: "黑龙江省牡丹江市东安区",
		231003: "黑龙江省牡丹江市阳明区",
		231004: "黑龙江省牡丹江市爱民区",
		231005: "黑龙江省牡丹江市西安区",
		231024: "黑龙江省牡丹江市东宁县",
		231025: "黑龙江省牡丹江市林口县",
		231081: "黑龙江省牡丹江市绥芬河市",
		231083: "黑龙江省牡丹江市海林市",
		231084: "黑龙江省牡丹江市宁安市",
		231085: "黑龙江省牡丹江市穆棱市",
		231100: "黑龙江省黑河市",
		231101: "黑龙江省黑河市市辖区",
		231102: "黑龙江省黑河市爱辉区",
		231121: "黑龙江省黑河市嫩江县",
		231123: "黑龙江省黑河市逊克县",
		231124: "黑龙江省黑河市孙吴县",
		231181: "黑龙江省黑河市北安市",
		231182: "黑龙江省黑河市五大连池市",
		232300: "黑龙江省绥化地区",
		232301: "黑龙江省绥化地区绥化市",
		232302: "黑龙江省绥化地区安达市",
		232303: "黑龙江省绥化地区肇东市",
		232304: "黑龙江省绥化地区海伦市",
		232324: "黑龙江省绥化地区望奎县",
		232325: "黑龙江省绥化地区兰西县",
		232326: "黑龙江省绥化地区青冈县",
		232330: "黑龙江省绥化地区庆安县",
		232331: "黑龙江省绥化地区明水县",
		232332: "黑龙江省绥化地区绥棱县",
		232700: "黑龙江省大兴安岭地区",
		232721: "黑龙江省大兴安岭地区呼玛县",
		232722: "黑龙江省大兴安岭地区塔河县",
		232723: "黑龙江省大兴安岭地区漠河县",
		31e4: "上海市",
		310100: "上海市市辖区",
		310101: "上海市黄浦区",
		310102: "上海市南市区",
		310103: "上海市卢湾区",
		310104: "上海市徐汇区",
		310105: "上海市长宁区",
		310106: "上海市静安区",
		310107: "上海市普陀区",
		310108: "上海市闸北区",
		310109: "上海市虹口区",
		310110: "上海市杨浦区",
		310112: "上海市闵行区",
		310113: "上海市宝山区",
		310114: "上海市嘉定区",
		310115: "上海市浦东新区",
		310116: "上海市金山区",
		310117: "上海市松江区",
		310200: "上海市县",
		310225: "上海市南汇县",
		310226: "上海市奉贤县",
		310229: "上海市青浦县",
		310230: "上海市崇明县",
		32e4: "江苏省",
		320100: "江苏省南京市",
		320101: "江苏省南京市市辖区",
		320102: "江苏省南京市玄武区",
		320103: "江苏省南京市白下区",
		320104: "江苏省南京市秦淮区",
		320105: "江苏省南京市建邺区",
		320106: "江苏省南京市鼓楼区",
		320107: "江苏省南京市下关区",
		320111: "江苏省南京市浦口区",
		320112: "江苏省南京市大厂区",
		320113: "江苏省南京市栖霞区",
		320114: "江苏省南京市雨花台区",
		320121: "江苏省南京市江宁县",
		320122: "江苏省南京市江浦县",
		320123: "江苏省南京市六合县",
		320124: "江苏省南京市溧水县",
		320125: "江苏省南京市高淳县",
		320200: "江苏省无锡市",
		320201: "江苏省无锡市市辖区",
		320202: "江苏省无锡市崇安区",
		320203: "江苏省无锡市南长区",
		320204: "江苏省无锡市北塘区",
		320211: "江苏省无锡市郊区",
		320281: "江苏省无锡市江阴市",
		320282: "江苏省无锡市宜兴市",
		320283: "江苏省无锡市锡山市",
		320300: "江苏省徐州市",
		320301: "江苏省徐州市市辖区",
		320302: "江苏省徐州市鼓楼区",
		320303: "江苏省徐州市云龙区",
		320304: "江苏省徐州市九里区",
		320305: "江苏省徐州市贾汪区",
		320311: "江苏省徐州市泉山区",
		320321: "江苏省徐州市丰县",
		320322: "江苏省徐州市沛县",
		320323: "江苏省徐州市铜山县",
		320324: "江苏省徐州市睢宁县",
		320381: "江苏省徐州市新沂市",
		320382: "江苏省徐州市邳州市",
		320400: "江苏省常州市",
		320401: "江苏省常州市市辖区",
		320402: "江苏省常州市天宁区",
		320404: "江苏省常州市钟楼区",
		320405: "江苏省常州市戚墅堰区",
		320411: "江苏省常州市郊区",
		320481: "江苏省常州市溧阳市",
		320482: "江苏省常州市金坛市",
		320483: "江苏省常州市武进市",
		320500: "江苏省苏州市",
		320501: "江苏省苏州市市辖区",
		320502: "江苏省苏州市沧浪区",
		320503: "江苏省苏州市平江区",
		320504: "江苏省苏州市金阊区",
		320511: "江苏省苏州市郊区",
		320581: "江苏省苏州市常熟市",
		320582: "江苏省苏州市张家港市",
		320583: "江苏省苏州市昆山市",
		320584: "江苏省苏州市吴江市",
		320585: "江苏省苏州市太仓市",
		320586: "江苏省苏州市吴县市",
		320600: "江苏省南通市",
		320601: "江苏省南通市市辖区",
		320602: "江苏省南通市崇川区",
		320611: "江苏省南通市港闸区",
		320621: "江苏省南通市海安县",
		320623: "江苏省南通市如东县",
		320681: "江苏省南通市启东市",
		320682: "江苏省南通市如皋市",
		320683: "江苏省南通市通州市",
		320684: "江苏省南通市海门市",
		320700: "江苏省连云港市",
		320701: "江苏省连云港市市辖区",
		320703: "江苏省连云港市连云区",
		320704: "江苏省连云港市云台区",
		320705: "江苏省连云港市新浦区",
		320706: "江苏省连云港市海州区",
		320721: "江苏省连云港市赣榆县",
		320722: "江苏省连云港市东海县",
		320723: "江苏省连云港市灌云县",
		320724: "江苏省连云港市灌南县",
		320800: "江苏省淮阴市",
		320801: "江苏省淮阴市市辖区",
		320802: "江苏省淮阴市清河区",
		320811: "江苏省淮阴市清浦区",
		320821: "江苏省淮阴市淮阴县",
		320826: "江苏省淮阴市涟水县",
		320829: "江苏省淮阴市洪泽县",
		320830: "江苏省淮阴市盱眙县",
		320831: "江苏省淮阴市金湖县",
		320882: "江苏省淮阴市淮安市",
		320900: "江苏省盐城市",
		320901: "江苏省盐城市市辖区",
		320902: "江苏省盐城市城区",
		320921: "江苏省盐城市响水县",
		320922: "江苏省盐城市滨海县",
		320923: "江苏省盐城市阜宁县",
		320924: "江苏省盐城市射阳县",
		320925: "江苏省盐城市建湖县",
		320928: "江苏省盐城市盐都县",
		320981: "江苏省盐城市东台市",
		320982: "江苏省盐城市大丰市",
		321e3: "江苏省扬州市",
		321001: "江苏省扬州市市辖区",
		321002: "江苏省扬州市广陵区",
		321011: "江苏省扬州市郊区",
		321023: "江苏省扬州市宝应县",
		321027: "江苏省扬州市邗江县",
		321081: "江苏省扬州市仪征市",
		321084: "江苏省扬州市高邮市",
		321088: "江苏省扬州市江都市",
		321100: "江苏省镇江市",
		321101: "江苏省镇江市市辖区",
		321102: "江苏省镇江市京口区",
		321111: "江苏省镇江市润州区",
		321121: "江苏省镇江市丹徒县",
		321181: "江苏省镇江市丹阳市",
		321182: "江苏省镇江市扬中市",
		321183: "江苏省镇江市句容市",
		321200: "江苏省泰州市",
		321201: "江苏省泰州市市辖区",
		321202: "江苏省泰州市海陵区",
		321203: "江苏省泰州市高港区",
		321281: "江苏省泰州市兴化市",
		321282: "江苏省泰州市靖江市",
		321283: "江苏省泰州市泰兴市",
		321284: "江苏省泰州市姜堰市",
		321300: "江苏省宿迁市",
		321301: "江苏省宿迁市市辖区",
		321302: "江苏省宿迁市宿城区",
		321321: "江苏省宿迁市宿豫县",
		321322: "江苏省宿迁市沭阳县",
		321323: "江苏省宿迁市泗阳县",
		321324: "江苏省宿迁市泗洪县",
		33e4: "浙江省",
		330100: "浙江省杭州市",
		330101: "浙江省杭州市市辖区",
		330102: "浙江省杭州市上城区",
		330103: "浙江省杭州市下城区",
		330104: "浙江省杭州市江干区",
		330105: "浙江省杭州市拱墅区",
		330106: "浙江省杭州市西湖区",
		330108: "浙江省杭州市滨江区",
		330122: "浙江省杭州市桐庐县",
		330127: "浙江省杭州市淳安县",
		330181: "浙江省杭州市萧山市",
		330182: "浙江省杭州市建德市",
		330183: "浙江省杭州市富阳市",
		330184: "浙江省杭州市余杭市",
		330185: "浙江省杭州市临安市",
		330200: "浙江省宁波市",
		330201: "浙江省宁波市市辖区",
		330203: "浙江省宁波市海曙区",
		330204: "浙江省宁波市江东区",
		330205: "浙江省宁波市江北区",
		330206: "浙江省宁波市北仑区",
		330211: "浙江省宁波市镇海区",
		330225: "浙江省宁波市象山县",
		330226: "浙江省宁波市宁海县",
		330227: "浙江省宁波市鄞县",
		330281: "浙江省宁波市余姚市",
		330282: "浙江省宁波市慈溪市",
		330283: "浙江省宁波市奉化市",
		330300: "浙江省温州市",
		330301: "浙江省温州市市辖区",
		330302: "浙江省温州市鹿城区",
		330303: "浙江省温州市龙湾区",
		330304: "浙江省温州市瓯海区",
		330322: "浙江省温州市洞头县",
		330324: "浙江省温州市永嘉县",
		330326: "浙江省温州市平阳县",
		330327: "浙江省温州市苍南县",
		330328: "浙江省温州市文成县",
		330329: "浙江省温州市泰顺县",
		330381: "浙江省温州市瑞安市",
		330382: "浙江省温州市乐清市",
		330400: "浙江省嘉兴市",
		330401: "浙江省嘉兴市市辖区",
		330402: "浙江省嘉兴市秀城区",
		330411: "浙江省嘉兴市郊区",
		330421: "浙江省嘉兴市嘉善县",
		330424: "浙江省嘉兴市海盐县",
		330481: "浙江省嘉兴市海宁市",
		330482: "浙江省嘉兴市平湖市",
		330483: "浙江省嘉兴市桐乡市",
		330500: "浙江省湖州市",
		330501: "浙江省湖州市市辖区",
		330521: "浙江省湖州市德清县",
		330522: "浙江省湖州市长兴县",
		330523: "浙江省湖州市安吉县",
		330600: "浙江省绍兴市",
		330601: "浙江省绍兴市市辖区",
		330602: "浙江省绍兴市越城区",
		330621: "浙江省绍兴市绍兴县",
		330624: "浙江省绍兴市新昌县",
		330681: "浙江省绍兴市诸暨市",
		330682: "浙江省绍兴市上虞市",
		330683: "浙江省绍兴市嵊州市",
		330700: "浙江省金华市",
		330701: "浙江省金华市市辖区",
		330702: "浙江省金华市婺城区",
		330721: "浙江省金华市金华县",
		330723: "浙江省金华市武义县",
		330726: "浙江省金华市浦江县",
		330727: "浙江省金华市磐安县",
		330781: "浙江省金华市兰溪市",
		330782: "浙江省金华市义乌市",
		330783: "浙江省金华市东阳市",
		330784: "浙江省金华市永康市",
		330800: "浙江省衢州市",
		330801: "浙江省衢州市市辖区",
		330802: "浙江省衢州市柯城区",
		330821: "浙江省衢州市衢县",
		330822: "浙江省衢州市常山县",
		330824: "浙江省衢州市开化县",
		330825: "浙江省衢州市龙游县",
		330881: "浙江省衢州市江山市",
		330900: "浙江省舟山市",
		330901: "浙江省舟山市市辖区",
		330902: "浙江省舟山市定海区",
		330903: "浙江省舟山市普陀区",
		330921: "浙江省舟山市岱山县",
		330922: "浙江省舟山市嵊泗县",
		331e3: "浙江省台州市",
		331001: "浙江省台州市市辖区",
		331002: "浙江省台州市椒江区",
		331003: "浙江省台州市黄岩区",
		331004: "浙江省台州市路桥区",
		331021: "浙江省台州市玉环县",
		331022: "浙江省台州市三门县",
		331023: "浙江省台州市天台县",
		331024: "浙江省台州市仙居县",
		331081: "浙江省台州市温岭市",
		331082: "浙江省台州市临海市",
		332500: "浙江省丽水地区",
		332501: "浙江省丽水地区丽水市",
		332502: "浙江省丽水地区龙泉市",
		332522: "浙江省丽水地区青田县",
		332523: "浙江省丽水地区云和县",
		332525: "浙江省丽水地区庆元县",
		332526: "浙江省丽水地区缙云县",
		332527: "浙江省丽水地区遂昌县",
		332528: "浙江省丽水地区松阳县",
		332529: "浙江省丽水地区景宁畲族自治县",
		34e4: "安徽省",
		340100: "安徽省合肥市",
		340101: "安徽省合肥市市辖区",
		340102: "安徽省合肥市东市区",
		340103: "安徽省合肥市中市区",
		340104: "安徽省合肥市西市区",
		340111: "安徽省合肥市郊区",
		340121: "安徽省合肥市长丰县",
		340122: "安徽省合肥市肥东县",
		340123: "安徽省合肥市肥西县",
		340200: "安徽省芜湖市",
		340201: "安徽省芜湖市市辖区",
		340202: "安徽省芜湖市镜湖区",
		340203: "安徽省芜湖市马塘区",
		340204: "安徽省芜湖市新芜区",
		340207: "安徽省芜湖市鸠江区",
		340221: "安徽省芜湖市芜湖县",
		340222: "安徽省芜湖市繁昌县",
		340223: "安徽省芜湖市南陵县",
		340300: "安徽省蚌埠市",
		340301: "安徽省蚌埠市市辖区",
		340302: "安徽省蚌埠市东市区",
		340303: "安徽省蚌埠市中市区",
		340304: "安徽省蚌埠市西市区",
		340311: "安徽省蚌埠市郊区",
		340321: "安徽省蚌埠市怀远县",
		340322: "安徽省蚌埠市五河县",
		340323: "安徽省蚌埠市固镇县",
		340400: "安徽省淮南市",
		340401: "安徽省淮南市市辖区",
		340402: "安徽省淮南市大通区",
		340403: "安徽省淮南市田家庵区",
		340404: "安徽省淮南市谢家集区",
		340405: "安徽省淮南市八公山区",
		340406: "安徽省淮南市潘集区",
		340421: "安徽省淮南市凤台县",
		340500: "安徽省马鞍山市",
		340501: "安徽省马鞍山市市辖区",
		340502: "安徽省马鞍山市金家庄区",
		340503: "安徽省马鞍山市花山区",
		340504: "安徽省马鞍山市雨山区",
		340505: "安徽省马鞍山市向山区",
		340521: "安徽省马鞍山市当涂县",
		340600: "安徽省淮北市",
		340601: "安徽省淮北市市辖区",
		340602: "安徽省淮北市杜集区",
		340603: "安徽省淮北市相山区",
		340604: "安徽省淮北市烈山区",
		340621: "安徽省淮北市濉溪县",
		340700: "安徽省铜陵市",
		340701: "安徽省铜陵市市辖区",
		340702: "安徽省铜陵市铜官山区",
		340703: "安徽省铜陵市狮子山区",
		340711: "安徽省铜陵市郊区",
		340721: "安徽省铜陵市铜陵县",
		340800: "安徽省安庆市",
		340801: "安徽省安庆市市辖区",
		340802: "安徽省安庆市迎江区",
		340803: "安徽省安庆市大观区",
		340811: "安徽省安庆市郊区",
		340822: "安徽省安庆市怀宁县",
		340823: "安徽省安庆市枞阳县",
		340824: "安徽省安庆市潜山县",
		340825: "安徽省安庆市太湖县",
		340826: "安徽省安庆市宿松县",
		340827: "安徽省安庆市望江县",
		340828: "安徽省安庆市岳西县",
		340881: "安徽省安庆市桐城市",
		341e3: "安徽省黄山市",
		341001: "安徽省黄山市市辖区",
		341002: "安徽省黄山市屯溪区",
		341003: "安徽省黄山市黄山区",
		341004: "安徽省黄山市徽州区",
		341021: "安徽省黄山市歙县",
		341022: "安徽省黄山市休宁县",
		341023: "安徽省黄山市黟县",
		341024: "安徽省黄山市祁门县",
		341100: "安徽省滁州市",
		341101: "安徽省滁州市市辖区",
		341102: "安徽省滁州市琅琊区",
		341103: "安徽省滁州市南谯区",
		341122: "安徽省滁州市来安县",
		341124: "安徽省滁州市全椒县",
		341125: "安徽省滁州市定远县",
		341126: "安徽省滁州市凤阳县",
		341181: "安徽省滁州市天长市",
		341182: "安徽省滁州市明光市",
		341200: "安徽省阜阳市",
		341201: "安徽省阜阳市市辖区",
		341202: "安徽省阜阳市颍州区",
		341203: "安徽省阜阳市颍东区",
		341204: "安徽省阜阳市颍泉区",
		341221: "安徽省阜阳市临泉县",
		341222: "安徽省阜阳市太和县",
		341223: "安徽省阜阳市涡阳县",
		341224: "安徽省阜阳市蒙城县",
		341225: "安徽省阜阳市阜南县",
		341226: "安徽省阜阳市颍上县",
		341227: "安徽省阜阳市利辛县",
		341281: "安徽省阜阳市亳州市",
		341282: "安徽省阜阳市界首市",
		341300: "安徽省宿州市",
		341301: "安徽省宿州市市辖区",
		341302: "安徽省宿州市甬桥区",
		341321: "安徽省宿州市砀山县",
		341322: "安徽省宿州市萧县",
		341323: "安徽省宿州市灵璧县",
		341324: "安徽省宿州市泗县",
		342400: "安徽省六安地区",
		342401: "安徽省六安地区六安市",
		342422: "安徽省六安地区寿县",
		342423: "安徽省六安地区霍邱县",
		342425: "安徽省六安地区舒城县",
		342426: "安徽省六安地区金寨县",
		342427: "安徽省六安地区霍山县",
		342500: "安徽省宣城地区",
		342501: "安徽省宣城地区宣州市",
		342502: "安徽省宣城地区宁国市",
		342522: "安徽省宣城地区郎溪县",
		342523: "安徽省宣城地区广德县",
		342529: "安徽省宣城地区泾县",
		342530: "安徽省宣城地区旌德县",
		342531: "安徽省宣城地区绩溪县",
		342600: "安徽省巢湖地区",
		342601: "安徽省巢湖地区巢湖市",
		342622: "安徽省巢湖地区庐江县",
		342623: "安徽省巢湖地区无为县",
		342625: "安徽省巢湖地区含山县",
		342626: "安徽省巢湖地区和县",
		342900: "安徽省池州地区",
		342901: "安徽省池州地区贵池市",
		342921: "安徽省池州地区东至县",
		342922: "安徽省池州地区石台县",
		342923: "安徽省池州地区青阳县",
		35e4: "福建省",
		350100: "福建省福州市",
		350101: "福建省福州市市辖区",
		350102: "福建省福州市鼓楼区",
		350103: "福建省福州市台江区",
		350104: "福建省福州市仓山区",
		350105: "福建省福州市马尾区",
		350111: "福建省福州市晋安区",
		350121: "福建省福州市闽侯县",
		350122: "福建省福州市连江县",
		350123: "福建省福州市罗源县",
		350124: "福建省福州市闽清县",
		350125: "福建省福州市永泰县",
		350128: "福建省福州市平潭县",
		350181: "福建省福州市福清市",
		350182: "福建省福州市长乐市",
		350200: "福建省厦门市",
		350201: "福建省厦门市市辖区",
		350202: "福建省厦门市鼓浪屿区",
		350203: "福建省厦门市思明区",
		350204: "福建省厦门市开元区",
		350205: "福建省厦门市杏林区",
		350206: "福建省厦门市湖里区",
		350211: "福建省厦门市集美区",
		350212: "福建省厦门市同安区",
		350300: "福建省莆田市",
		350301: "福建省莆田市市辖区",
		350302: "福建省莆田市城厢区",
		350303: "福建省莆田市涵江区",
		350321: "福建省莆田市莆田县",
		350322: "福建省莆田市仙游县",
		350400: "福建省三明市",
		350401: "福建省三明市市辖区",
		350402: "福建省三明市梅列区",
		350403: "福建省三明市三元区",
		350421: "福建省三明市明溪县",
		350423: "福建省三明市清流县",
		350424: "福建省三明市宁化县",
		350425: "福建省三明市大田县",
		350426: "福建省三明市尤溪县",
		350427: "福建省三明市沙县",
		350428: "福建省三明市将乐县",
		350429: "福建省三明市泰宁县",
		350430: "福建省三明市建宁县",
		350481: "福建省三明市永安市",
		350500: "福建省泉州市",
		350501: "福建省泉州市市辖区",
		350502: "福建省泉州市鲤城区",
		350503: "福建省泉州市丰泽区",
		350504: "福建省泉州市洛江区",
		350521: "福建省泉州市惠安县",
		350524: "福建省泉州市安溪县",
		350525: "福建省泉州市永春县",
		350526: "福建省泉州市德化县",
		350527: "福建省泉州市金门县",
		350581: "福建省泉州市石狮市",
		350582: "福建省泉州市晋江市",
		350583: "福建省泉州市南安市",
		350600: "福建省漳州市",
		350601: "福建省漳州市市辖区",
		350602: "福建省漳州市芗城区",
		350603: "福建省漳州市龙文区",
		350622: "福建省漳州市云霄县",
		350623: "福建省漳州市漳浦县",
		350624: "福建省漳州市诏安县",
		350625: "福建省漳州市长泰县",
		350626: "福建省漳州市东山县",
		350627: "福建省漳州市南靖县",
		350628: "福建省漳州市平和县",
		350629: "福建省漳州市华安县",
		350681: "福建省漳州市龙海市",
		350700: "福建省南平市",
		350701: "福建省南平市市辖区",
		350702: "福建省南平市延平区",
		350721: "福建省南平市顺昌县",
		350722: "福建省南平市浦城县",
		350723: "福建省南平市光泽县",
		350724: "福建省南平市松溪县",
		350725: "福建省南平市政和县",
		350781: "福建省南平市邵武市",
		350782: "福建省南平市武夷山市",
		350783: "福建省南平市建瓯市",
		350784: "福建省南平市建阳市",
		350800: "福建省龙岩市",
		350801: "福建省龙岩市市辖区",
		350802: "福建省龙岩市新罗区",
		350821: "福建省龙岩市长汀县",
		350822: "福建省龙岩市永定县",
		350823: "福建省龙岩市上杭县",
		350824: "福建省龙岩市武平县",
		350825: "福建省龙岩市连城县",
		350881: "福建省龙岩市漳平市",
		352200: "福建省宁德地区",
		352201: "福建省宁德地区宁德市",
		352202: "福建省宁德地区福安市",
		352203: "福建省宁德地区福鼎市",
		352225: "福建省宁德地区霞浦县",
		352227: "福建省宁德地区古田县",
		352228: "福建省宁德地区屏南县",
		352229: "福建省宁德地区寿宁县",
		352230: "福建省宁德地区周宁县",
		352231: "福建省宁德地区柘荣县",
		36e4: "江西省",
		360100: "江西省南昌市",
		360101: "江西省南昌市市辖区",
		360102: "江西省南昌市东湖区",
		360103: "江西省南昌市西湖区",
		360104: "江西省南昌市青云谱区",
		360105: "江西省南昌市湾里区",
		360111: "江西省南昌市郊区",
		360121: "江西省南昌市南昌县",
		360122: "江西省南昌市新建县",
		360123: "江西省南昌市安义县",
		360124: "江西省南昌市进贤县",
		360200: "江西省景德镇市",
		360201: "江西省景德镇市市辖区",
		360202: "江西省景德镇市昌江区",
		360203: "江西省景德镇市珠山区",
		360222: "江西省景德镇市浮梁县",
		360281: "江西省景德镇市乐平市",
		360300: "江西省萍乡市",
		360301: "江西省萍乡市市辖区",
		360302: "江西省萍乡市安源区",
		360313: "江西省萍乡市湘东区",
		360321: "江西省萍乡市莲花县",
		360322: "江西省萍乡市上栗县",
		360323: "江西省萍乡市芦溪县",
		360400: "江西省九江市",
		360401: "江西省九江市市辖区",
		360402: "江西省九江市庐山区",
		360403: "江西省九江市浔阳区",
		360421: "江西省九江市九江县",
		360423: "江西省九江市武宁县",
		360424: "江西省九江市修水县",
		360425: "江西省九江市永修县",
		360426: "江西省九江市德安县",
		360427: "江西省九江市星子县",
		360428: "江西省九江市都昌县",
		360429: "江西省九江市湖口县",
		360430: "江西省九江市彭泽县",
		360481: "江西省九江市瑞昌市",
		360500: "江西省新余市",
		360501: "江西省新余市市辖区",
		360502: "江西省新余市渝水区",
		360521: "江西省新余市分宜县",
		360600: "江西省鹰潭市",
		360601: "江西省鹰潭市市辖区",
		360602: "江西省鹰潭市月湖区",
		360622: "江西省鹰潭市余江县",
		360681: "江西省鹰潭市贵溪市",
		360700: "江西省赣州市",
		360701: "江西省赣州市市辖区",
		360702: "江西省赣州市章贡区",
		360721: "江西省赣州市赣县",
		360722: "江西省赣州市信丰县",
		360723: "江西省赣州市大余县",
		360724: "江西省赣州市上犹县",
		360725: "江西省赣州市崇义县",
		360726: "江西省赣州市安远县",
		360727: "江西省赣州市龙南县",
		360728: "江西省赣州市定南县",
		360729: "江西省赣州市全南县",
		360730: "江西省赣州市宁都县",
		360731: "江西省赣州市于都县",
		360732: "江西省赣州市兴国县",
		360733: "江西省赣州市会昌县",
		360734: "江西省赣州市寻乌县",
		360735: "江西省赣州市石城县",
		360781: "江西省赣州市瑞金市",
		360782: "江西省赣州市南康市",
		362200: "江西省宜春地区",
		362201: "江西省宜春地区宜春市",
		362202: "江西省宜春地区丰城市",
		362203: "江西省宜春地区樟树市",
		362204: "江西省宜春地区高安市",
		362226: "江西省宜春地区奉新县",
		362227: "江西省宜春地区万载县",
		362228: "江西省宜春地区上高县",
		362229: "江西省宜春地区宜丰县",
		362232: "江西省宜春地区靖安县",
		362233: "江西省宜春地区铜鼓县",
		362300: "江西省上饶地区",
		362301: "江西省上饶地区上饶市",
		362302: "江西省上饶地区德兴市",
		362321: "江西省上饶地区上饶县",
		362322: "江西省上饶地区广丰县",
		362323: "江西省上饶地区玉山县",
		362324: "江西省上饶地区铅山县",
		362325: "江西省上饶地区横峰县",
		362326: "江西省上饶地区弋阳县",
		362329: "江西省上饶地区余干县",
		362330: "江西省上饶地区波阳县",
		362331: "江西省上饶地区万年县",
		362334: "江西省上饶地区婺源县",
		362400: "江西省吉安地区",
		362401: "江西省吉安地区吉安市",
		362402: "江西省吉安地区井冈山市",
		362421: "江西省吉安地区吉安县",
		362422: "江西省吉安地区吉水县",
		362423: "江西省吉安地区峡江县",
		362424: "江西省吉安地区新干县",
		362425: "江西省吉安地区永丰县",
		362426: "江西省吉安地区泰和县",
		362427: "江西省吉安地区遂川县",
		362428: "江西省吉安地区万安县",
		362429: "江西省吉安地区安福县",
		362430: "江西省吉安地区永新县",
		362432: "江西省吉安地区宁冈县",
		362500: "江西省抚州地区",
		362502: "江西省抚州地区临川市",
		362522: "江西省抚州地区南城县",
		362523: "江西省抚州地区黎川县",
		362524: "江西省抚州地区南丰县",
		362525: "江西省抚州地区崇仁县",
		362526: "江西省抚州地区乐安县",
		362527: "江西省抚州地区宜黄县",
		362528: "江西省抚州地区金溪县",
		362529: "江西省抚州地区资溪县",
		362531: "江西省抚州地区东乡县",
		362532: "江西省抚州地区广昌县",
		37e4: "山东省",
		370100: "山东省济南市",
		370101: "山东省济南市市辖区",
		370102: "山东省济南市历下区",
		370103: "山东省济南市市中区",
		370104: "山东省济南市槐荫区",
		370105: "山东省济南市天桥区",
		370112: "山东省济南市历城区",
		370123: "山东省济南市长清县",
		370124: "山东省济南市平阴县",
		370125: "山东省济南市济阳县",
		370126: "山东省济南市商河县",
		370181: "山东省济南市章丘市",
		370200: "山东省青岛市",
		370201: "山东省青岛市市辖区",
		370202: "山东省青岛市市南区",
		370203: "山东省青岛市市北区",
		370205: "山东省青岛市四方区",
		370211: "山东省青岛市黄岛区",
		370212: "山东省青岛市崂山区",
		370213: "山东省青岛市李沧区",
		370214: "山东省青岛市城阳区",
		370281: "山东省青岛市胶州市",
		370282: "山东省青岛市即墨市",
		370283: "山东省青岛市平度市",
		370284: "山东省青岛市胶南市",
		370285: "山东省青岛市莱西市",
		370300: "山东省淄博市",
		370301: "山东省淄博市市辖区",
		370302: "山东省淄博市淄川区",
		370303: "山东省淄博市张店区",
		370304: "山东省淄博市博山区",
		370305: "山东省淄博市临淄区",
		370306: "山东省淄博市周村区",
		370321: "山东省淄博市桓台县",
		370322: "山东省淄博市高青县",
		370323: "山东省淄博市沂源县",
		370400: "山东省枣庄市",
		370401: "山东省枣庄市市辖区",
		370402: "山东省枣庄市市中区",
		370403: "山东省枣庄市薛城区",
		370404: "山东省枣庄市峄城区",
		370405: "山东省枣庄市台儿庄区",
		370406: "山东省枣庄市山亭区",
		370481: "山东省枣庄市滕州市",
		370500: "山东省东营市",
		370501: "山东省东营市市辖区",
		370502: "山东省东营市东营区",
		370503: "山东省东营市河口区",
		370521: "山东省东营市垦利县",
		370522: "山东省东营市利津县",
		370523: "山东省东营市广饶县",
		370600: "山东省烟台市",
		370601: "山东省烟台市市辖区",
		370602: "山东省烟台市芝罘区",
		370611: "山东省烟台市福山区",
		370612: "山东省烟台市牟平区",
		370613: "山东省烟台市莱山区",
		370634: "山东省烟台市长岛县",
		370681: "山东省烟台市龙口市",
		370682: "山东省烟台市莱阳市",
		370683: "山东省烟台市莱州市",
		370684: "山东省烟台市蓬莱市",
		370685: "山东省烟台市招远市",
		370686: "山东省烟台市栖霞市",
		370687: "山东省烟台市海阳市",
		370700: "山东省潍坊市",
		370701: "山东省潍坊市市辖区",
		370702: "山东省潍坊市潍城区",
		370703: "山东省潍坊市寒亭区",
		370704: "山东省潍坊市坊子区",
		370705: "山东省潍坊市奎文区",
		370724: "山东省潍坊市临朐县",
		370725: "山东省潍坊市昌乐县",
		370781: "山东省潍坊市青州市",
		370782: "山东省潍坊市诸城市",
		370783: "山东省潍坊市寿光市",
		370784: "山东省潍坊市安丘市",
		370785: "山东省潍坊市高密市",
		370786: "山东省潍坊市昌邑市",
		370800: "山东省济宁市",
		370801: "山东省济宁市市辖区",
		370802: "山东省济宁市市中区",
		370811: "山东省济宁市任城区",
		370826: "山东省济宁市微山县",
		370827: "山东省济宁市鱼台县",
		370828: "山东省济宁市金乡县",
		370829: "山东省济宁市嘉祥县",
		370830: "山东省济宁市汶上县",
		370831: "山东省济宁市泗水县",
		370832: "山东省济宁市梁山县",
		370881: "山东省济宁市曲阜市",
		370882: "山东省济宁市兖州市",
		370883: "山东省济宁市邹城市",
		370900: "山东省泰安市",
		370901: "山东省泰安市市辖区",
		370902: "山东省泰安市泰山区",
		370911: "山东省泰安市郊区",
		370921: "山东省泰安市宁阳县",
		370923: "山东省泰安市东平县",
		370982: "山东省泰安市新泰市",
		370983: "山东省泰安市肥城市",
		371e3: "山东省威海市",
		371001: "山东省威海市市辖区",
		371002: "山东省威海市环翠区",
		371081: "山东省威海市文登市",
		371082: "山东省威海市荣成市",
		371083: "山东省威海市乳山市",
		371100: "山东省日照市",
		371101: "山东省日照市市辖区",
		371102: "山东省日照市东港区",
		371121: "山东省日照市五莲县",
		371122: "山东省日照市莒县",
		371200: "山东省莱芜市",
		371201: "山东省莱芜市市辖区",
		371202: "山东省莱芜市莱城区",
		371203: "山东省莱芜市钢城区",
		371300: "山东省临沂市",
		371301: "山东省临沂市市辖区",
		371302: "山东省临沂市兰山区",
		371311: "山东省临沂市罗庄区",
		371312: "山东省临沂市河东区",
		371321: "山东省临沂市沂南县",
		371322: "山东省临沂市郯城县",
		371323: "山东省临沂市沂水县",
		371324: "山东省临沂市苍山县",
		371325: "山东省临沂市费县",
		371326: "山东省临沂市平邑县",
		371327: "山东省临沂市莒南县",
		371328: "山东省临沂市蒙阴县",
		371329: "山东省临沂市临沭县",
		371400: "山东省德州市",
		371401: "山东省德州市市辖区",
		371402: "山东省德州市德城区",
		371421: "山东省德州市陵县",
		371422: "山东省德州市宁津县",
		371423: "山东省德州市庆云县",
		371424: "山东省德州市临邑县",
		371425: "山东省德州市齐河县",
		371426: "山东省德州市平原县",
		371427: "山东省德州市夏津县",
		371428: "山东省德州市武城县",
		371481: "山东省德州市乐陵市",
		371482: "山东省德州市禹城市",
		371500: "山东省聊城市",
		371501: "山东省聊城市市辖区",
		371502: "山东省聊城市东昌府区",
		371521: "山东省聊城市阳谷县",
		371522: "山东省聊城市莘县",
		371523: "山东省聊城市茌平县",
		371524: "山东省聊城市东阿县",
		371525: "山东省聊城市冠县",
		371526: "山东省聊城市高唐县",
		371581: "山东省聊城市临清市",
		372300: "山东省滨州地区",
		372301: "山东省滨州地区滨州市",
		372321: "山东省滨州地区惠民县",
		372323: "山东省滨州地区阳信县",
		372324: "山东省滨州地区无棣县",
		372325: "山东省滨州地区沾化县",
		372328: "山东省滨州地区博兴县",
		372330: "山东省滨州地区邹平县",
		372900: "山东省菏泽地区",
		372901: "山东省菏泽地区菏泽市",
		372922: "山东省菏泽地区曹县",
		372923: "山东省菏泽地区定陶县",
		372924: "山东省菏泽地区成武县",
		372925: "山东省菏泽地区单县",
		372926: "山东省菏泽地区巨野县",
		372928: "山东省菏泽地区郓城县",
		372929: "山东省菏泽地区鄄城县",
		372930: "山东省菏泽地区东明县",
		41e4: "河南省",
		410100: "河南省郑州市",
		410101: "河南省郑州市市辖区",
		410102: "河南省郑州市中原区",
		410103: "河南省郑州市二七区",
		410104: "河南省郑州市管城回族区",
		410105: "河南省郑州市金水区",
		410106: "河南省郑州市上街区",
		410108: "河南省郑州市邙山区",
		410122: "河南省郑州市中牟县",
		410181: "河南省郑州市巩义市",
		410182: "河南省郑州市荥阳市",
		410183: "河南省郑州市新密市",
		410184: "河南省郑州市新郑市",
		410185: "河南省郑州市登封市",
		410200: "河南省开封市",
		410201: "河南省开封市市辖区",
		410202: "河南省开封市龙亭区",
		410203: "河南省开封市顺河回族区",
		410204: "河南省开封市鼓楼区",
		410205: "河南省开封市南关区",
		410211: "河南省开封市郊区",
		410221: "河南省开封市杞县",
		410222: "河南省开封市通许县",
		410223: "河南省开封市尉氏县",
		410224: "河南省开封市开封县",
		410225: "河南省开封市兰考县",
		410300: "河南省洛阳市",
		410301: "河南省洛阳市市辖区",
		410302: "河南省洛阳市老城区",
		410303: "河南省洛阳市西工区",
		410304: "河南省洛阳市廛河回族区",
		410305: "河南省洛阳市涧西区",
		410306: "河南省洛阳市吉利区",
		410311: "河南省洛阳市郊区",
		410322: "河南省洛阳市孟津县",
		410323: "河南省洛阳市新安县",
		410324: "河南省洛阳市栾川县",
		410325: "河南省洛阳市嵩县",
		410326: "河南省洛阳市汝阳县",
		410327: "河南省洛阳市宜阳县",
		410328: "河南省洛阳市洛宁县",
		410329: "河南省洛阳市伊川县",
		410381: "河南省洛阳市偃师市",
		410400: "河南省平顶山市",
		410401: "河南省平顶山市市辖区",
		410402: "河南省平顶山市新华区",
		410403: "河南省平顶山市卫东区",
		410404: "河南省平顶山市石龙区",
		410411: "河南省平顶山市湛河区",
		410421: "河南省平顶山市宝丰县",
		410422: "河南省平顶山市叶县",
		410423: "河南省平顶山市鲁山县",
		410425: "河南省平顶山市郏县",
		410481: "河南省平顶山市舞钢市",
		410482: "河南省平顶山市汝州市",
		410500: "河南省安阳市",
		410501: "河南省安阳市市辖区",
		410502: "河南省安阳市文峰区",
		410503: "河南省安阳市北关区",
		410504: "河南省安阳市铁西区",
		410511: "河南省安阳市郊区",
		410522: "河南省安阳市安阳县",
		410523: "河南省安阳市汤阴县",
		410526: "河南省安阳市滑县",
		410527: "河南省安阳市内黄县",
		410581: "河南省安阳市林州市",
		410600: "河南省鹤壁市",
		410601: "河南省鹤壁市市辖区",
		410602: "河南省鹤壁市鹤山区",
		410603: "河南省鹤壁市山城区",
		410611: "河南省鹤壁市郊区",
		410621: "河南省鹤壁市浚县",
		410622: "河南省鹤壁市淇县",
		410700: "河南省新乡市",
		410701: "河南省新乡市市辖区",
		410702: "河南省新乡市红旗区",
		410703: "河南省新乡市新华区",
		410704: "河南省新乡市北站区",
		410711: "河南省新乡市郊区",
		410721: "河南省新乡市新乡县",
		410724: "河南省新乡市获嘉县",
		410725: "河南省新乡市原阳县",
		410726: "河南省新乡市延津县",
		410727: "河南省新乡市封丘县",
		410728: "河南省新乡市长垣县",
		410781: "河南省新乡市卫辉市",
		410782: "河南省新乡市辉县市",
		410800: "河南省焦作市",
		410801: "河南省焦作市市辖区",
		410802: "河南省焦作市解放区",
		410803: "河南省焦作市中站区",
		410804: "河南省焦作市马村区",
		410811: "河南省焦作市山阳区",
		410821: "河南省焦作市修武县",
		410822: "河南省焦作市博爱县",
		410823: "河南省焦作市武陟县",
		410825: "河南省焦作市温县",
		410881: "河南省焦作市济源市",
		410882: "河南省焦作市沁阳市",
		410883: "河南省焦作市孟州市",
		410900: "河南省濮阳市",
		410901: "河南省濮阳市市辖区",
		410902: "河南省濮阳市市区",
		410922: "河南省濮阳市清丰县",
		410923: "河南省濮阳市南乐县",
		410926: "河南省濮阳市范县",
		410927: "河南省濮阳市台前县",
		410928: "河南省濮阳市濮阳县",
		411e3: "河南省许昌市",
		411001: "河南省许昌市市辖区",
		411002: "河南省许昌市魏都区",
		411023: "河南省许昌市许昌县",
		411024: "河南省许昌市鄢陵县",
		411025: "河南省许昌市襄城县",
		411081: "河南省许昌市禹州市",
		411082: "河南省许昌市长葛市",
		411100: "河南省漯河市",
		411101: "河南省漯河市市辖区",
		411102: "河南省漯河市源汇区",
		411121: "河南省漯河市舞阳县",
		411122: "河南省漯河市临颍县",
		411123: "河南省漯河市郾城县",
		411200: "河南省三门峡市",
		411201: "河南省三门峡市市辖区",
		411202: "河南省三门峡市湖滨区",
		411221: "河南省三门峡市渑池县",
		411222: "河南省三门峡市陕县",
		411224: "河南省三门峡市卢氏县",
		411281: "河南省三门峡市义马市",
		411282: "河南省三门峡市灵宝市",
		411300: "河南省南阳市",
		411301: "河南省南阳市市辖区",
		411302: "河南省南阳市宛城区",
		411303: "河南省南阳市卧龙区",
		411321: "河南省南阳市南召县",
		411322: "河南省南阳市方城县",
		411323: "河南省南阳市西峡县",
		411324: "河南省南阳市镇平县",
		411325: "河南省南阳市内乡县",
		411326: "河南省南阳市淅川县",
		411327: "河南省南阳市社旗县",
		411328: "河南省南阳市唐河县",
		411329: "河南省南阳市新野县",
		411330: "河南省南阳市桐柏县",
		411381: "河南省南阳市邓州市",
		411400: "河南省商丘市",
		411401: "河南省商丘市市辖区",
		411402: "河南省商丘市梁园区",
		411403: "河南省商丘市睢阳区",
		411421: "河南省商丘市民权县",
		411422: "河南省商丘市睢县",
		411423: "河南省商丘市宁陵县",
		411424: "河南省商丘市柘城县",
		411425: "河南省商丘市虞城县",
		411426: "河南省商丘市夏邑县",
		411481: "河南省商丘市永城市",
		411500: "河南省信阳市",
		411501: "河南省信阳市市辖区",
		411502: "河南省信阳市师河区",
		411503: "河南省信阳市平桥区",
		411521: "河南省信阳市罗山县",
		411522: "河南省信阳市光山县",
		411523: "河南省信阳市新县",
		411524: "河南省信阳市商城县",
		411525: "河南省信阳市固始县",
		411526: "河南省信阳市潢川县",
		411527: "河南省信阳市淮滨县",
		411528: "河南省信阳市息县",
		412700: "河南省周口地区",
		412701: "河南省周口地区周口市",
		412702: "河南省周口地区项城市",
		412721: "河南省周口地区扶沟县",
		412722: "河南省周口地区西华县",
		412723: "河南省周口地区商水县",
		412724: "河南省周口地区太康县",
		412725: "河南省周口地区鹿邑县",
		412726: "河南省周口地区郸城县",
		412727: "河南省周口地区淮阳县",
		412728: "河南省周口地区沈丘县",
		412800: "河南省驻马店地区",
		412801: "河南省驻马店地区驻马店市",
		412821: "河南省驻马店地区确山县",
		412822: "河南省驻马店地区泌阳县",
		412823: "河南省驻马店地区遂平县",
		412824: "河南省驻马店地区西平县",
		412825: "河南省驻马店地区上蔡县",
		412826: "河南省驻马店地区汝南县",
		412827: "河南省驻马店地区平舆县",
		412828: "河南省驻马店地区新蔡县",
		412829: "河南省驻马店地区正阳县",
		42e4: "湖北省",
		420100: "湖北省武汉市",
		420101: "湖北省武汉市市辖区",
		420102: "湖北省武汉市江岸区",
		420103: "湖北省武汉市江汉区",
		420104: "湖北省武汉市乔口区",
		420105: "湖北省武汉市汉阳区",
		420106: "湖北省武汉市武昌区",
		420107: "湖北省武汉市青山区",
		420111: "湖北省武汉市洪山区",
		420112: "湖北省武汉市东西湖区",
		420113: "湖北省武汉市汉南区",
		420114: "湖北省武汉市蔡甸区",
		420115: "湖北省武汉市江夏区",
		420116: "湖北省武汉市黄陂区",
		420117: "湖北省武汉市新洲区",
		420200: "湖北省黄石市",
		420201: "湖北省黄石市市辖区",
		420202: "湖北省黄石市黄石港区",
		420203: "湖北省黄石市石灰窑区",
		420204: "湖北省黄石市下陆区",
		420205: "湖北省黄石市铁山区",
		420222: "湖北省黄石市阳新县",
		420281: "湖北省黄石市大冶市",
		420300: "湖北省十堰市",
		420301: "湖北省十堰市市辖区",
		420302: "湖北省十堰市茅箭区",
		420303: "湖北省十堰市张湾区",
		420321: "湖北省十堰市郧县",
		420322: "湖北省十堰市郧西县",
		420323: "湖北省十堰市竹山县",
		420324: "湖北省十堰市竹溪县",
		420325: "湖北省十堰市房县",
		420381: "湖北省十堰市丹江口市",
		420500: "湖北省宜昌市",
		420501: "湖北省宜昌市市辖区",
		420502: "湖北省宜昌市西陵区",
		420503: "湖北省宜昌市伍家岗区",
		420504: "湖北省宜昌市点军区",
		420505: "湖北省宜昌市虎亭区",
		420521: "湖北省宜昌市宜昌县",
		420525: "湖北省宜昌市远安县",
		420526: "湖北省宜昌市兴山县",
		420527: "湖北省宜昌市秭归县",
		420528: "湖北省宜昌市长阳土家族自治县",
		420529: "湖北省宜昌市五峰土家族自治县",
		420581: "湖北省宜昌市宜都市",
		420582: "湖北省宜昌市当阳市",
		420583: "湖北省宜昌市枝江市",
		420600: "湖北省襄樊市",
		420601: "湖北省襄樊市市辖区",
		420602: "湖北省襄樊市襄城区",
		420606: "湖北省襄樊市樊城区",
		420621: "湖北省襄樊市襄阳县",
		420624: "湖北省襄樊市南漳县",
		420625: "湖北省襄樊市谷城县",
		420626: "湖北省襄樊市保康县",
		420682: "湖北省襄樊市老河口市",
		420683: "湖北省襄樊市枣阳市",
		420684: "湖北省襄樊市宜城市",
		420700: "湖北省鄂州市",
		420701: "湖北省鄂州市市辖区",
		420702: "湖北省鄂州市梁子湖区",
		420703: "湖北省鄂州市华容区",
		420704: "湖北省鄂州市鄂城区",
		420800: "湖北省荆门市",
		420801: "湖北省荆门市市辖区",
		420802: "湖北省荆门市东宝区",
		420821: "湖北省荆门市京山县",
		420822: "湖北省荆门市沙洋县",
		420881: "湖北省荆门市钟祥市",
		420900: "湖北省孝感市",
		420901: "湖北省孝感市市辖区",
		420902: "湖北省孝感市孝南区",
		420921: "湖北省孝感市孝昌县",
		420922: "湖北省孝感市大悟县",
		420923: "湖北省孝感市云梦县",
		420981: "湖北省孝感市应城市",
		420982: "湖北省孝感市安陆市",
		420983: "湖北省孝感市广水市",
		420984: "湖北省孝感市汉川市",
		421e3: "湖北省荆州市",
		421001: "湖北省荆州市市辖区",
		421002: "湖北省荆州市沙市区",
		421003: "湖北省荆州市荆州区",
		421022: "湖北省荆州市公安县",
		421023: "湖北省荆州市监利县",
		421024: "湖北省荆州市江陵县",
		421081: "湖北省荆州市石首市",
		421083: "湖北省荆州市洪湖市",
		421087: "湖北省荆州市松滋市",
		421100: "湖北省黄冈市",
		421101: "湖北省黄冈市市辖区",
		421102: "湖北省黄冈市黄州区",
		421121: "湖北省黄冈市团风县",
		421122: "湖北省黄冈市红安县",
		421123: "湖北省黄冈市罗田县",
		421124: "湖北省黄冈市英山县",
		421125: "湖北省黄冈市浠水县",
		421126: "湖北省黄冈市蕲春县",
		421127: "湖北省黄冈市黄梅县",
		421181: "湖北省黄冈市麻城市",
		421182: "湖北省黄冈市武穴市",
		421200: "湖北省咸宁市",
		421201: "湖北省咸宁市市辖区",
		421202: "湖北省咸宁市咸安区",
		421221: "湖北省咸宁市嘉鱼县",
		421222: "湖北省咸宁市通城县",
		421223: "湖北省咸宁市崇阳县",
		421224: "湖北省咸宁市通山县",
		422800: "湖北省施土家族苗族自治州",
		422801: "湖北省恩施土家族苗族自治州恩施县",
		422802: "湖北省恩施土家族苗族自治州利川市",
		422822: "湖北省恩施土家族苗族自治州建始县",
		422823: "湖北省恩施土家族苗族自治州巴东县",
		422825: "湖北省恩施土家族苗族自治州宣恩县",
		422826: "湖北省恩施土家族苗族自治州咸丰县",
		422827: "湖北省恩施土家族苗族自治州来凤县",
		422828: "湖北省恩施土家族苗族自治州鹤峰县",
		429e3: "湖北省省直辖县级行政单位",
		429001: "湖北省随州市",
		429004: "湖北省仙桃市",
		429005: "湖北省潜江市",
		429006: "湖北省天门市",
		429021: "湖北省神农架林区",
		43e4: "湖南省",
		430100: "湖南省长沙市",
		430101: "湖南省长沙市市辖区",
		430102: "湖南省长沙市芙蓉区",
		430103: "湖南省长沙市天心区",
		430104: "湖南省长沙市岳麓区",
		430105: "湖南省长沙市开福区",
		430111: "湖南省长沙市雨花区",
		430121: "湖南省长沙市长沙县",
		430122: "湖南省长沙市望城县",
		430124: "湖南省长沙市宁乡县",
		430181: "湖南省长沙市浏阳市",
		430200: "湖南省株洲市",
		430201: "湖南省株洲市市辖区",
		430202: "湖南省株洲市荷塘区",
		430203: "湖南省株洲市芦淞区",
		430204: "湖南省株洲市石峰区",
		430211: "湖南省株洲市天元区",
		430221: "湖南省株洲市株洲县",
		430223: "湖南省株洲市攸县",
		430224: "湖南省株洲市茶陵县",
		430225: "湖南省株洲市炎陵县",
		430281: "湖南省株洲市醴陵市",
		430300: "湖南省湘潭市",
		430301: "湖南省湘潭市市辖区",
		430302: "湖南省湘潭市雨湖区",
		430304: "湖南省湘潭市岳塘区",
		430321: "湖南省湘潭市湘潭县",
		430381: "湖南省湘潭市湘乡市",
		430382: "湖南省湘潭市韶山市",
		430400: "湖南省衡阳市",
		430401: "湖南省衡阳市市辖区",
		430402: "湖南省衡阳市江东区",
		430403: "湖南省衡阳市城南区",
		430404: "湖南省衡阳市城北区",
		430411: "湖南省衡阳市郊区",
		430412: "湖南省衡阳市南岳区",
		430421: "湖南省衡阳市衡阳县",
		430422: "湖南省衡阳市衡南县",
		430423: "湖南省衡阳市衡山县",
		430424: "湖南省衡阳市衡东县",
		430426: "湖南省衡阳市祁东县",
		430481: "湖南省衡阳市耒阳市",
		430482: "湖南省衡阳市常宁市",
		430500: "湖南省邵阳市",
		430501: "湖南省邵阳市市辖区",
		430502: "湖南省邵阳市双清区",
		430503: "湖南省邵阳市大祥区",
		430511: "湖南省邵阳市北塔区",
		430521: "湖南省邵阳市邵东县",
		430522: "湖南省邵阳市新邵县",
		430523: "湖南省邵阳市邵阳县",
		430524: "湖南省邵阳市隆回县",
		430525: "湖南省邵阳市洞口县",
		430527: "湖南省邵阳市绥宁县",
		430528: "湖南省邵阳市新宁县",
		430529: "湖南省邵阳市城步苗族自治县",
		430581: "湖南省邵阳市武冈市",
		430600: "湖南省岳阳市",
		430601: "湖南省岳阳市市辖区",
		430602: "湖南省岳阳市岳阳楼区",
		430603: "湖南省岳阳市云溪区",
		430611: "湖南省岳阳市君山区",
		430621: "湖南省岳阳市岳阳县",
		430623: "湖南省岳阳市华容县",
		430624: "湖南省岳阳市湘阴县",
		430626: "湖南省岳阳市平江县",
		430681: "湖南省岳阳市汨罗市",
		430682: "湖南省岳阳市临湘市",
		430700: "湖南省常德市",
		430701: "湖南省常德市市辖区",
		430702: "湖南省常德市武陵区",
		430703: "湖南省常德市鼎城区",
		430721: "湖南省常德市安乡县",
		430722: "湖南省常德市汉寿县",
		430723: "湖南省常德市澧县",
		430724: "湖南省常德市临澧县",
		430725: "湖南省常德市桃源县",
		430726: "湖南省常德市石门县",
		430781: "湖南省常德市津市市",
		430800: "湖南省张家界市",
		430801: "湖南省张家界市市辖区",
		430802: "湖南省张家界市永定区",
		430811: "湖南省张家界市武陵源区",
		430821: "湖南省张家界市慈利县",
		430822: "湖南省张家界市桑植县",
		430900: "湖南省益阳市",
		430901: "湖南省益阳市市辖区",
		430902: "湖南省益阳市资阳区",
		430903: "湖南省益阳市赫山区",
		430921: "湖南省益阳市南县",
		430922: "湖南省益阳市桃江县",
		430923: "湖南省益阳市安化县",
		430981: "湖南省益阳市沅江市",
		431e3: "湖南省郴州市",
		431001: "湖南省郴州市市辖区",
		431002: "湖南省郴州市北湖区",
		431003: "湖南省郴州市苏仙区",
		431021: "湖南省郴州市桂阳县",
		431022: "湖南省郴州市宜章县",
		431023: "湖南省郴州市永兴县",
		431024: "湖南省郴州市嘉禾县",
		431025: "湖南省郴州市临武县",
		431026: "湖南省郴州市汝城县",
		431027: "湖南省郴州市桂东县",
		431028: "湖南省郴州市安仁县",
		431081: "湖南省郴州市资兴市",
		431100: "湖南省永州市",
		431101: "湖南省永州市市辖区",
		431102: "湖南省永州市芝山区",
		431103: "湖南省永州市冷水滩区",
		431121: "湖南省永州市祁阳县",
		431122: "湖南省永州市东安县",
		431123: "湖南省永州市双牌县",
		431124: "湖南省永州市道县",
		431125: "湖南省永州市江永县",
		431126: "湖南省永州市宁远县",
		431127: "湖南省永州市蓝山县",
		431128: "湖南省永州市新田县",
		431129: "湖南省永州市江华瑶族自治县",
		431200: "湖南省怀化市",
		431201: "湖南省怀化市市辖区",
		431202: "湖南省怀化市鹤城区",
		431221: "湖南省怀化市中方县",
		431222: "湖南省怀化市沅陵县",
		431223: "湖南省怀化市辰溪县",
		431224: "湖南省怀化市溆浦县",
		431225: "湖南省怀化市会同县",
		431226: "湖南省怀化市麻阳苗族自治县",
		431227: "湖南省怀化市新晃侗族自治县",
		431228: "湖南省怀化市芷江侗族自治县",
		431229: "湖南省怀化市靖州苗族侗族自治县",
		431230: "湖南省怀化市通道侗族自治县",
		431281: "湖南省怀化市洪江市",
		432500: "湖南省娄底地区",
		432501: "湖南省娄底地区娄底市",
		432502: "湖南省娄底地区冷水江市",
		432503: "湖南省娄底地区涟源市",
		432522: "湖南省娄底地区双峰县",
		432524: "湖南省娄底地区新化县",
		433e3: "湖南省怀化市",
		433001: "湖南省怀化市",
		433100: "湖南省湘西土家族苗族自治州",
		433101: "湖南省湘西土家族苗族自治州吉首市",
		433122: "湖南省湘西土家族苗族自治州泸溪县",
		433123: "湖南省湘西土家族苗族自治州凤凰县",
		433124: "湖南省湘西土家族苗族自治州花垣县",
		433125: "湖南省湘西土家族苗族自治州保靖县",
		433126: "湖南省湘西土家族苗族自治州古丈县",
		433127: "湖南省湘西土家族苗族自治州永顺县",
		433130: "湖南省湘西土家族苗族自治州龙山县",
		44e4: "广东省",
		440100: "广东省广州市",
		440101: "广东省广州市市辖区",
		440102: "广东省广州市东山区",
		440103: "广东省广州市荔湾区",
		440104: "广东省广州市越秀区",
		440105: "广东省广州市海珠区",
		440106: "广东省广州市天河区",
		440107: "广东省广州市芳村区",
		440111: "广东省广州市白云区",
		440112: "广东省广州市黄埔区",
		440181: "广东省广州市番禺市",
		440182: "广东省广州市花都市",
		440183: "广东省广州市增城市",
		440184: "广东省广州市从化市",
		440200: "广东省韶关市",
		440201: "广东省韶关市市辖区",
		440202: "广东省韶关市北江区",
		440203: "广东省韶关市武江区",
		440204: "广东省韶关市浈江区",
		440221: "广东省韶关市曲江县",
		440222: "广东省韶关市始兴县",
		440224: "广东省韶关市仁化县",
		440229: "广东省韶关市翁源县",
		440232: "广东省韶关市乳源瑶族自治县",
		440233: "广东省韶关市新丰县",
		440281: "广东省韶关市乐昌市",
		440282: "广东省韶关市南雄市",
		440300: "广东省深圳市",
		440301: "广东省深圳市市辖区",
		440303: "广东省深圳市罗湖区",
		440304: "广东省深圳市福田区",
		440305: "广东省深圳市南山区",
		440306: "广东省深圳市宝安区",
		440307: "广东省深圳市龙岗区",
		440308: "广东省深圳市盐田区",
		440400: "广东省珠海市",
		440401: "广东省珠海市市辖区",
		440402: "广东省珠海市香洲区",
		440421: "广东省珠海市斗门县",
		440500: "广东省汕头市",
		440501: "广东省汕头市市辖区",
		440506: "广东省汕头市达濠区",
		440507: "广东省汕头市龙湖区",
		440508: "广东省汕头市金园区",
		440509: "广东省汕头市升平区",
		440510: "广东省汕头市河浦区",
		440523: "广东省汕头市南澳县",
		440582: "广东省汕头市潮阳市",
		440583: "广东省汕头市澄海市",
		440600: "广东省佛山市",
		440601: "广东省佛山市市辖区",
		440602: "广东省佛山市城区",
		440603: "广东省佛山市石湾区",
		440681: "广东省佛山市顺德市",
		440682: "广东省佛山市南海市",
		440683: "广东省佛山市三水市",
		440684: "广东省佛山市高明市",
		440700: "广东省江门市",
		440701: "广东省江门市市辖区",
		440703: "广东省江门市蓬江区",
		440704: "广东省江门市江海区",
		440781: "广东省江门市台山市",
		440782: "广东省江门市新会市",
		440783: "广东省江门市开平市",
		440784: "广东省江门市鹤山市",
		440785: "广东省江门市恩平市",
		440800: "广东省湛江市",
		440801: "广东省湛江市市辖区",
		440802: "广东省湛江市赤坎区",
		440803: "广东省湛江市霞山区",
		440804: "广东省湛江市坡头区",
		440811: "广东省湛江市麻章区",
		440823: "广东省湛江市遂溪县",
		440825: "广东省湛江市徐闻县",
		440881: "广东省湛江市廉江市",
		440882: "广东省湛江市雷州市",
		440883: "广东省湛江市吴川市",
		440900: "广东省茂名市",
		440901: "广东省茂名市市辖区",
		440902: "广东省茂名市茂南区",
		440923: "广东省茂名市电白县",
		440981: "广东省茂名市高州市",
		440982: "广东省茂名市化州市",
		440983: "广东省茂名市信宜市",
		441200: "广东省肇庆市",
		441201: "广东省肇庆市市辖区",
		441202: "广东省肇庆市端州区",
		441203: "广东省肇庆市鼎湖区",
		441223: "广东省肇庆市广宁县",
		441224: "广东省肇庆市怀集县",
		441225: "广东省肇庆市封开县",
		441226: "广东省肇庆市德庆县",
		441283: "广东省肇庆市高要市",
		441284: "广东省肇庆市四会市",
		441300: "广东省惠州市",
		441301: "广东省惠州市市辖区",
		441302: "广东省惠州市惠城区",
		441322: "广东省惠州市博罗县",
		441323: "广东省惠州市惠东县",
		441324: "广东省惠州市龙门县",
		441381: "广东省惠州市惠阳市",
		441400: "广东省梅州市",
		441401: "广东省梅州市市辖区",
		441402: "广东省梅州市梅江区",
		441421: "广东省梅州市梅县",
		441422: "广东省梅州市大埔县",
		441423: "广东省梅州市丰顺县",
		441424: "广东省梅州市五华县",
		441426: "广东省梅州市平远县",
		441427: "广东省梅州市蕉岭县",
		441481: "广东省梅州市兴宁市",
		441500: "广东省汕尾市",
		441501: "广东省汕尾市市辖区",
		441502: "广东省汕尾市城区",
		441521: "广东省汕尾市海丰县",
		441523: "广东省汕尾市陆河县",
		441581: "广东省汕尾市陆丰市",
		441600: "广东省河源市",
		441601: "广东省河源市市辖区",
		441602: "广东省河源市源城区",
		441621: "广东省河源市紫金县",
		441622: "广东省河源市龙川县",
		441623: "广东省河源市连平县",
		441624: "广东省河源市和平县",
		441625: "广东省河源市东源县",
		441700: "广东省阳江市",
		441701: "广东省阳江市市辖区",
		441702: "广东省阳江市江城区",
		441721: "广东省阳江市阳西县",
		441723: "广东省阳江市阳东县",
		441781: "广东省阳江市阳春市",
		441800: "广东省清远市",
		441801: "广东省清远市市辖区",
		441802: "广东省清远市清城区",
		441821: "广东省清远市佛冈县",
		441823: "广东省清远市阳山县",
		441825: "广东省清远市连山壮族瑶族自治县",
		441826: "广东省清远市连南瑶族自治县",
		441827: "广东省清远市清新县",
		441881: "广东省清远市英德市",
		441882: "广东省清远市连州市",
		441900: "广东省东莞市",
		441901: "广东省东莞市市辖区",
		442e3: "广东省中山市",
		442001: "广东省中山市市辖区",
		445100: "广东省潮州市",
		445101: "广东省潮州市市辖区",
		445102: "广东省潮州市湘桥区",
		445121: "广东省潮州市潮安县",
		445122: "广东省潮州市饶平县",
		445200: "广东省揭阳市",
		445201: "广东省揭阳市市辖区",
		445202: "广东省揭阳市榕城区",
		445221: "广东省揭阳市揭东县",
		445222: "广东省揭阳市揭西县",
		445224: "广东省揭阳市惠来县",
		445281: "广东省揭阳市普宁市",
		445300: "广东省云浮市",
		445301: "广东省云浮市市辖区",
		445302: "广东省云浮市云城区",
		445321: "广东省云浮市新兴县",
		445322: "广东省云浮市郁南县",
		445323: "广东省云浮市云安县",
		445381: "广东省云浮市罗定市",
		45e4: "广西壮族自治区",
		450100: "广西壮族自治区南宁市",
		450101: "广西壮族自治区南宁市市辖区",
		450102: "广西壮族自治区南宁市兴宁区",
		450103: "广西壮族自治区南宁市新城区",
		450104: "广西壮族自治区南宁市城北区",
		450105: "广西壮族自治区南宁市江南区",
		450106: "广西壮族自治区南宁市永新区",
		450111: "广西壮族自治区南宁市市郊区",
		450121: "广西壮族自治区南宁市邕宁县",
		450122: "广西壮族自治区南宁市武鸣县",
		450200: "广西壮族自治区柳州市",
		450201: "广西壮族自治区柳州市市辖区",
		450202: "广西壮族自治区柳州市城中区",
		450203: "广西壮族自治区柳州市鱼峰区",
		450204: "广西壮族自治区柳州市柳南区",
		450205: "广西壮族自治区柳州市柳北区",
		450211: "广西壮族自治区柳州市市郊区",
		450221: "广西壮族自治区柳州市柳江县",
		450222: "广西壮族自治区柳州市柳城县",
		450300: "广西壮族自治区桂林市",
		450301: "广西壮族自治区桂林市市辖区",
		450302: "广西壮族自治区桂林市秀峰区",
		450303: "广西壮族自治区桂林市叠彩区",
		450304: "广西壮族自治区桂林市象山区",
		450305: "广西壮族自治区桂林市七星区",
		450311: "广西壮族自治区桂林市雁山区",
		450321: "广西壮族自治区桂林市阳朔县",
		450322: "广西壮族自治区桂林市临桂县",
		450323: "广西壮族自治区桂林市灵川县",
		450324: "广西壮族自治区桂林市全州县",
		450325: "广西壮族自治区桂林市兴安县",
		450326: "广西壮族自治区桂林市永福县",
		450327: "广西壮族自治区桂林市灌阳县",
		450328: "广西壮族自治区桂林市龙胜各族自治县",
		450329: "广西壮族自治区桂林市资源县",
		450330: "广西壮族自治区桂林市平乐县",
		450331: "广西壮族自治区桂林市荔浦县",
		450332: "广西壮族自治区桂林市恭城瑶族自治县",
		450400: "广西壮族自治区梧州市",
		450401: "广西壮族自治区梧州市市辖区",
		450403: "广西壮族自治区梧州市万秀区",
		450404: "广西壮族自治区梧州市蝶山区",
		450411: "广西壮族自治区梧州市市郊区",
		450421: "广西壮族自治区梧州市苍梧县",
		450422: "广西壮族自治区梧州市藤县",
		450423: "广西壮族自治区梧州市蒙山县",
		450481: "广西壮族自治区梧州市岑溪市",
		450500: "广西壮族自治区北海市",
		450501: "广西壮族自治区北海市市辖区",
		450502: "广西壮族自治区北海市海城区",
		450503: "广西壮族自治区北海市银海区",
		450512: "广西壮族自治区北海市铁山港区",
		450521: "广西壮族自治区北海市合浦县",
		450600: "广西壮族自治区防城港市",
		450601: "广西壮族自治区防城港市市辖区",
		450602: "广西壮族自治区防城港市港口区",
		450603: "广西壮族自治区防城港市防城区",
		450621: "广西壮族自治区防城港市上思县",
		450681: "广西壮族自治区防城港市东兴市",
		450700: "广西壮族自治区钦州市",
		450701: "广西壮族自治区钦州市市辖区",
		450702: "广西壮族自治区钦州市钦南区",
		450703: "广西壮族自治区钦州市钦北区",
		450721: "广西壮族自治区钦州市灵山县",
		450722: "广西壮族自治区钦州市浦北县",
		450800: "广西壮族自治区贵港市",
		450801: "广西壮族自治区贵港市市辖区",
		450802: "广西壮族自治区贵港市港北区",
		450803: "广西壮族自治区贵港市港南区",
		450821: "广西壮族自治区贵港市平南县",
		450881: "广西壮族自治区贵港市桂平市",
		450900: "广西壮族自治区玉林市",
		450901: "广西壮族自治区玉林市市辖区",
		450902: "广西壮族自治区玉林市玉州区",
		450921: "广西壮族自治区玉林市容县",
		450922: "广西壮族自治区玉林市陆川县",
		450923: "广西壮族自治区玉林市博白县",
		450924: "广西壮族自治区玉林市兴业县",
		450981: "广西壮族自治区玉林市北流市",
		452100: "广西壮族自治区南宁地区",
		452101: "广西壮族自治区南宁地区凭祥市",
		452122: "广西壮族自治区南宁地区横县",
		452123: "广西壮族自治区南宁地区宾阳县",
		452124: "广西壮族自治区南宁地区上林县",
		452126: "广西壮族自治区南宁地区隆安县",
		452127: "广西壮族自治区南宁地区马山县",
		452128: "广西壮族自治区南宁地区扶绥县",
		452129: "广西壮族自治区南宁地区崇左县",
		452130: "广西壮族自治区南宁地区大新县",
		452131: "广西壮族自治区南宁地区天等县",
		452132: "广西壮族自治区南宁地区宁明县",
		452133: "广西壮族自治区南宁地区龙州县",
		452200: "广西壮族自治区柳州地区",
		452201: "广西壮族自治区柳州地区合山市",
		452223: "广西壮族自治区柳州地区鹿寨县",
		452224: "广西壮族自治区柳州地区象州县",
		452225: "广西壮族自治区柳州地区武宣县",
		452226: "广西壮族自治区柳州地区来宾县",
		452227: "广西壮族自治区柳州地区融安县",
		452228: "广西壮族自治区柳州地区三江侗族自治县",
		452229: "广西壮族自治区柳州地区融水苗族自治县",
		452230: "广西壮族自治区柳州地区金秀瑶族自治县",
		452231: "广西壮族自治区柳州地区忻城县",
		452400: "广西壮族自治区贺州地区",
		452402: "广西壮族自治区贺州地区贺州市",
		452424: "广西壮族自治区贺州地区昭平县",
		452427: "广西壮族自治区贺州地区钟山县",
		452428: "广西壮族自治区贺州地区富川瑶族自治县",
		452600: "广西壮族自治区百色地区",
		452601: "广西壮族自治区百色地区百色市",
		452622: "广西壮族自治区百色地区田阳县",
		452623: "广西壮族自治区百色地区田东县",
		452624: "广西壮族自治区百色地区平果县",
		452625: "广西壮族自治区百色地区德保县",
		452626: "广西壮族自治区百色地区靖西县",
		452627: "广西壮族自治区百色地区那坡县",
		452628: "广西壮族自治区百色地区凌云县",
		452629: "广西壮族自治区百色地区乐业县",
		452630: "广西壮族自治区百色地区田林县",
		452631: "广西壮族自治区百色地区隆林各族自治县",
		452632: "广西壮族自治区百色地区西林县",
		452700: "广西壮族自治区河池地区",
		452701: "广西壮族自治区河池地区河池市",
		452702: "广西壮族自治区河池地区宜州市",
		452723: "广西壮族自治区河池地区罗城仫佬族自治县",
		452724: "广西壮族自治区河池地区环江毛南族自治县",
		452725: "广西壮族自治区河池地区南丹县",
		452726: "广西壮族自治区河池地区天峨县",
		452727: "广西壮族自治区河池地区凤山县",
		452728: "广西壮族自治区河池地区东兰县",
		452729: "广西壮族自治区河池地区巴马瑶族自治县",
		452730: "广西壮族自治区河池地区都安瑶族自治县",
		452731: "广西壮族自治区河池地区大化瑶族自治县",
		46e4: "海南省",
		460001: "海南省三亚市通什市",
		460002: "海南省三亚市琼海市",
		460003: "海南省三亚市儋州市",
		460004: "海南省三亚市琼山市",
		460005: "海南省三亚市文昌市",
		460006: "海南省三亚市万宁市",
		460007: "海南省三亚市东方市",
		460025: "海南省三亚市定安县",
		460026: "海南省三亚市屯昌县",
		460027: "海南省三亚市澄迈县",
		460028: "海南省三亚市临高县",
		460030: "海南省三亚市白沙黎族自治县",
		460031: "海南省三亚市昌江黎族自治县",
		460033: "海南省三亚市乐东黎族自治县",
		460034: "海南省三亚市陵水黎族自治县",
		460035: "海南省三亚市保亭黎族苗族自治县",
		460036: "海南省三亚市琼中黎族苗族自治县",
		460037: "海南省西沙群岛",
		460038: "海南省南沙群岛",
		460039: "海南省中沙群岛的岛礁及其海域",
		460100: "海南省海口市",
		460101: "海南省海口市市辖区",
		460102: "海南省海口市振东区",
		460103: "海南省海口市新华区",
		460104: "海南省海口市秀英区",
		460200: "海南省三亚市",
		460201: "海南省三亚市市辖区",
		5e5: "重庆市",
		500100: "重庆市市辖区",
		500101: "重庆市万州区",
		500102: "重庆市涪陵区",
		500103: "重庆市渝中区",
		500104: "重庆市大渡口区",
		500105: "重庆市江北区",
		500106: "重庆市沙坪坝区",
		500107: "重庆市九龙坡区",
		500108: "重庆市南岸区",
		500109: "重庆市北碚区",
		500110: "重庆市万盛区",
		500111: "重庆市双桥区",
		500112: "重庆市渝北区",
		500113: "重庆市巴南区",
		500200: "重庆市县",
		500221: "重庆市长寿县",
		500222: "重庆市綦江县",
		500223: "重庆市潼南县",
		500224: "重庆市铜梁县",
		500225: "重庆市大足县",
		500226: "重庆市荣昌县",
		500227: "重庆市璧山县",
		500228: "重庆市梁平县",
		500229: "重庆市城口县",
		500230: "重庆市丰都县",
		500231: "重庆市垫江县",
		500232: "重庆市武隆县",
		500233: "重庆市忠县",
		500234: "重庆市开县",
		500235: "重庆市云阳县",
		500236: "重庆市奉节县",
		500237: "重庆市巫山县",
		500238: "重庆市巫溪县",
		500239: "重庆市黔江土家族苗族自治县",
		500240: "重庆市石柱土家族自治县",
		500241: "重庆市秀山土家族苗族自治县",
		500242: "重庆市酉阳土家族苗族自治县",
		500243: "重庆市彭水苗族土家族自治县",
		500300: "重庆市(市)",
		500381: "重庆市江津市",
		500382: "重庆市合川市",
		500383: "重庆市永川市",
		500384: "重庆市南川市",
		51e4: "四川省",
		510100: "四川省成都市",
		510101: "四川省成都市市辖区",
		510104: "四川省成都市锦江区",
		510105: "四川省成都市青羊区",
		510106: "四川省成都市金牛区",
		510107: "四川省成都市武侯区",
		510108: "四川省成都市成华区",
		510112: "四川省成都市龙泉驿区",
		510113: "四川省成都市青白江区",
		510121: "四川省成都市金堂县",
		510122: "四川省成都市双流县",
		510123: "四川省成都市温江县",
		510124: "四川省成都市郫县",
		510125: "四川省成都市新都县",
		510129: "四川省成都市大邑县",
		510131: "四川省成都市蒲江县",
		510132: "四川省成都市新津县",
		510181: "四川省成都市都江堰市",
		510182: "四川省成都市彭州市",
		510183: "四川省成都市邛崃市",
		510184: "四川省成都市崇州市",
		510300: "四川省自贡市",
		510301: "四川省自贡市市辖区",
		510302: "四川省自贡市自流井区",
		510303: "四川省自贡市贡井区",
		510304: "四川省自贡市大安区",
		510311: "四川省自贡市沿滩区",
		510321: "四川省自贡市荣县",
		510322: "四川省自贡市富顺县",
		510400: "四川省攀枝花市",
		510401: "四川省攀枝花市市辖区",
		510402: "四川省攀枝花市东区",
		510403: "四川省攀枝花市西区",
		510411: "四川省攀枝花市仁和区",
		510421: "四川省攀枝花市米易县",
		510422: "四川省攀枝花市盐边县",
		510500: "四川省泸州市",
		510501: "四川省泸州市市辖区",
		510502: "四川省泸州市江阳区",
		510503: "四川省泸州市纳溪区",
		510504: "四川省泸州市龙马潭区",
		510521: "四川省泸州市泸县",
		510522: "四川省泸州市合江县",
		510524: "四川省泸州市叙永县",
		510525: "四川省泸州市古蔺县",
		510600: "四川省德阳市",
		510601: "四川省德阳市市辖区",
		510603: "四川省德阳市旌阳区",
		510623: "四川省德阳市中江县",
		510626: "四川省德阳市罗江县",
		510681: "四川省德阳市广汉市",
		510682: "四川省德阳市什邡市",
		510683: "四川省德阳市绵竹市",
		510700: "四川省绵阳市",
		510701: "四川省绵阳市市辖区",
		510703: "四川省绵阳市涪城区",
		510704: "四川省绵阳市游仙区",
		510722: "四川省绵阳市三台县",
		510723: "四川省绵阳市盐亭县",
		510724: "四川省绵阳市安县",
		510725: "四川省绵阳市梓潼县",
		510726: "四川省绵阳市北川县",
		510727: "四川省绵阳市平武县",
		510781: "四川省绵阳市江油市",
		510800: "四川省广元市",
		510801: "四川省广元市市辖区",
		510802: "四川省广元市市中区",
		510811: "四川省广元市元坝区",
		510812: "四川省广元市朝天区",
		510821: "四川省广元市旺苍县",
		510822: "四川省广元市青川县",
		510823: "四川省广元市剑阁县",
		510824: "四川省广元市苍溪县",
		510900: "四川省遂宁市",
		510901: "四川省遂宁市市辖区",
		510902: "四川省遂宁市市中区",
		510921: "四川省遂宁市蓬溪县",
		510922: "四川省遂宁市射洪县",
		510923: "四川省遂宁市大英县",
		511e3: "四川省内江市",
		511001: "四川省内江市市辖区",
		511002: "四川省内江市市中区",
		511011: "四川省内江市东兴区",
		511024: "四川省内江市威远县",
		511025: "四川省内江市资中县",
		511028: "四川省内江市隆昌县",
		511100: "四川省乐山市",
		511101: "四川省乐山市市辖区",
		511102: "四川省乐山市市中区",
		511111: "四川省乐山市沙湾区",
		511112: "四川省乐山市五通桥区",
		511113: "四川省乐山市金口河区",
		511123: "四川省乐山市犍为县",
		511124: "四川省乐山市井研县",
		511126: "四川省乐山市夹江县",
		511129: "四川省乐山市沐川县",
		511132: "四川省乐山市峨边彝族自治县",
		511133: "四川省乐山市马边彝族自治县",
		511181: "四川省乐山市峨眉山市",
		511300: "四川省南充市",
		511301: "四川省南充市市辖区",
		511302: "四川省南充市顺庆区",
		511303: "四川省南充市高坪区",
		511304: "四川省南充市嘉陵区",
		511321: "四川省南充市南部县",
		511322: "四川省南充市营山县",
		511323: "四川省南充市蓬安县",
		511324: "四川省南充市仪陇县",
		511325: "四川省南充市西充县",
		511381: "四川省南充市阆中市",
		511500: "四川省宜宾市",
		511501: "四川省宜宾市市辖区",
		511502: "四川省宜宾市翠屏区",
		511521: "四川省宜宾市宜宾县",
		511522: "四川省宜宾市南溪县",
		511523: "四川省宜宾市江安县",
		511524: "四川省宜宾市长宁县",
		511525: "四川省宜宾市高县",
		511526: "四川省宜宾市珙县",
		511527: "四川省宜宾市筠连县",
		511528: "四川省宜宾市兴文县",
		511529: "四川省宜宾市屏山县",
		511600: "四川省广安市",
		511601: "四川省广安市市辖区",
		511602: "四川省广安市广安区",
		511621: "四川省广安市岳池县",
		511622: "四川省广安市武胜县",
		511623: "四川省广安市邻水县",
		511681: "四川省广安市华蓥市",
		513e3: "四川省达川地区",
		513001: "四川省达川地区达川市",
		513002: "四川省达川地区万源市",
		513021: "四川省达川地区达县",
		513022: "四川省达川地区宣汉县",
		513023: "四川省达川地区开江县",
		513029: "四川省达川地区大竹县",
		513030: "四川省达川地区渠县",
		513100: "四川省雅安地区",
		513101: "四川省雅安地区雅安市",
		513122: "四川省雅安地区名山县",
		513123: "四川省雅安地区荥经县",
		513124: "四川省雅安地区汉源县",
		513125: "四川省雅安地区石棉县",
		513126: "四川省雅安地区天全县",
		513127: "四川省雅安地区芦山县",
		513128: "四川省雅安地区宝兴县",
		513200: "四川省阿坝藏族羌族自治州",
		513221: "四川省阿坝藏族羌族自治州汶川县",
		513222: "四川省阿坝藏族羌族自治州理县",
		513223: "四川省阿坝藏族羌族自治州茂县",
		513224: "四川省阿坝藏族羌族自治州松潘县",
		513225: "四川省阿坝藏族羌族自治州九寨沟县",
		513226: "四川省阿坝藏族羌族自治州金川县",
		513227: "四川省阿坝藏族羌族自治州小金县",
		513228: "四川省阿坝藏族羌族自治州黑水县",
		513229: "四川省阿坝藏族羌族自治州马尔康县",
		513230: "四川省阿坝藏族羌族自治州壤塘县",
		513231: "四川省阿坝藏族羌族自治州阿坝县",
		513232: "四川省阿坝藏族羌族自治州若尔盖县",
		513233: "四川省阿坝藏族羌族自治州红原县",
		513300: "四川省甘孜藏族自治州",
		513321: "四川省甘孜藏族自治州康定县",
		513322: "四川省甘孜藏族自治州泸定县",
		513323: "四川省甘孜藏族自治州丹巴县",
		513324: "四川省甘孜藏族自治州九龙县",
		513325: "四川省甘孜藏族自治州雅江县",
		513326: "四川省甘孜藏族自治州道孚县",
		513327: "四川省甘孜藏族自治州炉霍县",
		513328: "四川省甘孜藏族自治州甘孜县",
		513329: "四川省甘孜藏族自治州新龙县",
		513330: "四川省甘孜藏族自治州德格县",
		513331: "四川省甘孜藏族自治州白玉县",
		513332: "四川省甘孜藏族自治州石渠县",
		513333: "四川省甘孜藏族自治州色达县",
		513334: "四川省甘孜藏族自治州理塘县",
		513335: "四川省甘孜藏族自治州巴塘县",
		513336: "四川省甘孜藏族自治州乡城县",
		513337: "四川省甘孜藏族自治州稻城县",
		513338: "四川省甘孜藏族自治州得荣县",
		513400: "四川省凉山彝族自治州",
		513401: "四川省凉山彝族自治州西昌市",
		513422: "四川省凉山彝族自治州木里藏族自治县",
		513423: "四川省凉山彝族自治州盐源县",
		513424: "四川省凉山彝族自治州德昌县",
		513425: "四川省凉山彝族自治州会理县",
		513426: "四川省凉山彝族自治州会东县",
		513427: "四川省凉山彝族自治州宁南县",
		513428: "四川省凉山彝族自治州普格县",
		513429: "四川省凉山彝族自治州布拖县",
		513430: "四川省凉山彝族自治州金阳县",
		513431: "四川省凉山彝族自治州昭觉县",
		513432: "四川省凉山彝族自治州喜德县",
		513433: "四川省凉山彝族自治州冕宁县",
		513434: "四川省凉山彝族自治州越西县",
		513435: "四川省凉山彝族自治州甘洛县",
		513436: "四川省凉山彝族自治州美姑县",
		513437: "四川省凉山彝族自治州雷波县",
		513700: "四川省巴中地区",
		513701: "四川省巴中地区巴中市",
		513721: "四川省巴中地区通江县",
		513722: "四川省巴中地区南江县",
		513723: "四川省巴中地区平昌县",
		513800: "四川省眉山地区",
		513821: "四川省眉山地区眉山县",
		513822: "四川省眉山地区仁寿县",
		513823: "四川省眉山地区彭山县",
		513824: "四川省眉山地区洪雅县",
		513825: "四川省眉山地区丹棱县",
		513826: "四川省眉山地区青神县",
		513900: "四川省眉山地区资阳地区",
		513901: "四川省眉山地区资阳市",
		513902: "四川省眉山地区简阳市",
		513921: "四川省眉山地区安岳县",
		513922: "四川省眉山地区乐至县",
		52e4: "贵州省",
		520100: "贵州省贵阳市",
		520101: "贵州省贵阳市市辖区",
		520102: "贵州省贵阳市南明区",
		520103: "贵州省贵阳市云岩区",
		520111: "贵州省贵阳市花溪区",
		520112: "贵州省贵阳市乌当区",
		520113: "贵州省贵阳市白云区",
		520121: "贵州省贵阳市开阳县",
		520122: "贵州省贵阳市息烽县",
		520123: "贵州省贵阳市修文县",
		520181: "贵州省贵阳市清镇市",
		520200: "贵州省六盘水市",
		520201: "贵州省六盘水市钟山区",
		520202: "贵州省六盘水市盘县特区",
		520203: "贵州省六盘水市六枝特区",
		520221: "贵州省六盘水市水城县",
		520300: "贵州省遵义市",
		520301: "贵州省遵义市市辖区",
		520302: "贵州省遵义市红花岗区",
		520321: "贵州省遵义市遵义县",
		520322: "贵州省遵义市桐梓县",
		520323: "贵州省遵义市绥阳县",
		520324: "贵州省遵义市正安县",
		520325: "贵州省遵义市道真仡佬族苗族自治县",
		520326: "贵州省遵义市务川仡佬族苗族自治县",
		520327: "贵州省遵义市凤冈县",
		520328: "贵州省遵义市湄潭县",
		520329: "贵州省遵义市余庆县",
		520330: "贵州省遵义市习水县",
		520381: "贵州省遵义市赤水市",
		520382: "贵州省遵义市仁怀市",
		522200: "贵州省铜仁地区",
		522201: "贵州省铜仁地区铜仁市",
		522222: "贵州省铜仁地区江口县",
		522223: "贵州省铜仁地区玉屏侗族自治县",
		522224: "贵州省铜仁地区石阡县",
		522225: "贵州省铜仁地区思南县",
		522226: "贵州省铜仁地区印江土家族苗族自治县",
		522227: "贵州省铜仁地区德江县",
		522228: "贵州省铜仁地区沿河土家族自治县",
		522229: "贵州省铜仁地区松桃苗族自治县",
		522230: "贵州省铜仁地区万山特区",
		522300: "贵州省黔西南布依族苗族自治州",
		522301: "贵州省黔西南布依族苗族自治州兴义市",
		522322: "贵州省黔西南布依族苗族自治州兴仁县",
		522323: "贵州省黔西南布依族苗族自治州普安县",
		522324: "贵州省黔西南布依族苗族自治州晴隆县",
		522325: "贵州省黔西南布依族苗族自治州贞丰县",
		522326: "贵州省黔西南布依族苗族自治州望谟县",
		522327: "贵州省黔西南布依族苗族自治州册亨县",
		522328: "贵州省黔西南布依族苗族自治州安龙县",
		522400: "贵州省毕节地区",
		522401: "贵州省毕节地区毕节市",
		522422: "贵州省毕节地区大方县",
		522423: "贵州省毕节地区黔西县",
		522424: "贵州省毕节地区金沙县",
		522425: "贵州省毕节地区织金县",
		522426: "贵州省毕节地区纳雍县",
		522427: "贵州省毕节地区威宁彝族回族苗族自治县",
		522428: "贵州省毕节地区赫章县",
		522500: "贵州省安顺地区",
		522501: "贵州省安顺地区安顺市",
		522526: "贵州省安顺地区平坝县",
		522527: "贵州省安顺地区普定县",
		522528: "贵州省安顺地区关岭布依族苗族自治县",
		522529: "贵州省安顺地区镇宁布依族苗族自治县",
		522530: "贵州省安顺地区紫云苗族布依族自治县",
		522600: "贵州省黔东南苗族侗族自治州",
		522601: "贵州省黔东南苗族侗族自治州凯里市",
		522622: "贵州省黔东南苗族侗族自治州黄平县",
		522623: "贵州省黔东南苗族侗族自治州施秉县",
		522624: "贵州省黔东南苗族侗族自治州三穗县",
		522625: "贵州省黔东南苗族侗族自治州镇远县",
		522626: "贵州省黔东南苗族侗族自治州岑巩县",
		522627: "贵州省黔东南苗族侗族自治州天柱县",
		522628: "贵州省黔东南苗族侗族自治州锦屏县",
		522629: "贵州省黔东南苗族侗族自治州剑河县",
		522630: "贵州省黔东南苗族侗族自治州台江县",
		522631: "贵州省黔东南苗族侗族自治州黎平县",
		522632: "贵州省黔东南苗族侗族自治州榕江县",
		522633: "贵州省黔东南苗族侗族自治州从江县",
		522634: "贵州省黔东南苗族侗族自治州雷山县",
		522635: "贵州省黔东南苗族侗族自治州麻江县",
		522636: "贵州省黔东南苗族侗族自治州丹寨县",
		522700: "贵州省黔南布依族苗族自治州",
		522701: "贵州省黔南布依族苗族自治州都匀市",
		522702: "贵州省黔南布依族苗族自治州福泉市",
		522722: "贵州省黔南布依族苗族自治州荔波县",
		522723: "贵州省黔南布依族苗族自治州贵定县",
		522725: "贵州省黔南布依族苗族自治州瓮安县",
		522726: "贵州省黔南布依族苗族自治州独山县",
		522727: "贵州省黔南布依族苗族自治州平塘县",
		522728: "贵州省黔南布依族苗族自治州罗甸县",
		522729: "贵州省黔南布依族苗族自治州长顺县",
		522730: "贵州省黔南布依族苗族自治州龙里县",
		522731: "贵州省黔南布依族苗族自治州惠水县",
		522732: "贵州省黔南布依族苗族自治州三都水族自治县",
		53e4: "云南省",
		530100: "云南省昆明市",
		530101: "云南省昆明市市辖区",
		530102: "云南省昆明市五华区",
		530103: "云南省昆明市盘龙区",
		530111: "云南省昆明市官渡区",
		530112: "云南省昆明市西山区",
		530113: "云南省昆明市东川区",
		530121: "云南省昆明市呈贡县",
		530122: "云南省昆明市晋宁县",
		530124: "云南省昆明市富民县",
		530125: "云南省昆明市宜良县",
		530126: "云南省昆明市石林彝族自治县",
		530127: "云南省昆明市嵩明县",
		530128: "云南省昆明市禄劝彝族苗族自治县",
		530129: "云南省昆明市寻甸回族彝族自治县",
		530181: "云南省昆明市安宁市",
		530300: "云南省曲靖市",
		530301: "云南省曲靖市市辖区",
		530302: "云南省曲靖市麒麟区",
		530321: "云南省曲靖市马龙县",
		530322: "云南省曲靖市陆良县",
		530323: "云南省曲靖市师宗县",
		530324: "云南省曲靖市罗平县",
		530325: "云南省曲靖市富源县",
		530326: "云南省曲靖市会泽县",
		530328: "云南省曲靖市沾益县",
		530381: "云南省曲靖市宣威市",
		530400: "云南省玉溪市",
		530401: "云南省玉溪市市辖区",
		530402: "云南省玉溪市红塔区",
		530421: "云南省玉溪市江川县",
		530422: "云南省玉溪市澄江县",
		530423: "云南省玉溪市通海县",
		530424: "云南省玉溪市华宁县",
		530425: "云南省玉溪市易门县",
		530426: "云南省玉溪市峨山彝族自治县",
		530427: "云南省玉溪市新平彝族傣族自治县",
		530428: "云南省玉溪市元江哈尼族彝族傣族自治县",
		532100: "云南省昭通地区",
		532101: "云南省昭通地区昭通市",
		532122: "云南省昭通地区鲁甸县",
		532123: "云南省昭通地区巧家县",
		532124: "云南省昭通地区盐津县",
		532125: "云南省昭通地区大关县",
		532126: "云南省昭通地区永善县",
		532127: "云南省昭通地区绥江县",
		532128: "云南省昭通地区镇雄县",
		532129: "云南省昭通地区彝良县",
		532130: "云南省昭通地区威信县",
		532131: "云南省昭通地区水富县",
		532300: "云南省楚雄彝族自治州",
		532301: "云南省楚雄彝族自治州楚雄市",
		532322: "云南省楚雄彝族自治州双柏县",
		532323: "云南省楚雄彝族自治州牟定县",
		532324: "云南省楚雄彝族自治州南华县",
		532325: "云南省楚雄彝族自治州姚安县",
		532326: "云南省楚雄彝族自治州大姚县",
		532327: "云南省楚雄彝族自治州永仁县",
		532328: "云南省楚雄彝族自治州元谋县",
		532329: "云南省楚雄彝族自治州武定县",
		532331: "云南省楚雄彝族自治州禄丰县",
		532500: "云南省红河哈尼族彝族自治州",
		532501: "云南省红河哈尼族彝族自治州个旧市",
		532502: "云南省红河哈尼族彝族自治州开远市",
		532522: "云南省红河哈尼族彝族自治州蒙自县",
		532523: "云南省红河哈尼族彝族自治州屏边苗族自治县",
		532524: "云南省红河哈尼族彝族自治州建水县",
		532525: "云南省红河哈尼族彝族自治州石屏县",
		532526: "云南省红河哈尼族彝族自治州弥勒县",
		532527: "云南省红河哈尼族彝族自治州泸西县",
		532528: "云南省红河哈尼族彝族自治州元阳县",
		532529: "云南省红河哈尼族彝族自治州红河县",
		532530: "云南省红河哈尼族彝族自治州金平苗族瑶族傣族自治县",
		532531: "云南省红河哈尼族彝族自治州绿春县",
		532532: "云南省红河哈尼族彝族自治州河口瑶族自治县",
		532600: "云南省文山壮族苗族自治州",
		532621: "云南省文山壮族苗族自治州文山县",
		532622: "云南省文山壮族苗族自治州砚山县",
		532623: "云南省文山壮族苗族自治州西畴县",
		532624: "云南省文山壮族苗族自治州麻栗坡县",
		532625: "云南省文山壮族苗族自治州马关县",
		532626: "云南省文山壮族苗族自治州丘北县",
		532627: "云南省文山壮族苗族自治州广南县",
		532628: "云南省文山壮族苗族自治州富宁县",
		532700: "云南省思茅地区",
		532701: "云南省思茅地区思茅市",
		532722: "云南省思茅地区普洱哈尼族彝族自治县",
		532723: "云南省思茅地区墨江哈尼族自治县",
		532724: "云南省思茅地区景东彝族自治县",
		532725: "云南省思茅地区景谷傣族彝族自治县",
		532726: "云南省思茅地区镇沅彝族哈尼族拉祜族自治县",
		532727: "云南省思茅地区江城哈尼族彝族自治县",
		532728: "云南省思茅地区孟连傣族拉祜族佤族自治县",
		532729: "云南省思茅地区澜沧拉祜族自治县",
		532730: "云南省思茅地区西盟佤族自治县",
		532800: "云南省西双版纳傣族自治州",
		532801: "云南省西双版纳傣族自治州景洪市",
		532822: "云南省西双版纳傣族自治州勐海县",
		532823: "云南省西双版纳傣族自治州勐腊县",
		532900: "云南省大理白族自治州",
		532901: "云南省大理白族自治州大理市",
		532922: "云南省大理白族自治州漾濞彝族自治县",
		532923: "云南省大理白族自治州祥云县",
		532924: "云南省大理白族自治州宾川县",
		532925: "云南省大理白族自治州弥渡县",
		532926: "云南省大理白族自治州南涧彝族自治县",
		532927: "云南省大理白族自治州巍山彝族回族自治县",
		532928: "云南省大理白族自治州永平县",
		532929: "云南省大理白族自治州云龙县",
		532930: "云南省大理白族自治州洱源县",
		532931: "云南省大理白族自治州剑川县",
		532932: "云南省大理白族自治州鹤庆县",
		533e3: "云南省保山地区",
		533001: "云南省保山地区保山市",
		533022: "云南省保山地区施甸县",
		533023: "云南省保山地区腾冲县",
		533024: "云南省保山地区龙陵县",
		533025: "云南省保山地区昌宁县",
		533100: "云南省德宏傣族景颇族自治州",
		533101: "云南省德宏傣族景颇族自治州畹町市",
		533102: "云南省德宏傣族景颇族自治州瑞丽市",
		533103: "云南省德宏傣族景颇族自治州潞西市",
		533122: "云南省德宏傣族景颇族自治州梁河县",
		533123: "云南省德宏傣族景颇族自治州盈江县",
		533124: "云南省德宏傣族景颇族自治州陇川县",
		533200: "云南省丽江地区",
		533221: "云南省丽江地区丽江纳西族自治县",
		533222: "云南省丽江地区永胜县",
		533223: "云南省丽江地区华坪县",
		533224: "云南省丽江地区宁蒗彝族自治县",
		533300: "云南省怒江傈僳族自治州",
		533321: "云南省怒江傈僳族自治州泸水县",
		533323: "云南省怒江傈僳族自治州福贡县",
		533324: "云南省怒江傈僳族自治州贡山独龙族怒族自治县",
		533325: "云南省怒江傈僳族自治州兰坪白族普米族自治县",
		533400: "云南省迪庆藏族自治州",
		533421: "云南省迪庆藏族自治州中甸县",
		533422: "云南省迪庆藏族自治州德钦县",
		533423: "云南省迪庆藏族自治州维西傈僳族自治县",
		533500: "云南省临沧地区",
		533521: "云南省临沧地区临沧县",
		533522: "云南省临沧地区凤庆县",
		533523: "云南省临沧地区云县",
		533524: "云南省临沧地区永德县",
		533525: "云南省临沧地区镇康县",
		533526: "云南省临沧地区双江拉祜族佤族布朗族傣族自治县",
		533527: "云南省临沧地区耿马傣族佤族自治县",
		533528: "云南省临沧地区沧源佤族自治县",
		54e4: "西藏自治区",
		540100: "西藏自治区拉萨市",
		540101: "西藏自治区拉萨市市辖区",
		540102: "西藏自治区拉萨市城关区",
		540121: "西藏自治区拉萨市林周县",
		540122: "西藏自治区拉萨市当雄县",
		540123: "西藏自治区拉萨市尼木县",
		540124: "西藏自治区拉萨市曲水县",
		540125: "西藏自治区拉萨市堆龙德庆县",
		540126: "西藏自治区拉萨市达孜县",
		540127: "西藏自治区拉萨市墨竹工卡县",
		542100: "西藏自治区昌都地区",
		542121: "西藏自治区昌都地区昌都县",
		542122: "西藏自治区昌都地区江达县",
		542123: "西藏自治区昌都地区贡觉县",
		542124: "西藏自治区昌都地区类乌齐县",
		542125: "西藏自治区昌都地区丁青县",
		542126: "西藏自治区昌都地区察雅县",
		542127: "西藏自治区昌都地区八宿县",
		542128: "西藏自治区昌都地区左贡县",
		542129: "西藏自治区昌都地区芒康县",
		542132: "西藏自治区昌都地区洛隆县",
		542133: "西藏自治区昌都地区边坝县",
		542134: "西藏自治区昌都地区盐井县",
		542135: "西藏自治区昌都地区碧土县",
		542136: "西藏自治区昌都地区妥坝县",
		542137: "西藏自治区昌都地区生达县",
		542200: "西藏自治区山南地区",
		542221: "西藏自治区山南地区乃东县",
		542222: "西藏自治区山南地区扎囊县",
		542223: "西藏自治区山南地区贡嘎县",
		542224: "西藏自治区山南地区桑日县",
		542225: "西藏自治区山南地区琼结县",
		542226: "西藏自治区山南地区曲松县",
		542227: "西藏自治区山南地区措美县",
		542228: "西藏自治区山南地区洛扎县",
		542229: "西藏自治区山南地区加查县",
		542231: "西藏自治区山南地区隆子县",
		542232: "西藏自治区山南地区错那县",
		542233: "西藏自治区山南地区浪卡子县",
		542300: "西藏自治区日喀则地区",
		542301: "西藏自治区日喀则地区日喀则市",
		542322: "西藏自治区日喀则地区南木林县",
		542323: "西藏自治区日喀则地区江孜县",
		542324: "西藏自治区日喀则地区定日县",
		542325: "西藏自治区日喀则地区萨迦县",
		542326: "西藏自治区日喀则地区拉孜县",
		542327: "西藏自治区日喀则地区昂仁县",
		542328: "西藏自治区日喀则地区谢通门县",
		542329: "西藏自治区日喀则地区白朗县",
		542330: "西藏自治区日喀则地区仁布县",
		542331: "西藏自治区日喀则地区康马县",
		542332: "西藏自治区日喀则地区定结县",
		542333: "西藏自治区日喀则地区仲巴县",
		542334: "西藏自治区日喀则地区亚东县",
		542335: "西藏自治区日喀则地区吉隆县",
		542336: "西藏自治区日喀则地区聂拉木县",
		542337: "西藏自治区日喀则地区萨嘎县",
		542338: "西藏自治区日喀则地区岗巴县",
		542400: "西藏自治区那曲地区",
		542421: "西藏自治区那曲地区那曲县",
		542422: "西藏自治区那曲地区嘉黎县",
		542423: "西藏自治区那曲地区比如县",
		542424: "西藏自治区那曲地区聂荣县",
		542425: "西藏自治区那曲地区安多县",
		542426: "西藏自治区那曲地区申扎县",
		542427: "西藏自治区那曲地区索县",
		542428: "西藏自治区那曲地区班戈县",
		542429: "西藏自治区那曲地区巴青县",
		542430: "西藏自治区那曲地区尼玛县",
		542500: "西藏自治区阿里地区",
		542521: "西藏自治区阿里地区普兰县",
		542522: "西藏自治区阿里地区札达县",
		542523: "西藏自治区阿里地区噶尔县",
		542524: "西藏自治区阿里地区日土县",
		542525: "西藏自治区阿里地区革吉县",
		542526: "西藏自治区阿里地区改则县",
		542527: "西藏自治区阿里地区措勤县",
		542528: "西藏自治区阿里地区隆格尔县",
		542600: "西藏自治区林芝地区",
		542621: "西藏自治区林芝地区林芝县",
		542622: "西藏自治区林芝地区工布江达县",
		542623: "西藏自治区林芝地区米林县",
		542624: "西藏自治区林芝地区墨脱县",
		542625: "西藏自治区林芝地区波密县",
		542626: "西藏自治区林芝地区察隅县",
		542627: "西藏自治区林芝地区朗县",
		61e4: "陕西省",
		610100: "陕西省西安市",
		610101: "陕西省西安市市辖区",
		610102: "陕西省西安市新城区",
		610103: "陕西省西安市碑林区",
		610104: "陕西省西安市莲湖区",
		610111: "陕西省西安市灞桥区",
		610112: "陕西省西安市未央区",
		610113: "陕西省西安市雁塔区",
		610114: "陕西省西安市阎良区",
		610115: "陕西省西安市临潼区",
		610121: "陕西省西安市长安县",
		610122: "陕西省西安市蓝田县",
		610124: "陕西省西安市周至县",
		610125: "陕西省西安市户县",
		610126: "陕西省西安市高陵县",
		610200: "陕西省铜川市",
		610201: "陕西省铜川市市辖区",
		610202: "陕西省铜川市城区",
		610203: "陕西省铜川市郊区",
		610221: "陕西省铜川市耀县",
		610222: "陕西省铜川市宜君县",
		610300: "陕西省宝鸡市",
		610301: "陕西省宝鸡市市辖区",
		610302: "陕西省宝鸡市渭滨区",
		610303: "陕西省宝鸡市金台区",
		610321: "陕西省宝鸡市宝鸡县",
		610322: "陕西省宝鸡市凤翔县",
		610323: "陕西省宝鸡市岐山县",
		610324: "陕西省宝鸡市扶风县",
		610326: "陕西省宝鸡市眉县",
		610327: "陕西省宝鸡市陇县",
		610328: "陕西省宝鸡市千阳县",
		610329: "陕西省宝鸡市麟游县",
		610330: "陕西省宝鸡市凤县",
		610331: "陕西省宝鸡市太白县",
		610400: "陕西省咸阳市",
		610401: "陕西省咸阳市市辖区",
		610402: "陕西省咸阳市秦都区",
		610403: "陕西省咸阳市杨陵区",
		610404: "陕西省咸阳市渭城区",
		610422: "陕西省咸阳市三原县",
		610423: "陕西省咸阳市泾阳县",
		610424: "陕西省咸阳市乾县",
		610425: "陕西省咸阳市礼泉县",
		610426: "陕西省咸阳市永寿县",
		610427: "陕西省咸阳市彬县",
		610428: "陕西省咸阳市长武县",
		610429: "陕西省咸阳市旬邑县",
		610430: "陕西省咸阳市淳化县",
		610431: "陕西省咸阳市武功县",
		610481: "陕西省咸阳市兴平市",
		610500: "陕西省渭南市",
		610501: "陕西省渭南市市辖区",
		610502: "陕西省渭南市临渭区",
		610521: "陕西省渭南市华县",
		610522: "陕西省渭南市潼关县",
		610523: "陕西省渭南市大荔县",
		610524: "陕西省渭南市合阳县",
		610525: "陕西省渭南市澄城县",
		610526: "陕西省渭南市蒲城县",
		610527: "陕西省渭南市白水县",
		610528: "陕西省渭南市富平县",
		610581: "陕西省渭南市韩城市",
		610582: "陕西省渭南市华阴市",
		610600: "陕西省延安市",
		610601: "陕西省延安市市辖区",
		610602: "陕西省延安市宝塔区",
		610621: "陕西省延安市延长县",
		610622: "陕西省延安市延川县",
		610623: "陕西省延安市子长县",
		610624: "陕西省延安市安塞县",
		610625: "陕西省延安市志丹县",
		610626: "陕西省延安市吴旗县",
		610627: "陕西省延安市甘泉县",
		610628: "陕西省延安市富县",
		610629: "陕西省延安市洛川县",
		610630: "陕西省延安市宜川县",
		610631: "陕西省延安市黄龙县",
		610632: "陕西省延安市黄陵县",
		610700: "陕西省汉中市",
		610701: "陕西省汉中市市辖区",
		610702: "陕西省汉中市汉台区",
		610721: "陕西省汉中市南郑县",
		610722: "陕西省汉中市城固县",
		610723: "陕西省汉中市洋县",
		610724: "陕西省汉中市西乡县",
		610725: "陕西省汉中市勉县",
		610726: "陕西省汉中市宁强县",
		610727: "陕西省汉中市略阳县",
		610728: "陕西省汉中市镇巴县",
		610729: "陕西省汉中市留坝县",
		610730: "陕西省汉中市佛坪县",
		612400: "陕西省安康地区",
		612401: "陕西省安康地区安康市",
		612422: "陕西省安康地区汉阴县",
		612423: "陕西省安康地区石泉县",
		612424: "陕西省安康地区宁陕县",
		612425: "陕西省安康地区紫阳县",
		612426: "陕西省安康地区岚皋县",
		612427: "陕西省安康地区平利县",
		612428: "陕西省安康地区镇坪县",
		612429: "陕西省安康地区旬阳县",
		612430: "陕西省安康地区白河县",
		612500: "陕西省商洛地区",
		612501: "陕西省商洛地区商州市",
		612522: "陕西省商洛地区洛南县",
		612523: "陕西省商洛地区丹凤县",
		612524: "陕西省商洛地区商南县",
		612525: "陕西省商洛地区山阳县",
		612526: "陕西省商洛地区镇安县",
		612527: "陕西省商洛地区柞水县",
		612700: "陕西省榆林地区",
		612701: "陕西省榆林地区榆林市",
		612722: "陕西省榆林地区神木县",
		612723: "陕西省榆林地区府谷县",
		612724: "陕西省榆林地区横山县",
		612725: "陕西省榆林地区靖边县",
		612726: "陕西省榆林地区定边县",
		612727: "陕西省榆林地区绥德县",
		612728: "陕西省榆林地区米脂县",
		612729: "陕西省榆林地区佳县",
		612730: "陕西省榆林地区吴堡县",
		612731: "陕西省榆林地区清涧县",
		612732: "陕西省榆林地区子洲县",
		62e4: "甘肃省",
		620100: "甘肃省兰州市",
		620101: "甘肃省兰州市市辖区",
		620102: "甘肃省兰州市城关区",
		620103: "甘肃省兰州市七里河区",
		620104: "甘肃省兰州市西固区",
		620105: "甘肃省兰州市安宁区",
		620111: "甘肃省兰州市红古区",
		620121: "甘肃省兰州市永登县",
		620122: "甘肃省兰州市皋兰县",
		620123: "甘肃省兰州市榆中县",
		620200: "甘肃省嘉峪关市",
		620201: "甘肃省嘉峪关市市辖区",
		620300: "甘肃省嘉峪关市金昌市",
		620301: "甘肃省嘉峪关市市辖区",
		620302: "甘肃省嘉峪关市金川区",
		620321: "甘肃省嘉峪关市永昌县",
		620400: "甘肃省白银市",
		620401: "甘肃省白银市市辖区",
		620402: "甘肃省白银市白银区",
		620403: "甘肃省白银市平川区",
		620421: "甘肃省白银市靖远县",
		620422: "甘肃省白银市会宁县",
		620423: "甘肃省白银市景泰县",
		620500: "甘肃省天水市",
		620501: "甘肃省天水市市辖区",
		620502: "甘肃省天水市秦城区",
		620503: "甘肃省天水市北道区",
		620521: "甘肃省天水市清水县",
		620522: "甘肃省天水市秦安县",
		620523: "甘肃省天水市甘谷县",
		620524: "甘肃省天水市武山县",
		620525: "甘肃省天水市张家川回族自治县",
		622100: "甘肃省酒泉地区",
		622101: "甘肃省酒泉地区玉门市",
		622102: "甘肃省酒泉地区酒泉市",
		622103: "甘肃省酒泉地区敦煌市",
		622123: "甘肃省酒泉地区金塔县",
		622124: "甘肃省酒泉地区肃北蒙古族自治县",
		622125: "甘肃省酒泉地区阿克塞哈萨克族自治县",
		622126: "甘肃省酒泉地区安西县",
		622200: "甘肃省张掖地区",
		622201: "甘肃省张掖地区张掖市",
		622222: "甘肃省张掖地区肃南裕固族自治县",
		622223: "甘肃省张掖地区民乐县",
		622224: "甘肃省张掖地区临泽县",
		622225: "甘肃省张掖地区高台县",
		622226: "甘肃省张掖地区山丹县",
		622300: "甘肃省武威地区",
		622301: "甘肃省武威地区武威市",
		622322: "甘肃省武威地区民勤县",
		622323: "甘肃省武威地区古浪县",
		622326: "甘肃省武威地区天祝藏族自治县",
		622400: "甘肃省定西地区",
		622421: "甘肃省定西地区定西县",
		622424: "甘肃省定西地区通渭县",
		622425: "甘肃省定西地区陇西县",
		622426: "甘肃省定西地区渭源县",
		622427: "甘肃省定西地区临洮县",
		622428: "甘肃省定西地区漳县",
		622429: "甘肃省定西地区岷县",
		622600: "甘肃省陇南地区",
		622621: "甘肃省陇南地区武都县",
		622623: "甘肃省陇南地区宕昌县",
		622624: "甘肃省陇南地区成县",
		622625: "甘肃省陇南地区康县",
		622626: "甘肃省陇南地区文县",
		622627: "甘肃省陇南地区西和县",
		622628: "甘肃省陇南地区礼县",
		622629: "甘肃省陇南地区两当县",
		622630: "甘肃省陇南地区徽县",
		622700: "甘肃省平凉地区",
		622701: "甘肃省平凉地区平凉市",
		622722: "甘肃省平凉地区泾川县",
		622723: "甘肃省平凉地区灵台县",
		622724: "甘肃省平凉地区崇信县",
		622725: "甘肃省平凉地区华亭县",
		622726: "甘肃省平凉地区庄浪县",
		622727: "甘肃省平凉地区静宁县",
		622800: "甘肃省庆阳地区",
		622801: "甘肃省庆阳地区西峰市",
		622821: "甘肃省庆阳地区庆阳县",
		622822: "甘肃省庆阳地区环县",
		622823: "甘肃省庆阳地区华池县",
		622824: "甘肃省庆阳地区合水县",
		622825: "甘肃省庆阳地区正宁县",
		622826: "甘肃省庆阳地区宁县",
		622827: "甘肃省庆阳地区镇原县",
		622900: "甘肃省临夏回族自治州",
		622901: "甘肃省临夏回族自治州临夏市",
		622921: "甘肃省临夏回族自治州临夏县",
		622922: "甘肃省临夏回族自治州康乐县",
		622923: "甘肃省临夏回族自治州永靖县",
		622924: "甘肃省临夏回族自治州广河县",
		622925: "甘肃省临夏回族自治州和政县",
		622926: "甘肃省临夏回族自治州东乡族自治县",
		622927: "甘肃省临夏回族自治州积石山保安族东乡族撒拉族自治县",
		623e3: "甘肃省甘南藏族自治州",
		623001: "甘肃省甘南藏族自治州合作市",
		623021: "甘肃省甘南藏族自治州临潭县",
		623022: "甘肃省甘南藏族自治州卓尼县",
		623023: "甘肃省甘南藏族自治州舟曲县",
		623024: "甘肃省甘南藏族自治州迭部县",
		623025: "甘肃省甘南藏族自治州玛曲县",
		623026: "甘肃省甘南藏族自治州碌曲县",
		623027: "甘肃省甘南藏族自治州夏河县",
		63e4: "青海省",
		630100: "青海省西宁市",
		630101: "青海省西宁市市辖区",
		630102: "青海省西宁市城东区",
		630103: "青海省西宁市城中区",
		630104: "青海省西宁市城西区",
		630105: "青海省西宁市城北区",
		630121: "青海省西宁市大通回族土族自治县",
		632100: "青海省海东地区",
		632121: "青海省海东地区平安县",
		632122: "青海省海东地区民和回族土族自治县",
		632123: "青海省海东地区乐都县",
		632124: "青海省海东地区湟中县",
		632125: "青海省海东地区湟源县",
		632126: "青海省海东地区互助土族自治县",
		632127: "青海省海东地区化隆回族自治县",
		632128: "青海省海东地区循化撒拉族自治县",
		632200: "青海省海北藏族自治州",
		632221: "青海省海北藏族自治州门源回族自治县",
		632222: "青海省海北藏族自治州祁连县",
		632223: "青海省海北藏族自治州海晏县",
		632224: "青海省海北藏族自治州刚察县",
		632300: "青海省黄南藏族自治州",
		632321: "青海省黄南藏族自治州同仁县",
		632322: "青海省黄南藏族自治州尖扎县",
		632323: "青海省黄南藏族自治州泽库县",
		632324: "青海省黄南藏族自治州河南蒙古族自治县",
		632500: "青海省海南藏族自治州",
		632521: "青海省海南藏族自治州共和县",
		632522: "青海省海南藏族自治州同德县",
		632523: "青海省海南藏族自治州贵德县",
		632524: "青海省海南藏族自治州兴海县",
		632525: "青海省海南藏族自治州贵南县",
		632600: "青海省果洛藏族自治州",
		632621: "青海省果洛藏族自治州玛沁县",
		632622: "青海省果洛藏族自治州班玛县",
		632623: "青海省果洛藏族自治州甘德县",
		632624: "青海省果洛藏族自治州达日县",
		632625: "青海省果洛藏族自治州久治县",
		632626: "青海省果洛藏族自治州玛多县",
		632700: "青海省玉树藏族自治州",
		632721: "青海省玉树藏族自治州玉树县",
		632722: "青海省玉树藏族自治州杂多县",
		632723: "青海省玉树藏族自治州称多县",
		632724: "青海省玉树藏族自治州治多县",
		632725: "青海省玉树藏族自治州囊谦县",
		632726: "青海省玉树藏族自治州曲麻莱县",
		632800: "青海省海西蒙古族藏族自治州",
		632801: "青海省海西蒙古族藏族自治州格尔木市",
		632802: "青海省海西蒙古族藏族自治州德令哈市",
		632821: "青海省海西蒙古族藏族自治州乌兰县",
		632822: "青海省海西蒙古族藏族自治州都兰县",
		632823: "青海省海西蒙古族藏族自治州天峻县",
		64e4: "宁夏回族自治区",
		640100: "宁夏回族自治区银川市",
		640101: "宁夏回族自治区银川市市辖区",
		640102: "宁夏回族自治区银川市城区",
		640103: "宁夏回族自治区银川市新城区",
		640111: "宁夏回族自治区银川市郊区",
		640121: "宁夏回族自治区银川市永宁县",
		640122: "宁夏回族自治区银川市贺兰县",
		640200: "宁夏回族自治区石嘴山市",
		640201: "宁夏回族自治区石嘴山市市辖区",
		640202: "宁夏回族自治区石嘴山市大武口区",
		640203: "宁夏回族自治区石嘴山市石嘴山区",
		640204: "宁夏回族自治区石嘴山市石炭井区",
		640221: "宁夏回族自治区石嘴山市平罗县",
		640222: "宁夏回族自治区石嘴山市陶乐县",
		640223: "宁夏回族自治区石嘴山市惠农县",
		640300: "宁夏回族自治区吴忠市",
		640301: "宁夏回族自治区吴忠市市辖区",
		640302: "宁夏回族自治区吴忠市利通区",
		640321: "宁夏回族自治区吴忠市中卫县",
		640322: "宁夏回族自治区吴忠市中宁县",
		640323: "宁夏回族自治区吴忠市盐池县",
		640324: "宁夏回族自治区吴忠市同心县",
		640381: "宁夏回族自治区吴忠市青铜峡市",
		640382: "宁夏回族自治区吴忠市灵武市",
		642200: "宁夏回族自治区固原地区",
		642221: "宁夏回族自治区固原地区固原县",
		642222: "宁夏回族自治区固原地区海原县",
		642223: "宁夏回族自治区固原地区西吉县",
		642224: "宁夏回族自治区固原地区隆德县",
		642225: "宁夏回族自治区固原地区泾源县",
		642226: "宁夏回族自治区固原地区彭阳县",
		65e4: "新疆维吾尔自治区",
		650100: "新疆维吾尔族自治区乌鲁木齐市",
		650101: "新疆维吾尔族自治区乌鲁木齐市市辖区",
		650102: "新疆维吾尔族自治区乌鲁木齐市天山区",
		650103: "新疆维吾尔族自治区乌鲁木齐市沙依巴克区",
		650104: "新疆维吾尔族自治区乌鲁木齐市新市区",
		650105: "新疆维吾尔族自治区乌鲁木齐市水磨沟区",
		650106: "新疆维吾尔族自治区乌鲁木齐市头屯河区",
		650107: "新疆维吾尔族自治区乌鲁木齐市南山矿区",
		650108: "新疆维吾尔族自治区乌鲁木齐市东山区",
		650121: "新疆维吾尔族自治区乌鲁木齐市乌鲁木齐县",
		650200: "新疆维吾尔族自治区克拉玛依市",
		650201: "新疆维吾尔族自治区克拉玛依市市辖区",
		650202: "新疆维吾尔族自治区克拉玛依市独山子区",
		650203: "新疆维吾尔族自治区克拉玛依市克拉玛依区",
		650204: "新疆维吾尔族自治区克拉玛依市白碱滩区",
		650205: "新疆维吾尔族自治区克拉玛依市乌尔禾区",
		652100: "新疆维吾尔族自治区吐鲁番地区",
		652101: "新疆维吾尔族自治区吐鲁番地区吐鲁番市",
		652122: "新疆维吾尔族自治区吐鲁番地区鄯善县",
		652123: "新疆维吾尔族自治区吐鲁番地区托克逊县",
		652200: "新疆维吾尔族自治区哈密地区",
		652201: "新疆维吾尔族自治区哈密地区哈密市",
		652222: "新疆维吾尔族自治区哈密地区巴里坤哈萨克自治县",
		652223: "新疆维吾尔族自治区哈密地区伊吾县",
		652300: "新疆维吾尔族自治区昌吉回族自治州",
		652301: "新疆维吾尔族自治区昌吉回族自治州昌吉市",
		652302: "新疆维吾尔族自治区昌吉回族自治州阜康市",
		652303: "新疆维吾尔族自治区昌吉回族自治州米泉市",
		652323: "新疆维吾尔族自治区昌吉回族自治州呼图壁县",
		652324: "新疆维吾尔族自治区昌吉回族自治州玛纳斯县",
		652325: "新疆维吾尔族自治区昌吉回族自治州奇台县",
		652327: "新疆维吾尔族自治区昌吉回族自治州吉木萨尔县",
		652328: "新疆维吾尔族自治区昌吉回族自治州木垒哈萨克自治县",
		652700: "新疆维吾尔族自治区博尔塔拉蒙古自治州",
		652701: "新疆维吾尔族自治区博尔塔拉蒙古自治州博乐市",
		652722: "新疆维吾尔族自治区博尔塔拉蒙古自治州精河县",
		652723: "新疆维吾尔族自治区博尔塔拉蒙古自治州温泉县",
		652800: "新疆维吾尔族自治区巴音郭楞蒙古自治州",
		652801: "新疆维吾尔族自治区巴音郭楞蒙古自治州库尔勒市",
		652822: "新疆维吾尔族自治区巴音郭楞蒙古自治州轮台县",
		652823: "新疆维吾尔族自治区巴音郭楞蒙古自治州尉犁县",
		652824: "新疆维吾尔族自治区巴音郭楞蒙古自治州若羌县",
		652825: "新疆维吾尔族自治区巴音郭楞蒙古自治州且末县",
		652826: "新疆维吾尔族自治区巴音郭楞蒙古自治州焉耆回族自治县",
		652827: "新疆维吾尔族自治区巴音郭楞蒙古自治州和静县",
		652828: "新疆维吾尔族自治区巴音郭楞蒙古自治州和硕县",
		652829: "新疆维吾尔族自治区巴音郭楞蒙古自治州博湖县",
		652900: "新疆维吾尔族自治区阿克苏地区",
		652901: "新疆维吾尔族自治区阿克苏地区阿克苏市",
		652922: "新疆维吾尔族自治区阿克苏地区温宿县",
		652923: "新疆维吾尔族自治区阿克苏地区库车县",
		652924: "新疆维吾尔族自治区阿克苏地区沙雅县",
		652925: "新疆维吾尔族自治区阿克苏地区新和县",
		652926: "新疆维吾尔族自治区阿克苏地区拜城县",
		652927: "新疆维吾尔族自治区阿克苏地区乌什县",
		652928: "新疆维吾尔族自治区阿克苏地区阿瓦提县",
		652929: "新疆维吾尔族自治区阿克苏地区柯坪县",
		653e3: "新疆维吾尔族自治区克孜勒苏柯尔克孜自治州",
		653001: "新疆维吾尔族自治区克孜勒苏柯尔克孜自治州阿图什市",
		653022: "新疆维吾尔族自治区克孜勒苏柯尔克孜自治州阿克陶县",
		653023: "新疆维吾尔族自治区克孜勒苏柯尔克孜自治州阿合奇县",
		653024: "新疆维吾尔族自治区克孜勒苏柯尔克孜自治州乌恰县",
		653100: "新疆维吾尔族自治区喀什地区",
		653101: "新疆维吾尔族自治区喀什地区喀什市",
		653121: "新疆维吾尔族自治区喀什地区疏附县",
		653122: "新疆维吾尔族自治区喀什地区疏勒县",
		653123: "新疆维吾尔族自治区喀什地区英吉沙县",
		653124: "新疆维吾尔族自治区喀什地区泽普县",
		653125: "新疆维吾尔族自治区喀什地区莎车县",
		653126: "新疆维吾尔族自治区喀什地区叶城县",
		653127: "新疆维吾尔族自治区喀什地区麦盖提县",
		653128: "新疆维吾尔族自治区喀什地区岳普湖县",
		653129: "新疆维吾尔族自治区喀什地区伽师县",
		653130: "新疆维吾尔族自治区喀什地区巴楚县",
		653131: "新疆维吾尔族自治区喀什地区塔什库尔干塔吉克自治县",
		653200: "新疆维吾尔族自治区和田地区",
		653201: "新疆维吾尔族自治区和田地区和田市",
		653221: "新疆维吾尔族自治区和田地区和田县",
		653222: "新疆维吾尔族自治区和田地区墨玉县",
		653223: "新疆维吾尔族自治区和田地区皮山县",
		653224: "新疆维吾尔族自治区和田地区洛浦县",
		653225: "新疆维吾尔族自治区和田地区策勒县",
		653226: "新疆维吾尔族自治区和田地区于田县",
		653227: "新疆维吾尔族自治区和田地区民丰县",
		654e3: "新疆维吾尔族自治区伊犁哈萨克自治州",
		654001: "新疆维吾尔族自治区伊犁哈萨克自治州奎屯市",
		654100: "新疆维吾尔族自治区伊犁哈萨克自治州伊犁地区",
		654101: "新疆维吾尔族自治区伊犁哈萨克自治州伊宁市",
		654121: "新疆维吾尔族自治区伊犁哈萨克自治州伊宁县",
		654122: "新疆自治区伊犁哈萨克自治州察布查尔锡伯自治县",
		654123: "新疆维吾尔族自治区伊犁哈萨克自治州霍城县",
		654124: "新疆维吾尔族自治区伊犁哈萨克自治州巩留县",
		654125: "新疆维吾尔族自治区伊犁哈萨克自治州新源县",
		654126: "新疆维吾尔族自治区伊犁哈萨克自治州昭苏县",
		654127: "新疆维吾尔族自治区伊犁哈萨克自治州特克斯县",
		654128: "新疆维吾尔族自治区伊犁哈萨克自治州尼勒克县",
		654200: "新疆维吾尔族自治区塔城地区",
		654201: "新疆维吾尔族自治区塔城地区塔城市",
		654202: "新疆维吾尔族自治区塔城地区乌苏市",
		654221: "新疆维吾尔族自治区塔城地区额敏县",
		654223: "新疆维吾尔族自治区塔城地区沙湾县",
		654224: "新疆维吾尔族自治区塔城地区托里县",
		654225: "新疆维吾尔族自治区塔城地区裕民县",
		654226: "新疆维吾尔族自治区塔城地区和布克赛尔蒙古自治县",
		654300: "新疆维吾尔族自治区阿勒泰地区",
		654301: "新疆维吾尔族自治区阿勒泰地区阿勒泰市",
		654321: "新疆维吾尔族自治区阿勒泰地区布尔津县",
		654322: "新疆维吾尔族自治区阿勒泰地区富蕴县",
		654323: "新疆维吾尔族自治区阿勒泰地区福海县",
		654324: "新疆维吾尔族自治区阿勒泰地区哈巴河县",
		654325: "新疆维吾尔族自治区阿勒泰地区青河县",
		654326: "新疆维吾尔族自治区阿勒泰地区吉木乃县",
		659e3: "新疆维吾尔族自治区直辖县级行政单位",
		659001: "新疆维吾尔族自治区石河子市"
	};
	return t
});
! function (t, e) {
	"function" == typeof define && define.amd ? define(e) : "object" == typeof exports ? module.exports = e() : t.PhotoSwipe = e()
}(this, function () {
	"use strict";
	var t = function (d, W, t, e) {
		var g = {
			features: null,
			bind: function (t, e, i, n) {
				var s = (n ? "remove" : "add") + "EventListener";
				e = e.split(" ");
				for (var o = 0; o < e.length; o++) e[o] && t[s](e[o], i, !1)
			},
			isArray: function (t) {
				return t instanceof Array
			},
			createEl: function (t, e) {
				var i = document.createElement(e || "div");
				return t && (i.className = t), i
			},
			getScrollY: function () {
				var t = window.pageYOffset;
				return void 0 !== t ? t : document.documentElement.scrollTop
			},
			unbind: function (t, e, i) {
				g.bind(t, e, i, !0)
			},
			removeClass: function (t, e) {
				var i = new RegExp("(\\s|^)" + e + "(\\s|$)");
				t.className = t.className.replace(i, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
			},
			addClass: function (t, e) {
				g.hasClass(t, e) || (t.className += (t.className ? " " : "") + e)
			},
			hasClass: function (t, e) {
				return t.className && new RegExp("(^|\\s)" + e + "(\\s|$)").test(t.className)
			},
			getChildByClass: function (t, e) {
				for (var i = t.firstChild; i;) {
					if (g.hasClass(i, e)) return i;
					i = i.nextSibling
				}
			},
			arraySearch: function (t, e, i) {
				for (var n = t.length; n--;)
					if (t[n][i] === e) return n;
				return -1
			},
			extend: function (t, e, i) {
				for (var n in e)
					if (e.hasOwnProperty(n)) {
						if (i && t.hasOwnProperty(n)) continue;
						t[n] = e[n]
					}
			},
			easing: {
				sine: {
					out: function (t) {
						return Math.sin(t * (Math.PI / 2))
					},
					inOut: function (t) {
						return -(Math.cos(Math.PI * t) - 1) / 2
					}
				},
				cubic: {
					out: function (t) {
						return --t * t * t + 1
					}
				}
			},
			detectFeatures: function () {
				if (g.features) return g.features;
				var t = g.createEl(),
					e = t.style,
					i = "",
					n = {};
				if (n.oldIE = document.all && !document.addEventListener, n.touch = "ontouchstart" in window, window.requestAnimationFrame && (n.raf = window.requestAnimationFrame, n.caf = window.cancelAnimationFrame), n.pointerEvent = navigator.pointerEnabled || navigator.msPointerEnabled, !n.pointerEvent) {
					var s = navigator.userAgent;
					if (/iP(hone|od)/.test(navigator.platform)) {
						var o = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
						o && o.length > 0 && (o = parseInt(o[1], 10), o >= 1 && o < 8 && (n.isOldIOSPhone = !0))
					}
					var r = s.match(/Android\s([0-9\.]*)/),
						a = r ? r[1] : 0;
					a = parseFloat(a), a >= 1 && (a < 4.4 && (n.isOldAndroid = !0), n.androidVersion = a), n.isMobileOpera = /opera mini|opera mobi/i.test(s)
				}
				for (var l, h, c = ["transform", "perspective", "animationName"], u = ["", "webkit", "Moz", "ms", "O"], d = 0; d < 4; d++) {
					i = u[d];
					for (var f = 0; f < 3; f++) l = c[f], h = i + (i ? l.charAt(0).toUpperCase() + l.slice(1) : l), !n[l] && h in e && (n[l] = h);
					i && !n.raf && (i = i.toLowerCase(), n.raf = window[i + "RequestAnimationFrame"], n.raf && (n.caf = window[i + "CancelAnimationFrame"] || window[i + "CancelRequestAnimationFrame"]))
				}
				if (!n.raf) {
					var p = 0;
					n.raf = function (t) {
						var e = (new Date).getTime(),
							i = Math.max(0, 16 - (e - p)),
							n = window.setTimeout(function () {
								t(e + i)
							}, i);
						return p = e + i, n
					}, n.caf = function (t) {
						clearTimeout(t)
					}
				}
				return n.svg = !!document.createElementNS && !!document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect, g.features = n, n
			}
		};
		g.detectFeatures(), g.features.oldIE && (g.bind = function (t, e, i, n) {
			e = e.split(" ");
			for (var s, o = (n ? "detach" : "attach") + "Event", r = function () {
				i.handleEvent.call(i)
			}, a = 0; a < e.length; a++)
				if (s = e[a])
					if ("object" == typeof i && i.handleEvent) {
						if (n) {
							if (!i["oldIE" + s]) return !1
						} else i["oldIE" + s] = r;
						t[o]("on" + s, i["oldIE" + s])
					} else t[o]("on" + s, i)
		});
		var f = this,
			i = 25,
			B = 3,
			p = {
				allowPanToNext: !0,
				spacing: .12,
				bgOpacity: 1,
				mouseUsed: !1,
				loop: !0,
				pinchToClose: !0,
				closeOnScroll: !0,
				closeOnVerticalDrag: !0,
				verticalDragRange: .75,
				hideAnimationDuration: 333,
				showAnimationDuration: 333,
				showHideOpacity: !1,
				focus: !0,
				escKey: !0,
				arrowKeys: !0,
				mainScrollEndFriction: .35,
				panEndFriction: .35,
				isClickableElement: function (t) {
					return "A" === t.tagName
				},
				getDoubleTapZoom: function (t, e) {
					return t ? 1 : e.initialZoomLevel < .7 ? 1 : 1.33
				},
				maxSpreadZoom: 1.33,
				modal: !0,
				scaleMode: "fit"
			};
		g.extend(p, e);
		var j, Y, n, m, V, r, $, U, s, v, q, G, K, X, Z, a, Q, J, tt, et, it, nt, st, o, ot, rt, at, lt, ht, ct, b, ut, dt, ft, pt, gt, mt, vt, _, bt, _t, yt, xt, wt, y, x, kt, Ct, u, w, k, Dt, Mt, Tt, St, Pt, It, Et = function () {
			return {
				x: 0,
				y: 0
			}
		},
			Ot = Et(),
			At = Et(),
			C = Et(),
			l = {},
			Lt = 0,
			Nt = {},
			c = Et(),
			D = 0,
			Rt = !0,
			Ft = [],
			Ht = {},
			zt = !1,
			Wt = function (t, e) {
				g.extend(f, e.publicMethods), Ft.push(t)
			},
			Bt = function (t) {
				var e = N();
				return t > e - 1 ? t - e : t < 0 ? e + t : t
			},
			jt = {},
			h = function (t, e) {
				return jt[t] || (jt[t] = []), jt[t].push(e)
			},
			M = function (t) {
				var e = jt[t];
				if (e) {
					var i = Array.prototype.slice.call(arguments);
					i.shift();
					for (var n = 0; n < e.length; n++) e[n].apply(f, i)
				}
			},
			T = function () {
				return (new Date).getTime()
			},
			S = function (t) {
				St = t, f.bg.style.opacity = t * p.bgOpacity
			},
			Yt = function (t, e, i, n, s) {
				(!zt || s && s !== f.currItem) && (n /= s ? s.fitRatio : f.currItem.fitRatio), t[nt] = G + e + "px, " + i + "px" + K + " scale(" + n + ")"
			},
			P = function (t) {
				w && (t && (v > f.currItem.fitRatio ? zt || (gi(f.currItem, !1, !0), zt = !0) : zt && (gi(f.currItem), zt = !1)), Yt(w, C.x, C.y, v))
			},
			Vt = function (t) {
				t.container && Yt(t.container.style, t.initialPosition.x, t.initialPosition.y, t.initialZoomLevel, t)
			},
			$t = function (t, e) {
				e[nt] = G + t + "px, 0px" + K
			},
			Ut = function (t, e) {
				if (!p.loop && e) {
					var i = m + (c.x * Lt - t) / c.x,
						n = Math.round(t - Ce.x);
					(i < 0 && n > 0 || i >= N() - 1 && n < 0) && (t = Ce.x + n * p.mainScrollEndFriction)
				}
				Ce.x = t, $t(t, V)
			},
			qt = function (t, e) {
				var i = De[t] - Nt[t];
				return At[t] + Ot[t] + i - i * (e / q)
			},
			I = function (t, e) {
				t.x = e.x, t.y = e.y, e.id && (t.id = e.id)
			},
			Gt = function (t) {
				t.x = Math.round(t.x), t.y = Math.round(t.y)
			},
			Kt = null,
			Xt = function () {
				Kt && (g.unbind(document, "mousemove", Xt), g.addClass(d, "pswp--has_mouse"), p.mouseUsed = !0, M("mouseUsed")), Kt = setTimeout(function () {
					Kt = null
				}, 100)
			},
			Zt = function () {
				g.bind(document, "keydown", f), b.transform && g.bind(f.scrollWrap, "click", f), p.mouseUsed || g.bind(document, "mousemove", Xt), g.bind(window, "resize scroll orientationchange", f), M("bindEvents")
			},
			Qt = function () {
				g.unbind(window, "resize scroll orientationchange", f), g.unbind(window, "scroll", s.scroll), g.unbind(document, "keydown", f), g.unbind(document, "mousemove", Xt), b.transform && g.unbind(f.scrollWrap, "click", f), _ && g.unbind(window, $, f), clearTimeout(ut), M("unbindEvents")
			},
			Jt = function (t, e) {
				var i = ui(f.currItem, l, t);
				return e && (u = i), i
			},
			te = function (t) {
				return t || (t = f.currItem), t.initialZoomLevel
			},
			ee = function (t) {
				return t || (t = f.currItem), t.w > 0 ? p.maxSpreadZoom : 1
			},
			ie = function (t, e, i, n) {
				return n === f.currItem.initialZoomLevel ? (i[t] = f.currItem.initialPosition[t], !0) : (i[t] = qt(t, n), i[t] > e.min[t] ? (i[t] = e.min[t], !0) : i[t] < e.max[t] && (i[t] = e.max[t], !0))
			},
			ne = function () {
				if (nt) {
					var t = b.perspective && !o;
					return G = "translate" + (t ? "3d(" : "("), void (K = b.perspective ? ", 0px)" : ")")
				}
				nt = "left", g.addClass(d, "pswp--ie"), $t = function (t, e) {
					e.left = t + "px"
				}, Vt = function (t) {
					var e = t.fitRatio > 1 ? 1 : t.fitRatio,
						i = t.container.style,
						n = e * t.w,
						s = e * t.h;
					i.width = n + "px", i.height = s + "px", i.left = t.initialPosition.x + "px", i.top = t.initialPosition.y + "px"
				}, P = function () {
					if (w) {
						var t = w,
							e = f.currItem,
							i = e.fitRatio > 1 ? 1 : e.fitRatio,
							n = i * e.w,
							s = i * e.h;
						t.width = n + "px", t.height = s + "px", t.left = C.x + "px", t.top = C.y + "px"
					}
				}
			},
			se = function (t) {
				var e = "";
				p.escKey && 27 === t.keyCode ? e = "close" : p.arrowKeys && (37 === t.keyCode ? e = "prev" : 39 === t.keyCode && (e = "next")), e && (t.ctrlKey || t.altKey || t.shiftKey || t.metaKey || (t.preventDefault ? t.preventDefault() : t.returnValue = !1, f[e]()))
			},
			oe = function (t) {
				t && (yt || _t || k || mt) && (t.preventDefault(), t.stopPropagation())
			},
			re = function () {
				f.setScrollOffset(0, g.getScrollY())
			},
			E = {},
			ae = 0,
			le = function (t) {
				E[t] && (E[t].raf && rt(E[t].raf), ae--, delete E[t])
			},
			he = function (t) {
				E[t] && le(t), E[t] || (ae++, E[t] = {})
			},
			ce = function () {
				for (var t in E) E.hasOwnProperty(t) && le(t)
			},
			ue = function (t, e, i, n, s, o, r) {
				var a, l = T();
				he(t);
				var h = function () {
					if (E[t]) {
						if (a = T() - l, a >= n) return le(t), o(i), void (r && r());
						o((i - e) * s(a / n) + e), E[t].raf = ot(h)
					}
				};
				h()
			},
			de = {
				shout: M,
				listen: h,
				viewportSize: l,
				options: p,
				isMainScrollAnimating: function () {
					return k
				},
				getZoomLevel: function () {
					return v
				},
				getCurrentIndex: function () {
					return m
				},
				isDragging: function () {
					return _
				},
				isZooming: function () {
					return x
				},
				setScrollOffset: function (t, e) {
					Nt.x = t, ct = Nt.y = e, M("updateScrollOffset", Nt)
				},
				applyZoomPan: function (t, e, i, n) {
					C.x = e, C.y = i, v = t, P(n)
				},
				init: function () {
					if (!j && !Y) {
						var t;
						f.framework = g, f.template = d, f.bg = g.getChildByClass(d, "pswp__bg"), at = d.className, j = !0, b = g.detectFeatures(), ot = b.raf, rt = b.caf, nt = b.transform, ht = b.oldIE, f.scrollWrap = g.getChildByClass(d, "pswp__scroll-wrap"), f.container = g.getChildByClass(f.scrollWrap, "pswp__container"), V = f.container.style, f.itemHolders = a = [{
							el: f.container.children[0],
							wrap: 0,
							index: -1
						}, {
							el: f.container.children[1],
							wrap: 0,
							index: -1
						}, {
							el: f.container.children[2],
							wrap: 0,
							index: -1
						}], a[0].el.style.display = a[2].el.style.display = "none", ne(), s = {
							resize: f.updateSize,
							orientationchange: function () {
								clearTimeout(ut), ut = setTimeout(function () {
									l.x !== f.scrollWrap.clientWidth && f.updateSize()
								}, 500)
							},
							scroll: re,
							keydown: se,
							click: oe
						};
						var e = b.isOldIOSPhone || b.isOldAndroid || b.isMobileOpera;
						for (b.animationName && b.transform && !e || (p.showAnimationDuration = p.hideAnimationDuration = 0), t = 0; t < Ft.length; t++) f["init" + Ft[t]]();
						if (W) {
							var i = f.ui = new W(f, g);
							i.init()
						}
						M("firstUpdate"), m = m || p.index || 0, (isNaN(m) || m < 0 || m >= N()) && (m = 0), f.currItem = si(m), (b.isOldIOSPhone || b.isOldAndroid) && (Rt = !1), d.setAttribute("aria-hidden", "false"), p.modal && (Rt ? d.style.position = "fixed" : (d.style.position = "absolute", d.style.top = g.getScrollY() + "px")), void 0 === ct && (M("initialLayout"), ct = lt = g.getScrollY());
						var n = "pswp--open ";
						for (p.mainClass && (n += p.mainClass + " "), p.showHideOpacity && (n += "pswp--animate_opacity "), n += o ? "pswp--touch" : "pswp--notouch", n += b.animationName ? " pswp--css_animation" : "", n += b.svg ? " pswp--svg" : "", g.addClass(d, n), f.updateSize(), r = -1, D = null, t = 0; t < B; t++) $t((t + r) * c.x, a[t].el.style);
						ht || g.bind(f.scrollWrap, U, f), h("initialZoomInEnd", function () {
							f.setContent(a[0], m - 1), f.setContent(a[2], m + 1), a[0].el.style.display = a[2].el.style.display = "block", p.focus && d.focus(), Zt()
						}), f.setContent(a[1], m), f.updateCurrItem(), M("afterInit"), Rt || (X = setInterval(function () {
							ae || _ || x || v !== f.currItem.initialZoomLevel || f.updateSize()
						}, 1e3)), g.addClass(d, "pswp--visible")
					}
				},
				close: function () {
					j && (j = !1, Y = !0, M("close"), Qt(), ri(f.currItem, null, !0, f.destroy))
				},
				destroy: function () {
					M("destroy"), ti && clearTimeout(ti), d.setAttribute("aria-hidden", "true"), d.className = at, X && clearInterval(X), g.unbind(f.scrollWrap, U, f), g.unbind(window, "scroll", f), Ie(), ce(), jt = null
				},
				panTo: function (t, e, i) {
					i || (t > u.min.x ? t = u.min.x : t < u.max.x && (t = u.max.x), e > u.min.y ? e = u.min.y : e < u.max.y && (e = u.max.y)), C.x = t, C.y = e, P()
				},
				handleEvent: function (t) {
					t = t || window.event, s[t.type] && s[t.type](t)
				},
				goTo: function (t) {
					t = Bt(t);
					var e = t - m;
					D = e, m = t, f.currItem = si(m), Lt -= e, Ut(c.x * Lt), ce(), k = !1, f.updateCurrItem()
				},
				next: function () {
					f.goTo(m + 1)
				},
				prev: function () {
					f.goTo(m - 1)
				},
				updateCurrZoomItem: function (t) {
					if (t && M("beforeChange", 0), a[1].el.children.length) {
						var e = a[1].el.children[0];
						w = g.hasClass(e, "pswp__zoom-wrap") ? e.style : null
					} else w = null;
					u = f.currItem.bounds, q = v = f.currItem.initialZoomLevel, C.x = u.center.x, C.y = u.center.y, t && M("afterChange")
				},
				invalidateCurrItems: function () {
					Z = !0;
					for (var t = 0; t < B; t++) a[t].item && (a[t].item.needsUpdate = !0)
				},
				updateCurrItem: function (t) {
					if (0 !== D) {
						var e, i = Math.abs(D);
						if (!(t && i < 2)) {
							f.currItem = si(m), zt = !1, M("beforeChange", D), i >= B && (r += D + (D > 0 ? -B : B), i = B);
							for (var n = 0; n < i; n++) D > 0 ? (e = a.shift(), a[B - 1] = e, r++, $t((r + 2) * c.x, e.el.style), f.setContent(e, m - i + n + 1 + 1)) : (e = a.pop(), a.unshift(e), r--, $t(r * c.x, e.el.style), f.setContent(e, m + i - n - 1 - 1));
							if (w && 1 === Math.abs(D)) {
								var s = si(Q);
								s.initialZoomLevel !== v && (ui(s, l), gi(s), Vt(s))
							}
							D = 0, f.updateCurrZoomItem(), Q = m, M("afterChange")
						}
					}
				},
				updateSize: function (t) {
					if (!Rt && p.modal) {
						var e = g.getScrollY();
						if (ct !== e && (d.style.top = e + "px", ct = e), !t && Ht.x === window.innerWidth && Ht.y === window.innerHeight) return;
						Ht.x = window.innerWidth, Ht.y = window.innerHeight, d.style.height = Ht.y + "px"
					}
					if (l.x = f.scrollWrap.clientWidth, l.y = f.scrollWrap.clientHeight, re(), c.x = l.x + Math.round(l.x * p.spacing), c.y = l.y, Ut(c.x * Lt), M("beforeResize"), void 0 !== r) {
						for (var i, n, s, o = 0; o < B; o++) i = a[o], $t((o + r) * c.x, i.el.style), s = m + o - 1, p.loop && N() > 2 && (s = Bt(s)), n = si(s), n && (Z || n.needsUpdate || !n.bounds) ? (f.cleanSlide(n), f.setContent(i, s), 1 === o && (f.currItem = n, f.updateCurrZoomItem(!0)), n.needsUpdate = !1) : i.index === -1 && s >= 0 && f.setContent(i, s), n && n.container && (ui(n, l), gi(n), Vt(n));
						Z = !1
					}
					q = v = f.currItem.initialZoomLevel, u = f.currItem.bounds, u && (C.x = u.center.x, C.y = u.center.y, P(!0)), M("resize")
				},
				zoomTo: function (e, t, i, n, s) {
					t && (q = v, De.x = Math.abs(t.x) - C.x, De.y = Math.abs(t.y) - C.y, I(At, C));
					var o = Jt(e, !1),
						r = {};
					ie("x", o, r, e), ie("y", o, r, e);
					var a = v,
						l = {
							x: C.x,
							y: C.y
						};
					Gt(r);
					var h = function (t) {
						1 === t ? (v = e, C.x = r.x, C.y = r.y) : (v = (e - a) * t + a, C.x = (r.x - l.x) * t + l.x, C.y = (r.y - l.y) * t + l.y), s && s(t), P(1 === t)
					};
					i ? ue("customZoomTo", 0, 1, i, n || g.easing.sine.inOut, h) : h(1)
				}
			},
			fe = 30,
			pe = 10,
			O = {},
			ge = {},
			A = {},
			L = {},
			me = {},
			ve = [],
			be = {},
			_e = [],
			ye = {},
			xe = 0,
			we = Et(),
			ke = 0,
			Ce = Et(),
			De = Et(),
			Me = Et(),
			Te = function (t, e) {
				return t.x === e.x && t.y === e.y
			},
			Se = function (t, e) {
				return Math.abs(t.x - e.x) < i && Math.abs(t.y - e.y) < i
			},
			Pe = function (t, e) {
				return ye.x = Math.abs(t.x - e.x), ye.y = Math.abs(t.y - e.y), Math.sqrt(ye.x * ye.x + ye.y * ye.y)
			},
			Ie = function () {
				xt && (rt(xt), xt = null)
			},
			Ee = function () {
				_ && (xt = ot(Ee), qe())
			},
			Oe = function () {
				return !("fit" === p.scaleMode && v === f.currItem.initialZoomLevel)
			},
			Ae = function (t, e) {
				return !(!t || t === document) && (!(t.getAttribute("class") && t.getAttribute("class").indexOf("pswp__scroll-wrap") > -1) && (e(t) ? t : Ae(t.parentNode, e)))
			},
			Le = {},
			Ne = function (t, e) {
				return Le.prevent = !Ae(t.target, p.isClickableElement), M("preventDragEvent", t, e, Le), Le.prevent
			},
			Re = function (t, e) {
				return e.x = t.pageX, e.y = t.pageY, e.id = t.identifier, e
			},
			Fe = function (t, e, i) {
				i.x = .5 * (t.x + e.x), i.y = .5 * (t.y + e.y)
			},
			He = function (t, e, i) {
				if (t - ft > 50) {
					var n = _e.length > 2 ? _e.shift() : {};
					n.x = e, n.y = i, _e.push(n), ft = t
				}
			},
			ze = function () {
				var t = C.y - f.currItem.initialPosition.y;
				return 1 - Math.abs(t / (l.y / 2))
			},
			We = {},
			Be = {},
			je = [],
			Ye = function (t) {
				for (; je.length > 0;) je.pop();
				return st ? (It = 0, ve.forEach(function (t) {
					0 === It ? je[0] = t : 1 === It && (je[1] = t), It++
				})) : t.type.indexOf("touch") > -1 ? t.touches && t.touches.length > 0 && (je[0] = Re(t.touches[0], We), t.touches.length > 1 && (je[1] = Re(t.touches[1], Be))) : (We.x = t.pageX, We.y = t.pageY, We.id = "", je[0] = We), je
			},
			Ve = function (t, e) {
				var i, n, s, o, r = 0,
					a = C[t] + e[t],
					l = e[t] > 0,
					h = Ce.x + e.x,
					c = Ce.x - be.x;
				return i = a > u.min[t] || a < u.max[t] ? p.panEndFriction : 1, a = C[t] + e[t] * i, !p.allowPanToNext && v !== f.currItem.initialZoomLevel || (w ? "h" !== Dt || "x" !== t || _t || (l ? (a > u.min[t] && (i = p.panEndFriction, r = u.min[t] - a, n = u.min[t] - At[t]), (n <= 0 || c < 0) && N() > 1 ? (o = h, c < 0 && h > be.x && (o = be.x)) : u.min.x !== u.max.x && (s = a)) : (a < u.max[t] && (i = p.panEndFriction, r = a - u.max[t], n = At[t] - u.max[t]), (n <= 0 || c > 0) && N() > 1 ? (o = h, c > 0 && h < be.x && (o = be.x)) : u.min.x !== u.max.x && (s = a))) : o = h, "x" !== t) ? void (k || wt || v > f.currItem.fitRatio && (C[t] += e[t] * i)) : (void 0 !== o && (Ut(o, !0), wt = o !== be.x), u.min.x !== u.max.x && (void 0 !== s ? C.x = s : wt || (C.x += e.x * i)), void 0 !== o)
			},
			$e = function (t) {
				if (!("mousedown" === t.type && t.button > 0)) {
					if (ni) return void t.preventDefault();
					if (!vt || "mousedown" !== t.type) {
						if (Ne(t, !0) && t.preventDefault(), M("pointerDown"), st) {
							var e = g.arraySearch(ve, t.pointerId, "id");
							e < 0 && (e = ve.length), ve[e] = {
								x: t.pageX,
								y: t.pageY,
								id: t.pointerId
							}
						}
						var i = Ye(t),
							n = i.length;
						y = null, ce(), _ && 1 !== n || (_ = Mt = !0, g.bind(window, $, f), gt = Pt = Tt = mt = wt = yt = bt = _t = !1, Dt = null, M("firstTouchStart", i), I(At, C), Ot.x = Ot.y = 0, I(L, i[0]), I(me, L), be.x = c.x * Lt, _e = [{
							x: L.x,
							y: L.y
						}], ft = dt = T(), Jt(v, !0), Ie(), Ee()), !x && n > 1 && !k && !wt && (q = v, _t = !1, x = bt = !0, Ot.y = Ot.x = 0, I(At, C), I(O, i[0]), I(ge, i[1]), Fe(O, ge, Me), De.x = Math.abs(Me.x) - C.x, De.y = Math.abs(Me.y) - C.y, kt = Ct = Pe(O, ge))
					}
				}
			},
			Ue = function (t) {
				if (t.preventDefault(), st) {
					var e = g.arraySearch(ve, t.pointerId, "id");
					if (e > -1) {
						var i = ve[e];
						i.x = t.pageX, i.y = t.pageY
					}
				}
				if (_) {
					var n = Ye(t);
					if (Dt || yt || x) y = n;
					else if (Ce.x !== c.x * Lt) Dt = "h";
					else {
						var s = Math.abs(n[0].x - L.x) - Math.abs(n[0].y - L.y);
						Math.abs(s) >= pe && (Dt = s > 0 ? "h" : "v", y = n)
					}
				}
			},
			qe = function () {
				if (y) {
					var t = y.length;
					if (0 !== t)
						if (I(O, y[0]), A.x = O.x - L.x, A.y = O.y - L.y, x && t > 1) {
							if (L.x = O.x, L.y = O.y, !A.x && !A.y && Te(y[1], ge)) return;
							I(ge, y[1]), _t || (_t = !0, M("zoomGestureStarted"));
							var e = Pe(O, ge),
								i = Qe(e);
							i > f.currItem.initialZoomLevel + f.currItem.initialZoomLevel / 15 && (Pt = !0);
							var n = 1,
								s = te(),
								o = ee();
							if (i < s)
								if (p.pinchToClose && !Pt && q <= f.currItem.initialZoomLevel) {
									var r = s - i,
										a = 1 - r / (s / 1.2);
									S(a), M("onPinchClose", a), Tt = !0
								} else n = (s - i) / s, n > 1 && (n = 1), i = s - n * (s / 3);
							else i > o && (n = (i - o) / (6 * s), n > 1 && (n = 1), i = o + n * s);
							n < 0 && (n = 0), kt = e, Fe(O, ge, we), Ot.x += we.x - Me.x, Ot.y += we.y - Me.y, I(Me, we), C.x = qt("x", i), C.y = qt("y", i), gt = i > v, v = i, P()
						} else {
							if (!Dt) return;
							if (Mt && (Mt = !1, Math.abs(A.x) >= pe && (A.x -= y[0].x - me.x), Math.abs(A.y) >= pe && (A.y -= y[0].y - me.y)), L.x = O.x, L.y = O.y, 0 === A.x && 0 === A.y) return;
							if ("v" === Dt && p.closeOnVerticalDrag && !Oe()) {
								Ot.y += A.y, C.y += A.y;
								var l = ze();
								return mt = !0, M("onVerticalDrag", l), S(l), void P()
							}
							He(T(), O.x, O.y), yt = !0, u = f.currItem.bounds;
							var h = Ve("x", A);
							h || (Ve("y", A), Gt(C), P())
						}
				}
			},
			Ge = function (t) {
				if (b.isOldAndroid) {
					if (vt && "mouseup" === t.type) return;
					t.type.indexOf("touch") > -1 && (clearTimeout(vt), vt = setTimeout(function () {
						vt = 0
					}, 600))
				}
				M("pointerUp"), Ne(t, !1) && t.preventDefault();
				var e;
				if (st) {
					var i = g.arraySearch(ve, t.pointerId, "id");
					if (i > -1)
						if (e = ve.splice(i, 1)[0], navigator.pointerEnabled) e.type = t.pointerType || "mouse";
						else {
							var n = {
								4: "mouse",
								2: "touch",
								3: "pen"
							};
							e.type = n[t.pointerType], e.type || (e.type = t.pointerType || "mouse")
						}
				}
				var s, o = Ye(t),
					r = o.length;
				if ("mouseup" === t.type && (r = 0), 2 === r) return y = null, !0;
				1 === r && I(me, o[0]), 0 !== r || Dt || k || (e || ("mouseup" === t.type ? e = {
					x: t.pageX,
					y: t.pageY,
					type: "mouse"
				} : t.changedTouches && t.changedTouches[0] && (e = {
					x: t.changedTouches[0].pageX,
					y: t.changedTouches[0].pageY,
					type: "touch"
				})), M("touchRelease", t, e));
				var a = -1;
				if (0 === r && (_ = !1, g.unbind(window, $, f), Ie(), x ? a = 0 : ke !== -1 && (a = T() - ke)), ke = 1 === r ? T() : -1, s = a !== -1 && a < 150 ? "zoom" : "swipe", x && r < 2 && (x = !1, 1 === r && (s = "zoomPointerUp"), M("zoomGestureEnded")), y = null, yt || _t || k || mt)
					if (ce(), pt || (pt = Ke()), pt.calculateSwipeSpeed("x"), mt) {
						var l = ze();
						if (l < p.verticalDragRange) f.close();
						else {
							var h = C.y,
								c = St;
							ue("verticalDrag", 0, 1, 300, g.easing.cubic.out, function (t) {
								C.y = (f.currItem.initialPosition.y - h) * t + h, S((1 - c) * t + c), P()
							}), M("onVerticalDrag", 1)
						}
					} else {
						if ((wt || k) && 0 === r) {
							var u = Ze(s, pt);
							if (u) return;
							s = "zoomPointerUp"
						}
						if (!k) return "swipe" !== s ? void Je() : void (!wt && v > f.currItem.fitRatio && Xe(pt))
					}
			},
			Ke = function () {
				var e, i, n = {
					lastFlickOffset: {},
					lastFlickDist: {},
					lastFlickSpeed: {},
					slowDownRatio: {},
					slowDownRatioReverse: {},
					speedDecelerationRatio: {},
					speedDecelerationRatioAbs: {},
					distanceOffset: {},
					backAnimDestination: {},
					backAnimStarted: {},
					calculateSwipeSpeed: function (t) {
						_e.length > 1 ? (e = T() - ft + 50, i = _e[_e.length - 2][t]) : (e = T() - dt, i = me[t]), n.lastFlickOffset[t] = L[t] - i, n.lastFlickDist[t] = Math.abs(n.lastFlickOffset[t]), n.lastFlickDist[t] > 20 ? n.lastFlickSpeed[t] = n.lastFlickOffset[t] / e : n.lastFlickSpeed[t] = 0, Math.abs(n.lastFlickSpeed[t]) < .1 && (n.lastFlickSpeed[t] = 0), n.slowDownRatio[t] = .95, n.slowDownRatioReverse[t] = 1 - n.slowDownRatio[t], n.speedDecelerationRatio[t] = 1
					},
					calculateOverBoundsAnimOffset: function (e, t) {
						n.backAnimStarted[e] || (C[e] > u.min[e] ? n.backAnimDestination[e] = u.min[e] : C[e] < u.max[e] && (n.backAnimDestination[e] = u.max[e]), void 0 !== n.backAnimDestination[e] && (n.slowDownRatio[e] = .7, n.slowDownRatioReverse[e] = 1 - n.slowDownRatio[e], n.speedDecelerationRatioAbs[e] < .05 && (n.lastFlickSpeed[e] = 0, n.backAnimStarted[e] = !0, ue("bounceZoomPan" + e, C[e], n.backAnimDestination[e], t || 300, g.easing.sine.out, function (t) {
							C[e] = t, P()
						}))))
					},
					calculateAnimOffset: function (t) {
						n.backAnimStarted[t] || (n.speedDecelerationRatio[t] = n.speedDecelerationRatio[t] * (n.slowDownRatio[t] + n.slowDownRatioReverse[t] - n.slowDownRatioReverse[t] * n.timeDiff / 10), n.speedDecelerationRatioAbs[t] = Math.abs(n.lastFlickSpeed[t] * n.speedDecelerationRatio[t]), n.distanceOffset[t] = n.lastFlickSpeed[t] * n.speedDecelerationRatio[t] * n.timeDiff, C[t] += n.distanceOffset[t])
					},
					panAnimLoop: function () {
						if (E.zoomPan && (E.zoomPan.raf = ot(n.panAnimLoop), n.now = T(), n.timeDiff = n.now - n.lastNow, n.lastNow = n.now, n.calculateAnimOffset("x"), n.calculateAnimOffset("y"), P(), n.calculateOverBoundsAnimOffset("x"), n.calculateOverBoundsAnimOffset("y"), n.speedDecelerationRatioAbs.x < .05 && n.speedDecelerationRatioAbs.y < .05)) return C.x = Math.round(C.x), C.y = Math.round(C.y), P(), void le("zoomPan")
					}
				};
				return n
			},
			Xe = function (t) {
				return t.calculateSwipeSpeed("y"), u = f.currItem.bounds, t.backAnimDestination = {}, t.backAnimStarted = {}, Math.abs(t.lastFlickSpeed.x) <= .05 && Math.abs(t.lastFlickSpeed.y) <= .05 ? (t.speedDecelerationRatioAbs.x = t.speedDecelerationRatioAbs.y = 0, t.calculateOverBoundsAnimOffset("x"), t.calculateOverBoundsAnimOffset("y"), !0) : (he("zoomPan"), t.lastNow = T(), void t.panAnimLoop())
			},
			Ze = function (t, e) {
				var i;
				k || (xe = m);
				var n;
				if ("swipe" === t) {
					var s = L.x - me.x,
						o = e.lastFlickDist.x < 10;
					s > fe && (o || e.lastFlickOffset.x > 20) ? n = -1 : s < -fe && (o || e.lastFlickOffset.x < -20) && (n = 1)
				}
				var r;
				n && (m += n, m < 0 ? (m = p.loop ? N() - 1 : 0, r = !0) : m >= N() && (m = p.loop ? 0 : N() - 1, r = !0), r && !p.loop || (D += n, Lt -= n, i = !0));
				var a, l = c.x * Lt,
					h = Math.abs(l - Ce.x);
				return i || l > Ce.x == e.lastFlickSpeed.x > 0 ? (a = Math.abs(e.lastFlickSpeed.x) > 0 ? h / Math.abs(e.lastFlickSpeed.x) : 333, a = Math.min(a, 400), a = Math.max(a, 250)) : a = 333, xe === m && (i = !1), k = !0, M("mainScrollAnimStart"), ue("mainScroll", Ce.x, l, a, g.easing.cubic.out, Ut, function () {
					ce(), k = !1, xe = -1, (i || xe !== m) && f.updateCurrItem(), M("mainScrollAnimComplete")
				}), i && f.updateCurrItem(!0), i
			},
			Qe = function (t) {
				return 1 / Ct * t * q
			},
			Je = function () {
				var t = v,
					e = te(),
					i = ee();
				v < e ? t = e : v > i && (t = i);
				var n, s = 1,
					o = St;
				return Tt && !gt && !Pt && v < e ? (f.close(), !0) : (Tt && (n = function (t) {
					S((s - o) * t + o)
				}), f.zoomTo(t, 0, 200, g.easing.cubic.out, n), !0)
			};
		Wt("Gestures", {
			publicMethods: {
				initGestures: function () {
					var t = function (t, e, i, n, s) {
						J = t + e, tt = t + i, et = t + n, it = s ? t + s : ""
					};
					st = b.pointerEvent, st && b.touch && (b.touch = !1), st ? navigator.pointerEnabled ? t("pointer", "down", "move", "up", "cancel") : t("MSPointer", "Down", "Move", "Up", "Cancel") : b.touch ? (t("touch", "start", "move", "end", "cancel"), o = !0) : t("mouse", "down", "move", "up"), $ = tt + " " + et + " " + it, U = J, st && !o && (o = navigator.maxTouchPoints > 1 || navigator.msMaxTouchPoints > 1), f.likelyTouchDevice = o, s[J] = $e, s[tt] = Ue, s[et] = Ge, it && (s[it] = s[et]), b.touch && (U += " mousedown", $ += " mousemove mouseup", s.mousedown = s[J], s.mousemove = s[tt], s.mouseup = s[et]), o || (p.allowPanToNext = !1)
				}
			}
		});
		var ti, ei, ii, ni, si, N, oi, ri = function (a, t, l, e) {
			ti && clearTimeout(ti), ni = !0, ii = !0;
			var h;
			a.initialLayout ? (h = a.initialLayout, a.initialLayout = null) : h = p.getThumbBoundsFn && p.getThumbBoundsFn(m);
			var c = l ? p.hideAnimationDuration : p.showAnimationDuration,
				u = function () {
					le("initialZoom"), l ? (f.template.removeAttribute("style"), f.bg.removeAttribute("style")) : (S(1), t && (t.style.display = "block"), g.addClass(d, "pswp--animated-in"), M("initialZoom" + (l ? "OutEnd" : "InEnd"))), e && e(), ni = !1
				};
			if (!c || !h || void 0 === h.x) return M("initialZoom" + (l ? "Out" : "In")), v = a.initialZoomLevel, I(C, a.initialPosition), P(), d.style.opacity = l ? 0 : 1, S(1), void (c ? setTimeout(function () {
				u()
			}, c) : u());
			var i = function () {
				var o = n,
					r = !f.currItem.src || f.currItem.loadError || p.showHideOpacity;
				a.miniImg && (a.miniImg.style.webkitBackfaceVisibility = "hidden"), l || (v = h.w / a.w, C.x = h.x, C.y = h.y - lt, f[r ? "template" : "bg"].style.opacity = .001, P()), he("initialZoom"), l && !o && g.removeClass(d, "pswp--animated-in"), r && (l ? g[(o ? "remove" : "add") + "Class"](d, "pswp--animate_opacity") : setTimeout(function () {
					g.addClass(d, "pswp--animate_opacity")
				}, 30)), ti = setTimeout(function () {
					if (M("initialZoom" + (l ? "Out" : "In")), l) {
						var e = h.w / a.w,
							i = {
								x: C.x,
								y: C.y
							},
							n = v,
							s = St,
							t = function (t) {
								1 === t ? (v = e, C.x = h.x, C.y = h.y - ct) : (v = (e - n) * t + n, C.x = (h.x - i.x) * t + i.x, C.y = (h.y - ct - i.y) * t + i.y), P(), r ? d.style.opacity = 1 - t : S(s - t * s)
							};
						o ? ue("initialZoom", 0, 1, c, g.easing.cubic.out, t, u) : (t(1), ti = setTimeout(u, c + 20))
					} else v = a.initialZoomLevel, I(C, a.initialPosition), P(), S(1), r ? d.style.opacity = 1 : S(1), ti = setTimeout(u, c + 20)
				}, l ? 25 : 90)
			};
			i()
		},
			R = {},
			ai = [],
			li = {
				index: 0,
				errorMsg: '<div class="pswp__error-msg"><a href="%url%" target="_blank">The image</a> could not be loaded.</div>',
				forceProgressiveLoading: !1,
				preload: [1, 1],
				getNumItemsFn: function () {
					return ei.length
				}
			},
			hi = function () {
				return {
					center: {
						x: 0,
						y: 0
					},
					max: {
						x: 0,
						y: 0
					},
					min: {
						x: 0,
						y: 0
					}
				}
			},
			ci = function (t, e, i) {
				var n = t.bounds;
				n.center.x = Math.round((R.x - e) / 2), n.center.y = Math.round((R.y - i) / 2) + t.vGap.top, n.max.x = e > R.x ? Math.round(R.x - e) : n.center.x, n.max.y = i > R.y ? Math.round(R.y - i) + t.vGap.top : n.center.y, n.min.x = e > R.x ? 0 : n.center.x, n.min.y = i > R.y ? t.vGap.top : n.center.y
			},
			ui = function (t, e, i) {
				if (t.src && !t.loadError) {
					var n = !i;
					if (n && (t.vGap || (t.vGap = {
						top: 0,
						bottom: 0
					}), M("parseVerticalMargin", t)), R.x = e.x, R.y = e.y - t.vGap.top - t.vGap.bottom, n) {
						var s = R.x / t.w,
							o = R.y / t.h;
						t.fitRatio = s < o ? s : o;
						var r = p.scaleMode;
						"orig" === r ? i = 1 : "fit" === r && (i = t.fitRatio), i > 1 && (i = 1), t.initialZoomLevel = i, t.bounds || (t.bounds = hi())
					}
					if (!i) return;
					return ci(t, t.w * i, t.h * i), n && i === t.initialZoomLevel && (t.initialPosition = t.bounds.center), t.bounds
				}
				return t.w = t.h = 0, t.initialZoomLevel = t.fitRatio = 1, t.bounds = hi(), t.initialPosition = t.bounds.center, t.bounds
			},
			di = function (t, e, i, n, s, o) {
				e.loadError || n && (e.imageAppended = !0, gi(e, n, e === f.currItem && zt), i.appendChild(n), o && setTimeout(function () {
					e && e.loaded && e.placeholder && (e.placeholder.style.display = "none", e.placeholder = null)
				}, 500))
			},
			fi = function (t) {
				t.loading = !0, t.loaded = !1;
				var e = t.img = g.createEl("pswp__img", "img"),
					i = function () {
						t.loading = !1, t.loaded = !0, t.loadComplete ? t.loadComplete(t) : t.img = null, e.onload = e.onerror = null, e = null
					};
				return e.onload = i, e.onerror = function () {
					t.loadError = !0, i()
				}, e.src = t.src, e
			},
			pi = function (t, e) {
				if (t.src && t.loadError && t.container) return e && (t.container.innerHTML = ""), t.container.innerHTML = p.errorMsg.replace("%url%", t.src), !0
			},
			gi = function (t, e, i) {
				if (t.src) {
					e || (e = t.container.lastChild);
					var n = i ? t.w : Math.round(t.w * t.fitRatio),
						s = i ? t.h : Math.round(t.h * t.fitRatio);
					t.placeholder && !t.loaded && (t.placeholder.style.width = n + "px", t.placeholder.style.height = s + "px"), e.style.width = n + "px", e.style.height = s + "px"
				}
			},
			mi = function () {
				if (ai.length) {
					for (var t, e = 0; e < ai.length; e++) t = ai[e], t.holder.index === t.index && di(t.index, t.item, t.baseDiv, t.img, !1, t.clearPlaceholder);
					ai = []
				}
			};
		Wt("Controller", {
			publicMethods: {
				lazyLoadItem: function (t) {
					t = Bt(t);
					var e = si(t);
					e && (!e.loaded && !e.loading || Z) && (M("gettingData", t, e), e.src && fi(e))
				},
				initController: function () {
					g.extend(p, li, !0), f.items = ei = t, si = f.getItemAt, N = p.getNumItemsFn, oi = p.loop, N() < 3 && (p.loop = !1), h("beforeChange", function (t) {
						var e, i = p.preload,
							n = null === t || t >= 0,
							s = Math.min(i[0], N()),
							o = Math.min(i[1], N());
						for (e = 1; e <= (n ? o : s); e++) f.lazyLoadItem(m + e);
						for (e = 1; e <= (n ? s : o); e++) f.lazyLoadItem(m - e)
					}), h("initialLayout", function () {
						f.currItem.initialLayout = p.getThumbBoundsFn && p.getThumbBoundsFn(m)
					}), h("mainScrollAnimComplete", mi), h("initialZoomInEnd", mi), h("destroy", function () {
						for (var t, e = 0; e < ei.length; e++) t = ei[e], t.container && (t.container = null), t.placeholder && (t.placeholder = null), t.img && (t.img = null), t.preloader && (t.preloader = null), t.loadError && (t.loaded = t.loadError = !1);
						ai = null
					})
				},
				getItemAt: function (t) {
					return t >= 0 && (void 0 !== ei[t] && ei[t])
				},
				allowProgressiveImg: function () {
					return p.forceProgressiveLoading || !o || p.mouseUsed || screen.width > 1200
				},
				setContent: function (e, i) {
					p.loop && (i = Bt(i));
					var t = f.getItemAt(e.index);
					t && (t.container = null);
					var n, s = f.getItemAt(i);
					if (!s) return void (e.el.innerHTML = "");
					M("gettingData", i, s), e.index = i, e.item = s;
					var o = s.container = g.createEl("pswp__zoom-wrap");
					if (!s.src && s.html && (s.html.tagName ? o.appendChild(s.html) : o.innerHTML = s.html), pi(s), ui(s, l), !s.src || s.loadError || s.loaded) s.src && !s.loadError && (n = g.createEl("pswp__img", "img"), n.style.opacity = 1, n.src = s.src, gi(s, n), di(i, s, o, n, !0));
					else {
						if (s.loadComplete = function (t) {
							if (j) {
								if (e && e.index === i) {
									if (pi(t, !0)) return t.loadComplete = t.img = null, ui(t, l), Vt(t), void (e.index === m && f.updateCurrZoomItem());
									t.imageAppended ? !ni && t.placeholder && (t.placeholder.style.display = "none", t.placeholder = null) : b.transform && (k || ni) ? ai.push({
										item: t,
										baseDiv: o,
										img: t.img,
										index: i,
										holder: e,
										clearPlaceholder: !0
									}) : di(i, t, o, t.img, k || ni, !0)
								}
								t.loadComplete = null, t.img = null, M("imageLoadComplete", i, t)
							}
						}, g.features.transform) {
							var r = "pswp__img pswp__img--placeholder";
							r += s.msrc ? "" : " pswp__img--placeholder--blank";
							var a = g.createEl(r, s.msrc ? "img" : "");
							s.msrc && (a.src = s.msrc), gi(s, a), o.appendChild(a), s.placeholder = a
						}
						s.loading || fi(s), f.allowProgressiveImg() && (!ii && b.transform ? ai.push({
							item: s,
							baseDiv: o,
							img: s.img,
							index: i,
							holder: e
						}) : di(i, s, o, s.img, !0, !0))
					}
					ii || i !== m ? Vt(s) : (w = o.style, ri(s, n || s.img)), e.el.innerHTML = "", e.el.appendChild(o)
				},
				cleanSlide: function (t) {
					t.img && (t.img.onload = t.img.onerror = null), t.loaded = t.loading = t.img = t.imageAppended = !1
				}
			}
		});
		var vi, bi = {},
			_i = function (t, e, i) {
				var n = document.createEvent("CustomEvent"),
					s = {
						origEvent: t,
						target: t.target,
						releasePoint: e,
						pointerType: i || "touch"
					};
				n.initCustomEvent("pswpTap", !0, !0, s), t.target.dispatchEvent(n)
			};
		Wt("Tap", {
			publicMethods: {
				initTap: function () {
					h("firstTouchStart", f.onTapStart), h("touchRelease", f.onTapRelease), h("destroy", function () {
						bi = {}, vi = null
					})
				},
				onTapStart: function (t) {
					t.length > 1 && (clearTimeout(vi), vi = null)
				},
				onTapRelease: function (t, e) {
					if (e && !yt && !bt && !ae) {
						var i = e;
						if (vi && (clearTimeout(vi), vi = null, Se(i, bi))) return void M("doubleTap", i);
						if ("mouse" === e.type) return void _i(t, e, "mouse");
						var n = t.target.tagName.toUpperCase();
						if ("BUTTON" === n || g.hasClass(t.target, "pswp__single-tap")) return void _i(t, e);
						I(bi, i), vi = setTimeout(function () {
							_i(t, e), vi = null
						}, 300)
					}
				}
			}
		});
		var F;
		Wt("DesktopZoom", {
			publicMethods: {
				initDesktopZoom: function () {
					ht || (o ? h("mouseUsed", function () {
						f.setupDesktopZoom()
					}) : f.setupDesktopZoom(!0))
				},
				setupDesktopZoom: function (t) {
					F = {};
					var e = "wheel mousewheel DOMMouseScroll";
					h("bindEvents", function () {
						g.bind(d, e, f.handleMouseWheel)
					}), h("unbindEvents", function () {
						F && g.unbind(d, e, f.handleMouseWheel)
					}), f.mouseZoomedIn = !1;
					var i, n = function () {
						f.mouseZoomedIn && (g.removeClass(d, "pswp--zoomed-in"), f.mouseZoomedIn = !1), v < 1 ? g.addClass(d, "pswp--zoom-allowed") : g.removeClass(d, "pswp--zoom-allowed"), s()
					},
						s = function () {
							i && (g.removeClass(d, "pswp--dragging"), i = !1)
						};
					h("resize", n), h("afterChange", n), h("pointerDown", function () {
						f.mouseZoomedIn && (i = !0, g.addClass(d, "pswp--dragging"))
					}), h("pointerUp", s), t || n()
				},
				handleMouseWheel: function (t) {
					if (v <= f.currItem.fitRatio) return p.modal && (!p.closeOnScroll || ae || _ ? t.preventDefault() : nt && Math.abs(t.deltaY) > 2 && (n = !0, f.close())), !0;
					if (t.stopPropagation(), F.x = 0, "deltaX" in t) 1 === t.deltaMode ? (F.x = 18 * t.deltaX, F.y = 18 * t.deltaY) : (F.x = t.deltaX, F.y = t.deltaY);
					else if ("wheelDelta" in t) t.wheelDeltaX && (F.x = -.16 * t.wheelDeltaX), t.wheelDeltaY ? F.y = -.16 * t.wheelDeltaY : F.y = -.16 * t.wheelDelta;
					else {
						if (!("detail" in t)) return;
						F.y = t.detail
					}
					Jt(v, !0);
					var e = C.x - F.x,
						i = C.y - F.y;
					(p.modal || e <= u.min.x && e >= u.max.x && i <= u.min.y && i >= u.max.y) && t.preventDefault(), f.panTo(e, i)
				},
				toggleDesktopZoom: function (t) {
					t = t || {
						x: l.x / 2 + Nt.x,
						y: l.y / 2 + Nt.y
					};
					var e = p.getDoubleTapZoom(!0, f.currItem),
						i = v === e;
					f.mouseZoomedIn = !i, f.zoomTo(i ? f.currItem.initialZoomLevel : e, t, 333), g[(i ? "remove" : "add") + "Class"](d, "pswp--zoomed-in")
				}
			}
		});
		var yi, xi, wi, ki, Ci, Di, H, Mi, Ti, Si, z, Pi, Ii = {
			history: !0,
			galleryUID: 1
		},
			Ei = function () {
				return z.hash.substring(1)
			},
			Oi = function () {
				yi && clearTimeout(yi), wi && clearTimeout(wi)
			},
			Ai = function () {
				var t = Ei(),
					e = {};
				if (t.length < 5) return e;
				var i, n = t.split("&");
				for (i = 0; i < n.length; i++)
					if (n[i]) {
						var s = n[i].split("=");
						s.length < 2 || (e[s[0]] = s[1])
					}
				if (p.galleryPIDs) {
					var o = e.pid;
					for (e.pid = 0, i = 0; i < ei.length; i++)
						if (ei[i].pid === o) {
							e.pid = i;
							break
						}
				} else e.pid = parseInt(e.pid, 10) - 1;
				return e.pid < 0 && (e.pid = 0), e
			},
			Li = function () {
				if (wi && clearTimeout(wi), ae || _) return void (wi = setTimeout(Li, 500));
				ki ? clearTimeout(xi) : ki = !0;
				var t = m + 1,
					e = si(m);
				e.hasOwnProperty("pid") && (t = e.pid);
				var i = H + "&gid=" + p.galleryUID + "&pid=" + t;
				Mi || z.hash.indexOf(i) === -1 && (Si = !0);
				var n = z.href.split("#")[0] + "#" + i;
				Pi ? "#" + i !== window.location.hash && history[Mi ? "replaceState" : "pushState"]("", document.title, n) : Mi ? z.replace(n) : z.hash = i, Mi = !0, xi = setTimeout(function () {
					ki = !1
				}, 60)
			};
		Wt("History", {
			publicMethods: {
				initHistory: function () {
					if (g.extend(p, Ii, !0), p.history) {
						z = window.location, Si = !1, Ti = !1, Mi = !1, H = Ei(), Pi = "pushState" in history, H.indexOf("gid=") > -1 && (H = H.split("&gid=")[0], H = H.split("?gid=")[0]), h("afterChange", f.updateURL), h("unbindEvents", function () {
							g.unbind(window, "hashchange", f.onHashChange)
						});
						var t = function () {
							Di = !0, Ti || (Si ? history.back() : H ? z.hash = H : Pi ? history.pushState("", document.title, z.pathname + z.search) : z.hash = ""), Oi()
						};
						h("unbindEvents", function () {
							n && t()
						}), h("destroy", function () {
							Di || t()
						}), h("firstUpdate", function () {
							m = Ai().pid
						});
						var e = H.indexOf("pid=");
						e > -1 && (H = H.substring(0, e), "&" === H.slice(-1) && (H = H.slice(0, -1))), setTimeout(function () {
							j && g.bind(window, "hashchange", f.onHashChange)
						}, 40)
					}
				},
				onHashChange: function () {
					return Ei() === H ? (Ti = !0, void f.close()) : void (ki || (Ci = !0, f.goTo(Ai().pid), Ci = !1))
				},
				updateURL: function () {
					Oi(), Ci || (Mi ? yi = setTimeout(Li, 800) : Li())
				}
			}
		}), g.extend(f, de)
	};
	return t
});
! function (t, e) {
	"function" == typeof define && define.amd ? define(e) : "object" == typeof exports ? module.exports = e() : t.PhotoSwipeUI_Default = e()
}(this, function () {
	"use strict";
	var t = function (n, a) {
		var e, l, s, o, i, r, h, c, u, t, d, f, p, g, m, v, b, _, y, x = this,
			w = !1,
			k = !0,
			C = !0,
			R = {
				barsSize: {
					top: 44,
					bottom: "auto"
				},
				closeElClasses: ["item", "caption", "zoom-wrap", "ui", "top-bar"],
				timeToIdle: 4e3,
				timeToIdleOutside: 1e3,
				loadingIndicatorDelay: 1e3,
				addCaptionHTMLFn: function (t, e) {
					return t.title ? (e.children[0].innerHTML = t.title, !0) : (e.children[0].innerHTML = "", !1)
				},
				closeEl: !0,
				captionEl: !0,
				fullscreenEl: !0,
				zoomEl: !0,
				shareEl: !0,
				counterEl: !0,
				arrowEl: !0,
				preloaderEl: !0,
				tapToClose: !1,
				tapToToggleControls: !0,
				clickToCloseNonZoomable: !0,
				shareButtons: [{
					id: "facebook",
					label: "Share on Facebook",
					url: "https://www.facebook.com/sharer/sharer.php?u={{url}}"
				}, {
					id: "twitter",
					label: "Tweet",
					url: "https://twitter.com/intent/tweet?text={{text}}&url={{url}}"
				}, {
					id: "pinterest",
					label: "Pin it",
					url: "http://www.pinterest.com/pin/create/button/?url={{url}}&media={{image_url}}&description={{text}}"
				}, {
					id: "download",
					label: "Download image",
					url: "{{raw_image_url}}",
					download: !0
				}],
				getImageURLForShare: function () {
					return n.currItem.src || ""
				},
				getPageURLForShare: function () {
					return window.location.href
				},
				getTextForShare: function () {
					return n.currItem.title || ""
				},
				indexIndicatorSep: " / ",
				fitControlsWidth: 1200
			},
			D = function (t) {
				if (v) return !0;
				t = t || window.event, m.timeToIdle && m.mouseUsed && !u && O();
				for (var e, i, n = t.target || t.srcElement, s = n.getAttribute("class") || "", o = 0; o < N.length; o++) e = N[o], e.onTap && s.indexOf("pswp__" + e.name) > -1 && (e.onTap(), i = !0);
				if (i) {
					t.stopPropagation && t.stopPropagation(), v = !0;
					var r = a.features.isOldAndroid ? 600 : 30;
					b = setTimeout(function () {
						v = !1
					}, r)
				}
			},
			F = function () {
				return !n.likelyTouchDevice || m.mouseUsed || screen.width > m.fitControlsWidth
			},
			M = function (t, e, i) {
				a[(i ? "add" : "remove") + "Class"](t, "pswp__" + e)
			},
			T = function () {
				var t = 1 === m.getNumItemsFn();
				t !== g && (M(l, "ui--one-slide", t), g = t)
			},
			S = function () {
				M(h, "share-modal--hidden", C)
			},
			P = function () {
				return C = !C, C ? (a.removeClass(h, "pswp__share-modal--fade-in"), setTimeout(function () {
					C && S()
				}, 300)) : (S(), setTimeout(function () {
					C || a.addClass(h, "pswp__share-modal--fade-in")
				}, 30)), C || z(), !1
			},
			H = function (t) {
				t = t || window.event;
				var e = t.target || t.srcElement;
				return n.shout("shareLinkClick", t, e), !!e.href && (!!e.hasAttribute("download") || (window.open(e.href, "pswp_share", "scrollbars=yes,resizable=yes,toolbar=no,location=yes,width=550,height=420,top=100,left=" + (window.screen ? Math.round(screen.width / 2 - 275) : 100)), C || P(), !1))
			},
			z = function () {
				for (var t, e, i, n, s, o = "", r = 0; r < m.shareButtons.length; r++) t = m.shareButtons[r], i = m.getImageURLForShare(t), n = m.getPageURLForShare(t), s = m.getTextForShare(t), e = t.url.replace("{{url}}", encodeURIComponent(n)).replace("{{image_url}}", encodeURIComponent(i)).replace("{{raw_image_url}}", i).replace("{{text}}", encodeURIComponent(s)), o += '<a href="' + e + '" target="_blank" class="pswp__share--' + t.id + '"' + (t.download ? "download" : "") + ">" + t.label + "</a>", m.parseShareButtonOut && (o = m.parseShareButtonOut(t, o));
				h.children[0].innerHTML = o, h.children[0].onclick = H
			},
			I = function (t) {
				for (var e = 0; e < m.closeElClasses.length; e++)
					if (a.hasClass(t, "pswp__" + m.closeElClasses[e])) return !0
			},
			E = 0,
			O = function () {
				clearTimeout(y), E = 0, u && x.setIdle(!1)
			},
			A = function (t) {
				t = t ? t : window.event;
				var e = t.relatedTarget || t.toElement;
				e && "HTML" !== e.nodeName || (clearTimeout(y), y = setTimeout(function () {
					x.setIdle(!0)
				}, m.timeToIdleOutside))
			},
			W = function () {
				m.fullscreenEl && !a.features.isOldAndroid && (e || (e = x.getFullscreenAPI()), e ? (a.bind(document, e.eventK, x.updateFullscreen), x.updateFullscreen(), a.addClass(n.template, "pswp--supports-fs")) : a.removeClass(n.template, "pswp--supports-fs"))
			},
			B = function () {
				m.preloaderEl && (L(!0), t("beforeChange", function () {
					clearTimeout(p), p = setTimeout(function () {
						n.currItem && n.currItem.loading ? (!n.allowProgressiveImg() || n.currItem.img && !n.currItem.img.naturalWidth) && L(!1) : L(!0)
					}, m.loadingIndicatorDelay)
				}), t("imageLoadComplete", function (t, e) {
					n.currItem === e && L(!0)
				}))
			},
			L = function (t) {
				f !== t && (M(d, "preloader--active", !t), f = t)
			},
			j = function (t) {
				var e = t.vGap;
				if (F()) {
					var i = m.barsSize;
					if (m.captionEl && "auto" === i.bottom)
						if (o || (o = a.createEl("pswp__caption pswp__caption--fake"), o.appendChild(a.createEl("pswp__caption__center")), l.insertBefore(o, s), a.addClass(l, "pswp__ui--fit")), m.addCaptionHTMLFn(t, o, !0)) {
							var n = o.clientHeight;
							e.bottom = parseInt(n, 10) || 44
						} else e.bottom = i.top;
					else e.bottom = "auto" === i.bottom ? 0 : i.bottom;
					e.top = i.top
				} else e.top = e.bottom = 0
			},
			Y = function () {
				m.timeToIdle && t("mouseUsed", function () {
					a.bind(document, "mousemove", O), a.bind(document, "mouseout", A), _ = setInterval(function () {
						E++, 2 === E && x.setIdle(!0)
					}, m.timeToIdle / 2)
				})
			},
			V = function () {
				t("onVerticalDrag", function (t) {
					k && t < .95 ? x.hideControls() : !k && t >= .95 && x.showControls()
				});
				var e;
				t("onPinchClose", function (t) {
					k && t < .9 ? (x.hideControls(), e = !0) : e && !k && t > .9 && x.showControls()
				}), t("zoomGestureEnded", function () {
					e = !1, e && !k && x.showControls()
				})
			},
			N = [{
				name: "caption",
				option: "captionEl",
				onInit: function (t) {
					s = t
				}
			}, {
				name: "share-modal",
				option: "shareEl",
				onInit: function (t) {
					h = t
				},
				onTap: function () {
					P()
				}
			}, {
				name: "button--share",
				option: "shareEl",
				onInit: function (t) {
					r = t
				},
				onTap: function () {
					P()
				}
			}, {
				name: "button--zoom",
				option: "zoomEl",
				onTap: n.toggleDesktopZoom
			}, {
				name: "counter",
				option: "counterEl",
				onInit: function (t) {
					i = t
				}
			}, {
				name: "button--close",
				option: "closeEl",
				onTap: n.close
			}, {
				name: "button--arrow--left",
				option: "arrowEl",
				onTap: n.prev
			}, {
				name: "button--arrow--right",
				option: "arrowEl",
				onTap: n.next
			}, {
				name: "button--fs",
				option: "fullscreenEl",
				onTap: function () {
					e.isFullscreen() ? e.exit() : e.enter()
				}
			}, {
				name: "preloader",
				option: "preloaderEl",
				onInit: function (t) {
					d = t
				}
			}],
			$ = function () {
				var s, o, r, t = function (t) {
					if (t)
						for (var e = t.length, i = 0; i < e; i++) {
							s = t[i], o = s.className;
							for (var n = 0; n < N.length; n++) r = N[n], o.indexOf("pswp__" + r.name) > -1 && (m[r.option] ? (a.removeClass(s, "pswp__element--disabled"), r.onInit && r.onInit(s)) : a.addClass(s, "pswp__element--disabled"))
						}
				};
				t(l.children);
				var e = a.getChildByClass(l, "pswp__top-bar");
				e && t(e.children)
			};
		x.init = function () {
			a.extend(n.options, R, !0), m = n.options, l = a.getChildByClass(n.scrollWrap, "pswp__ui"), t = n.listen, V(), t("beforeChange", x.update), t("doubleTap", function (t) {
				var e = n.currItem.initialZoomLevel;
				n.getZoomLevel() !== e ? n.zoomTo(e, t, 333) : n.zoomTo(m.getDoubleTapZoom(!1, n.currItem), t, 333)
			}), t("preventDragEvent", function (t, e, i) {
				var n = t.target || t.srcElement;
				n && n.getAttribute("class") && t.type.indexOf("mouse") > -1 && (n.getAttribute("class").indexOf("__caption") > 0 || /(SMALL|STRONG|EM)/i.test(n.tagName)) && (i.prevent = !1)
			}), t("bindEvents", function () {
				a.bind(l, "pswpTap click", D), a.bind(n.scrollWrap, "pswpTap", x.onGlobalTap), n.likelyTouchDevice || a.bind(n.scrollWrap, "mouseover", x.onMouseOver)
			}), t("unbindEvents", function () {
				C || P(), _ && clearInterval(_), a.unbind(document, "mouseout", A), a.unbind(document, "mousemove", O), a.unbind(l, "pswpTap click", D), a.unbind(n.scrollWrap, "pswpTap", x.onGlobalTap), a.unbind(n.scrollWrap, "mouseover", x.onMouseOver), e && (a.unbind(document, e.eventK, x.updateFullscreen), e.isFullscreen() && (m.hideAnimationDuration = 0, e.exit()), e = null)
			}), t("destroy", function () {
				m.captionEl && (o && l.removeChild(o), a.removeClass(s, "pswp__caption--empty")), h && (h.children[0].onclick = null), a.removeClass(l, "pswp__ui--over-close"), a.addClass(l, "pswp__ui--hidden"), x.setIdle(!1)
			}), m.showAnimationDuration || a.removeClass(l, "pswp__ui--hidden"), t("initialZoomIn", function () {
				m.showAnimationDuration && a.removeClass(l, "pswp__ui--hidden")
			}), t("initialZoomOut", function () {
				a.addClass(l, "pswp__ui--hidden")
			}), t("parseVerticalMargin", j), $(), m.shareEl && r && h && (C = !0), T(), Y(), W(), B()
		}, x.setIdle = function (t) {
			u = t, M(l, "ui--idle", t)
		}, x.update = function () {
			k && n.currItem ? (x.updateIndexIndicator(), m.captionEl && (m.addCaptionHTMLFn(n.currItem, s), M(s, "caption--empty", !n.currItem.title)), w = !0) : w = !1, C || P(), T()
		}, x.updateFullscreen = function (t) {
			t && setTimeout(function () {
				n.setScrollOffset(0, a.getScrollY())
			}, 50), a[(e.isFullscreen() ? "add" : "remove") + "Class"](n.template, "pswp--fs")
		}, x.updateIndexIndicator = function () {
			m.counterEl && (i.innerHTML = n.getCurrentIndex() + 1 + m.indexIndicatorSep + m.getNumItemsFn())
		}, x.onGlobalTap = function (t) {
			t = t || window.event;
			var e = t.target || t.srcElement;
			if (!v)
				if (t.detail && "mouse" === t.detail.pointerType) {
					if (I(e)) return void n.close();
					a.hasClass(e, "pswp__img") && (1 === n.getZoomLevel() && n.getZoomLevel() <= n.currItem.fitRatio ? m.clickToCloseNonZoomable && n.close() : n.toggleDesktopZoom(t.detail.releasePoint))
				} else if (m.tapToToggleControls && (k ? x.hideControls() : x.showControls()), m.tapToClose && (a.hasClass(e, "pswp__img") || I(e))) return void n.close()
		}, x.onMouseOver = function (t) {
			t = t || window.event;
			var e = t.target || t.srcElement;
			M(l, "ui--over-close", I(e))
		}, x.hideControls = function () {
			a.addClass(l, "pswp__ui--hidden"), k = !1
		}, x.showControls = function () {
			k = !0, w || x.update(), a.removeClass(l, "pswp__ui--hidden")
		}, x.supportsFullscreen = function () {
			var t = document;
			return !!(t.exitFullscreen || t.mozCancelFullScreen || t.webkitExitFullscreen || t.msExitFullscreen)
		}, x.getFullscreenAPI = function () {
			var t, e = document.documentElement,
				i = "fullscreenchange";
			return e.requestFullscreen ? t = {
				enterK: "requestFullscreen",
				exitK: "exitFullscreen",
				elementK: "fullscreenElement",
				eventK: i
			} : e.mozRequestFullScreen ? t = {
				enterK: "mozRequestFullScreen",
				exitK: "mozCancelFullScreen",
				elementK: "mozFullScreenElement",
				eventK: "moz" + i
			} : e.webkitRequestFullscreen ? t = {
				enterK: "webkitRequestFullscreen",
				exitK: "webkitExitFullscreen",
				elementK: "webkitFullscreenElement",
				eventK: "webkit" + i
			} : e.msRequestFullscreen && (t = {
				enterK: "msRequestFullscreen",
				exitK: "msExitFullscreen",
				elementK: "msFullscreenElement",
				eventK: "MSFullscreenChange"
			}), t && (t.enter = function () {
				return c = m.closeOnScroll, m.closeOnScroll = !1, "webkitRequestFullscreen" !== this.enterK ? n.template[this.enterK]() : void n.template[this.enterK](Element.ALLOW_KEYBOARD_INPUT)
			}, t.exit = function () {
				return m.closeOnScroll = c, document[this.exitK]()
			}, t.isFullscreen = function () {
				return document[this.elementK]
			}), t
		}
	};
	return t
});
var QRCode;
! function () {
	function i(t) {
		this.mode = o.MODE_8BIT_BYTE, this.data = t, this.parsedData = [];
		for (var e = [], i = 0, n = this.data.length; n > i; i++) {
			var s = this.data.charCodeAt(i);
			s > 65536 ? (e[0] = 240 | (1835008 & s) >>> 18, e[1] = 128 | (258048 & s) >>> 12, e[2] = 128 | (4032 & s) >>> 6, e[3] = 128 | 63 & s) : s > 2048 ? (e[0] = 224 | (61440 & s) >>> 12, e[1] = 128 | (4032 & s) >>> 6, e[2] = 128 | 63 & s) : s > 128 ? (e[0] = 192 | (1984 & s) >>> 6, e[1] = 128 | 63 & s) : e[0] = s, this.parsedData = this.parsedData.concat(e)
		}
		this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239))
	}

	function l(t, e) {
		this.typeNumber = t, this.errorCorrectLevel = e, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = []
	}

	function b(t, e) {
		if (void 0 == t.length) throw new Error(t.length + "/" + e);
		for (var i = 0; i < t.length && 0 == t[i];) i++;
		this.num = new Array(t.length - i + e);
		for (var n = 0; n < t.length - i; n++) this.num[n] = t[n + i]
	}

	function c(t, e) {
		this.totalCount = t, this.dataCount = e
	}

	function h() {
		this.buffer = [], this.length = 0
	}

	function t() {
		return "undefined" != typeof CanvasRenderingContext2D
	}

	function n() {
		var t = !1,
			e = navigator.userAgent;
		return /android/i.test(e) && (t = !0, aMat = e.toString().match(/android ([0-9]\.[0-9])/i), aMat && aMat[1] && (t = parseFloat(aMat[1]))), t
	}

	function e(t, e) {
		for (var i = 1, n = a(t), s = 0, o = f.length; o >= s; s++) {
			var r = 0;
			switch (e) {
				case u.L:
					r = f[s][0];
					break;
				case u.M:
					r = f[s][1];
					break;
				case u.Q:
					r = f[s][2];
					break;
				case u.H:
					r = f[s][3]
			}
			if (r >= n) break;
			i++
		}
		if (i > f.length) throw new Error("Too long data");
		return i
	}

	function a(t) {
		var e = encodeURI(t).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
		return e.length + (e.length != t ? 3 : 0)
	}
	i.prototype = {
		getLength: function () {
			return this.parsedData.length
		},
		write: function (t) {
			for (var e = 0, i = this.parsedData.length; i > e; e++) t.put(this.parsedData[e], 8)
		}
	}, l.prototype = {
		addData: function (t) {
			var e = new i(t);
			this.dataList.push(e), this.dataCache = null
		},
		isDark: function (t, e) {
			if (0 > t || this.moduleCount <= t || 0 > e || this.moduleCount <= e) throw new Error(t + "," + e);
			return this.modules[t][e]
		},
		getModuleCount: function () {
			return this.moduleCount
		},
		make: function () {
			this.makeImpl(!1, this.getBestMaskPattern())
		},
		makeImpl: function (t, e) {
			this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
			for (var i = 0; i < this.moduleCount; i++) {
				this.modules[i] = new Array(this.moduleCount);
				for (var n = 0; n < this.moduleCount; n++) this.modules[i][n] = null
			}
			this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(t, e), this.typeNumber >= 7 && this.setupTypeNumber(t), null == this.dataCache && (this.dataCache = l.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, e)
		},
		setupPositionProbePattern: function (t, e) {
			for (var i = -1; 7 >= i; i++)
				if (!(-1 >= t + i || this.moduleCount <= t + i))
					for (var n = -1; 7 >= n; n++) - 1 >= e + n || this.moduleCount <= e + n || (this.modules[t + i][e + n] = i >= 0 && 6 >= i && (0 == n || 6 == n) || n >= 0 && 6 >= n && (0 == i || 6 == i) || i >= 2 && 4 >= i && n >= 2 && 4 >= n ? !0 : !1)
		},
		getBestMaskPattern: function () {
			for (var t = 0, e = 0, i = 0; 8 > i; i++) {
				this.makeImpl(!0, i);
				var n = _.getLostPoint(this);
				(0 == i || t > n) && (t = n, e = i)
			}
			return e
		},
		createMovieClip: function (t, e, i) {
			var n = t.createEmptyMovieClip(e, i),
				s = 1;
			this.make();
			for (var o = 0; o < this.modules.length; o++)
				for (var r = o * s, a = 0; a < this.modules[o].length; a++) {
					var l = a * s,
						h = this.modules[o][a];
					h && (n.beginFill(0, 100), n.moveTo(l, r), n.lineTo(l + s, r), n.lineTo(l + s, r + s), n.lineTo(l, r + s), n.endFill())
				}
			return n
		},
		setupTimingPattern: function () {
			for (var t = 8; t < this.moduleCount - 8; t++) null == this.modules[t][6] && (this.modules[t][6] = 0 == t % 2);
			for (var e = 8; e < this.moduleCount - 8; e++) null == this.modules[6][e] && (this.modules[6][e] = 0 == e % 2)
		},
		setupPositionAdjustPattern: function () {
			for (var t = _.getPatternPosition(this.typeNumber), e = 0; e < t.length; e++)
				for (var i = 0; i < t.length; i++) {
					var n = t[e],
						s = t[i];
					if (null == this.modules[n][s])
						for (var o = -2; 2 >= o; o++)
							for (var r = -2; 2 >= r; r++) this.modules[n + o][s + r] = -2 == o || 2 == o || -2 == r || 2 == r || 0 == o && 0 == r ? !0 : !1
				}
		},
		setupTypeNumber: function (t) {
			for (var e = _.getBCHTypeNumber(this.typeNumber), i = 0; 18 > i; i++) {
				var n = !t && 1 == (1 & e >> i);
				this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = n
			}
			for (var i = 0; 18 > i; i++) {
				var n = !t && 1 == (1 & e >> i);
				this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = n
			}
		},
		setupTypeInfo: function (t, e) {
			for (var i = this.errorCorrectLevel << 3 | e, n = _.getBCHTypeInfo(i), s = 0; 15 > s; s++) {
				var o = !t && 1 == (1 & n >> s);
				6 > s ? this.modules[s][8] = o : 8 > s ? this.modules[s + 1][8] = o : this.modules[this.moduleCount - 15 + s][8] = o
			}
			for (var s = 0; 15 > s; s++) {
				var o = !t && 1 == (1 & n >> s);
				8 > s ? this.modules[8][this.moduleCount - s - 1] = o : 9 > s ? this.modules[8][15 - s - 1 + 1] = o : this.modules[8][15 - s - 1] = o
			}
			this.modules[this.moduleCount - 8][8] = !t
		},
		mapData: function (t, e) {
			for (var i = -1, n = this.moduleCount - 1, s = 7, o = 0, r = this.moduleCount - 1; r > 0; r -= 2)
				for (6 == r && r--; ;) {
					for (var a = 0; 2 > a; a++)
						if (null == this.modules[n][r - a]) {
							var l = !1;
							o < t.length && (l = 1 == (1 & t[o] >>> s));
							var h = _.getMask(e, n, r - a);
							h && (l = !l), this.modules[n][r - a] = l, s--, -1 == s && (o++, s = 7)
						}
					if (n += i, 0 > n || this.moduleCount <= n) {
						n -= i, i = -i;
						break
					}
				}
		}
	}, l.PAD0 = 236, l.PAD1 = 17, l.createData = function (t, e, i) {
		for (var n = c.getRSBlocks(t, e), s = new h, o = 0; o < i.length; o++) {
			var r = i[o];
			s.put(r.mode, 4), s.put(r.getLength(), _.getLengthInBits(r.mode, t)), r.write(s)
		}
		for (var a = 0, o = 0; o < n.length; o++) a += n[o].dataCount;
		if (s.getLengthInBits() > 8 * a) throw new Error("code length overflow. (" + s.getLengthInBits() + ">" + 8 * a + ")");
		for (s.getLengthInBits() + 4 <= 8 * a && s.put(0, 4); 0 != s.getLengthInBits() % 8;) s.putBit(!1);
		for (; ;) {
			if (s.getLengthInBits() >= 8 * a) break;
			if (s.put(l.PAD0, 8), s.getLengthInBits() >= 8 * a) break;
			s.put(l.PAD1, 8)
		}
		return l.createBytes(s, n)
	}, l.createBytes = function (t, e) {
		for (var i = 0, n = 0, s = 0, o = new Array(e.length), r = new Array(e.length), a = 0; a < e.length; a++) {
			var l = e[a].dataCount,
				h = e[a].totalCount - l;
			n = Math.max(n, l), s = Math.max(s, h), o[a] = new Array(l);
			for (var c = 0; c < o[a].length; c++) o[a][c] = 255 & t.buffer[c + i];
			i += l;
			var u = _.getErrorCorrectPolynomial(h),
				d = new b(o[a], u.getLength() - 1),
				f = d.mod(u);
			r[a] = new Array(u.getLength() - 1);
			for (var c = 0; c < r[a].length; c++) {
				var p = c + f.getLength() - r[a].length;
				r[a][c] = p >= 0 ? f.get(p) : 0
			}
		}
		for (var g = 0, c = 0; c < e.length; c++) g += e[c].totalCount;
		for (var m = new Array(g), v = 0, c = 0; n > c; c++)
			for (var a = 0; a < e.length; a++) c < o[a].length && (m[v++] = o[a][c]);
		for (var c = 0; s > c; c++)
			for (var a = 0; a < e.length; a++) c < r[a].length && (m[v++] = r[a][c]);
		return m
	};
	for (var o = {
		MODE_NUMBER: 1,
		MODE_ALPHA_NUM: 2,
		MODE_8BIT_BYTE: 4,
		MODE_KANJI: 8
	}, u = {
		L: 1,
		M: 0,
		Q: 3,
		H: 2
	}, s = {
		PATTERN000: 0,
		PATTERN001: 1,
		PATTERN010: 2,
		PATTERN011: 3,
		PATTERN100: 4,
		PATTERN101: 5,
		PATTERN110: 6,
		PATTERN111: 7
	}, _ = {
		PATTERN_POSITION_TABLE: [
			[],
			[6, 18],
			[6, 22],
			[6, 26],
			[6, 30],
			[6, 34],
			[6, 22, 38],
			[6, 24, 42],
			[6, 26, 46],
			[6, 28, 50],
			[6, 30, 54],
			[6, 32, 58],
			[6, 34, 62],
			[6, 26, 46, 66],
			[6, 26, 48, 70],
			[6, 26, 50, 74],
			[6, 30, 54, 78],
			[6, 30, 56, 82],
			[6, 30, 58, 86],
			[6, 34, 62, 90],
			[6, 28, 50, 72, 94],
			[6, 26, 50, 74, 98],
			[6, 30, 54, 78, 102],
			[6, 28, 54, 80, 106],
			[6, 32, 58, 84, 110],
			[6, 30, 58, 86, 114],
			[6, 34, 62, 90, 118],
			[6, 26, 50, 74, 98, 122],
			[6, 30, 54, 78, 102, 126],
			[6, 26, 52, 78, 104, 130],
			[6, 30, 56, 82, 108, 134],
			[6, 34, 60, 86, 112, 138],
			[6, 30, 58, 86, 114, 142],
			[6, 34, 62, 90, 118, 146],
			[6, 30, 54, 78, 102, 126, 150],
			[6, 24, 50, 76, 102, 128, 154],
			[6, 28, 54, 80, 106, 132, 158],
			[6, 32, 58, 84, 110, 136, 162],
			[6, 26, 54, 82, 110, 138, 166],
			[6, 30, 58, 86, 114, 142, 170]
		],
		G15: 1335,
		G18: 7973,
		G15_MASK: 21522,
		getBCHTypeInfo: function (t) {
			for (var e = t << 10; _.getBCHDigit(e) - _.getBCHDigit(_.G15) >= 0;) e ^= _.G15 << _.getBCHDigit(e) - _.getBCHDigit(_.G15);
			return (t << 10 | e) ^ _.G15_MASK
		},
		getBCHTypeNumber: function (t) {
			for (var e = t << 12; _.getBCHDigit(e) - _.getBCHDigit(_.G18) >= 0;) e ^= _.G18 << _.getBCHDigit(e) - _.getBCHDigit(_.G18);
			return t << 12 | e
		},
		getBCHDigit: function (t) {
			for (var e = 0; 0 != t;) e++, t >>>= 1;
			return e
		},
		getPatternPosition: function (t) {
			return _.PATTERN_POSITION_TABLE[t - 1]
		},
		getMask: function (t, e, i) {
			switch (t) {
				case s.PATTERN000:
					return 0 == (e + i) % 2;
				case s.PATTERN001:
					return 0 == e % 2;
				case s.PATTERN010:
					return 0 == i % 3;
				case s.PATTERN011:
					return 0 == (e + i) % 3;
				case s.PATTERN100:
					return 0 == (Math.floor(e / 2) + Math.floor(i / 3)) % 2;
				case s.PATTERN101:
					return 0 == e * i % 2 + e * i % 3;
				case s.PATTERN110:
					return 0 == (e * i % 2 + e * i % 3) % 2;
				case s.PATTERN111:
					return 0 == (e * i % 3 + (e + i) % 2) % 2;
				default:
					throw new Error("bad maskPattern:" + t)
			}
		},
		getErrorCorrectPolynomial: function (t) {
			for (var e = new b([1], 0), i = 0; t > i; i++) e = e.multiply(new b([1, r.gexp(i)], 0));
			return e
		},
		getLengthInBits: function (t, e) {
			if (e >= 1 && 10 > e) switch (t) {
				case o.MODE_NUMBER:
					return 10;
				case o.MODE_ALPHA_NUM:
					return 9;
				case o.MODE_8BIT_BYTE:
					return 8;
				case o.MODE_KANJI:
					return 8;
				default:
					throw new Error("mode:" + t)
			} else if (27 > e) switch (t) {
				case o.MODE_NUMBER:
					return 12;
				case o.MODE_ALPHA_NUM:
					return 11;
				case o.MODE_8BIT_BYTE:
					return 16;
				case o.MODE_KANJI:
					return 10;
				default:
					throw new Error("mode:" + t)
			} else {
				if (!(41 > e)) throw new Error("type:" + e);
				switch (t) {
					case o.MODE_NUMBER:
						return 14;
					case o.MODE_ALPHA_NUM:
						return 13;
					case o.MODE_8BIT_BYTE:
						return 16;
					case o.MODE_KANJI:
						return 12;
					default:
						throw new Error("mode:" + t)
				}
			}
		},
		getLostPoint: function (t) {
			for (var e = t.getModuleCount(), i = 0, n = 0; e > n; n++)
				for (var s = 0; e > s; s++) {
					for (var o = 0, r = t.isDark(n, s), a = -1; 1 >= a; a++)
						if (!(0 > n + a || n + a >= e))
							for (var l = -1; 1 >= l; l++) 0 > s + l || s + l >= e || (0 != a || 0 != l) && r == t.isDark(n + a, s + l) && o++;
					o > 5 && (i += 3 + o - 5)
				}
			for (var n = 0; e - 1 > n; n++)
				for (var s = 0; e - 1 > s; s++) {
					var h = 0;
					t.isDark(n, s) && h++, t.isDark(n + 1, s) && h++, t.isDark(n, s + 1) && h++, t.isDark(n + 1, s + 1) && h++, (0 == h || 4 == h) && (i += 3)
				}
			for (var n = 0; e > n; n++)
				for (var s = 0; e - 6 > s; s++) t.isDark(n, s) && !t.isDark(n, s + 1) && t.isDark(n, s + 2) && t.isDark(n, s + 3) && t.isDark(n, s + 4) && !t.isDark(n, s + 5) && t.isDark(n, s + 6) && (i += 40);
			for (var s = 0; e > s; s++)
				for (var n = 0; e - 6 > n; n++) t.isDark(n, s) && !t.isDark(n + 1, s) && t.isDark(n + 2, s) && t.isDark(n + 3, s) && t.isDark(n + 4, s) && !t.isDark(n + 5, s) && t.isDark(n + 6, s) && (i += 40);
			for (var c = 0, s = 0; e > s; s++)
				for (var n = 0; e > n; n++) t.isDark(n, s) && c++;
			var u = Math.abs(100 * c / e / e - 50) / 5;
			return i += 10 * u
		}
	}, r = {
		glog: function (t) {
			if (1 > t) throw new Error("glog(" + t + ")");
			return r.LOG_TABLE[t]
		},
		gexp: function (t) {
			for (; 0 > t;) t += 255;
			for (; t >= 256;) t -= 255;
			return r.EXP_TABLE[t]
		},
		EXP_TABLE: new Array(256),
		LOG_TABLE: new Array(256)
	}, d = 0; 8 > d; d++) r.EXP_TABLE[d] = 1 << d;
	for (var d = 8; 256 > d; d++) r.EXP_TABLE[d] = r.EXP_TABLE[d - 4] ^ r.EXP_TABLE[d - 5] ^ r.EXP_TABLE[d - 6] ^ r.EXP_TABLE[d - 8];
	for (var d = 0; 255 > d; d++) r.LOG_TABLE[r.EXP_TABLE[d]] = d;
	b.prototype = {
		get: function (t) {
			return this.num[t]
		},
		getLength: function () {
			return this.num.length
		},
		multiply: function (t) {
			for (var e = new Array(this.getLength() + t.getLength() - 1), i = 0; i < this.getLength(); i++)
				for (var n = 0; n < t.getLength(); n++) e[i + n] ^= r.gexp(r.glog(this.get(i)) + r.glog(t.get(n)));
			return new b(e, 0)
		},
		mod: function (t) {
			if (this.getLength() - t.getLength() < 0) return this;
			for (var e = r.glog(this.get(0)) - r.glog(t.get(0)), i = new Array(this.getLength()), n = 0; n < this.getLength(); n++) i[n] = this.get(n);
			for (var n = 0; n < t.getLength(); n++) i[n] ^= r.gexp(r.glog(t.get(n)) + e);
			return new b(i, 0).mod(t)
		}
	}, c.RS_BLOCK_TABLE = [
		[1, 26, 19],
		[1, 26, 16],
		[1, 26, 13],
		[1, 26, 9],
		[1, 44, 34],
		[1, 44, 28],
		[1, 44, 22],
		[1, 44, 16],
		[1, 70, 55],
		[1, 70, 44],
		[2, 35, 17],
		[2, 35, 13],
		[1, 100, 80],
		[2, 50, 32],
		[2, 50, 24],
		[4, 25, 9],
		[1, 134, 108],
		[2, 67, 43],
		[2, 33, 15, 2, 34, 16],
		[2, 33, 11, 2, 34, 12],
		[2, 86, 68],
		[4, 43, 27],
		[4, 43, 19],
		[4, 43, 15],
		[2, 98, 78],
		[4, 49, 31],
		[2, 32, 14, 4, 33, 15],
		[4, 39, 13, 1, 40, 14],
		[2, 121, 97],
		[2, 60, 38, 2, 61, 39],
		[4, 40, 18, 2, 41, 19],
		[4, 40, 14, 2, 41, 15],
		[2, 146, 116],
		[3, 58, 36, 2, 59, 37],
		[4, 36, 16, 4, 37, 17],
		[4, 36, 12, 4, 37, 13],
		[2, 86, 68, 2, 87, 69],
		[4, 69, 43, 1, 70, 44],
		[6, 43, 19, 2, 44, 20],
		[6, 43, 15, 2, 44, 16],
		[4, 101, 81],
		[1, 80, 50, 4, 81, 51],
		[4, 50, 22, 4, 51, 23],
		[3, 36, 12, 8, 37, 13],
		[2, 116, 92, 2, 117, 93],
		[6, 58, 36, 2, 59, 37],
		[4, 46, 20, 6, 47, 21],
		[7, 42, 14, 4, 43, 15],
		[4, 133, 107],
		[8, 59, 37, 1, 60, 38],
		[8, 44, 20, 4, 45, 21],
		[12, 33, 11, 4, 34, 12],
		[3, 145, 115, 1, 146, 116],
		[4, 64, 40, 5, 65, 41],
		[11, 36, 16, 5, 37, 17],
		[11, 36, 12, 5, 37, 13],
		[5, 109, 87, 1, 110, 88],
		[5, 65, 41, 5, 66, 42],
		[5, 54, 24, 7, 55, 25],
		[11, 36, 12],
		[5, 122, 98, 1, 123, 99],
		[7, 73, 45, 3, 74, 46],
		[15, 43, 19, 2, 44, 20],
		[3, 45, 15, 13, 46, 16],
		[1, 135, 107, 5, 136, 108],
		[10, 74, 46, 1, 75, 47],
		[1, 50, 22, 15, 51, 23],
		[2, 42, 14, 17, 43, 15],
		[5, 150, 120, 1, 151, 121],
		[9, 69, 43, 4, 70, 44],
		[17, 50, 22, 1, 51, 23],
		[2, 42, 14, 19, 43, 15],
		[3, 141, 113, 4, 142, 114],
		[3, 70, 44, 11, 71, 45],
		[17, 47, 21, 4, 48, 22],
		[9, 39, 13, 16, 40, 14],
		[3, 135, 107, 5, 136, 108],
		[3, 67, 41, 13, 68, 42],
		[15, 54, 24, 5, 55, 25],
		[15, 43, 15, 10, 44, 16],
		[4, 144, 116, 4, 145, 117],
		[17, 68, 42],
		[17, 50, 22, 6, 51, 23],
		[19, 46, 16, 6, 47, 17],
		[2, 139, 111, 7, 140, 112],
		[17, 74, 46],
		[7, 54, 24, 16, 55, 25],
		[34, 37, 13],
		[4, 151, 121, 5, 152, 122],
		[4, 75, 47, 14, 76, 48],
		[11, 54, 24, 14, 55, 25],
		[16, 45, 15, 14, 46, 16],
		[6, 147, 117, 4, 148, 118],
		[6, 73, 45, 14, 74, 46],
		[11, 54, 24, 16, 55, 25],
		[30, 46, 16, 2, 47, 17],
		[8, 132, 106, 4, 133, 107],
		[8, 75, 47, 13, 76, 48],
		[7, 54, 24, 22, 55, 25],
		[22, 45, 15, 13, 46, 16],
		[10, 142, 114, 2, 143, 115],
		[19, 74, 46, 4, 75, 47],
		[28, 50, 22, 6, 51, 23],
		[33, 46, 16, 4, 47, 17],
		[8, 152, 122, 4, 153, 123],
		[22, 73, 45, 3, 74, 46],
		[8, 53, 23, 26, 54, 24],
		[12, 45, 15, 28, 46, 16],
		[3, 147, 117, 10, 148, 118],
		[3, 73, 45, 23, 74, 46],
		[4, 54, 24, 31, 55, 25],
		[11, 45, 15, 31, 46, 16],
		[7, 146, 116, 7, 147, 117],
		[21, 73, 45, 7, 74, 46],
		[1, 53, 23, 37, 54, 24],
		[19, 45, 15, 26, 46, 16],
		[5, 145, 115, 10, 146, 116],
		[19, 75, 47, 10, 76, 48],
		[15, 54, 24, 25, 55, 25],
		[23, 45, 15, 25, 46, 16],
		[13, 145, 115, 3, 146, 116],
		[2, 74, 46, 29, 75, 47],
		[42, 54, 24, 1, 55, 25],
		[23, 45, 15, 28, 46, 16],
		[17, 145, 115],
		[10, 74, 46, 23, 75, 47],
		[10, 54, 24, 35, 55, 25],
		[19, 45, 15, 35, 46, 16],
		[17, 145, 115, 1, 146, 116],
		[14, 74, 46, 21, 75, 47],
		[29, 54, 24, 19, 55, 25],
		[11, 45, 15, 46, 46, 16],
		[13, 145, 115, 6, 146, 116],
		[14, 74, 46, 23, 75, 47],
		[44, 54, 24, 7, 55, 25],
		[59, 46, 16, 1, 47, 17],
		[12, 151, 121, 7, 152, 122],
		[12, 75, 47, 26, 76, 48],
		[39, 54, 24, 14, 55, 25],
		[22, 45, 15, 41, 46, 16],
		[6, 151, 121, 14, 152, 122],
		[6, 75, 47, 34, 76, 48],
		[46, 54, 24, 10, 55, 25],
		[2, 45, 15, 64, 46, 16],
		[17, 152, 122, 4, 153, 123],
		[29, 74, 46, 14, 75, 47],
		[49, 54, 24, 10, 55, 25],
		[24, 45, 15, 46, 46, 16],
		[4, 152, 122, 18, 153, 123],
		[13, 74, 46, 32, 75, 47],
		[48, 54, 24, 14, 55, 25],
		[42, 45, 15, 32, 46, 16],
		[20, 147, 117, 4, 148, 118],
		[40, 75, 47, 7, 76, 48],
		[43, 54, 24, 22, 55, 25],
		[10, 45, 15, 67, 46, 16],
		[19, 148, 118, 6, 149, 119],
		[18, 75, 47, 31, 76, 48],
		[34, 54, 24, 34, 55, 25],
		[20, 45, 15, 61, 46, 16]
	], c.getRSBlocks = function (t, e) {
		var i = c.getRsBlockTable(t, e);
		if (void 0 == i) throw new Error("bad rs block @ typeNumber:" + t + "/errorCorrectLevel:" + e);
		for (var n = i.length / 3, s = [], o = 0; n > o; o++)
			for (var r = i[3 * o + 0], a = i[3 * o + 1], l = i[3 * o + 2], h = 0; r > h; h++) s.push(new c(a, l));
		return s
	}, c.getRsBlockTable = function (t, e) {
		switch (e) {
			case u.L:
				return c.RS_BLOCK_TABLE[4 * (t - 1) + 0];
			case u.M:
				return c.RS_BLOCK_TABLE[4 * (t - 1) + 1];
			case u.Q:
				return c.RS_BLOCK_TABLE[4 * (t - 1) + 2];
			case u.H:
				return c.RS_BLOCK_TABLE[4 * (t - 1) + 3];
			default:
				return void 0
		}
	}, h.prototype = {
		get: function (t) {
			var e = Math.floor(t / 8);
			return 1 == (1 & this.buffer[e] >>> 7 - t % 8)
		},
		put: function (t, e) {
			for (var i = 0; e > i; i++) this.putBit(1 == (1 & t >>> e - i - 1))
		},
		getLengthInBits: function () {
			return this.length
		},
		putBit: function (t) {
			var e = Math.floor(this.length / 8);
			this.buffer.length <= e && this.buffer.push(0), t && (this.buffer[e] |= 128 >>> this.length % 8), this.length++
		}
	};
	var f = [
		[17, 14, 11, 7],
		[32, 26, 20, 14],
		[53, 42, 32, 24],
		[78, 62, 46, 34],
		[106, 84, 60, 44],
		[134, 106, 74, 58],
		[154, 122, 86, 64],
		[192, 152, 108, 84],
		[230, 180, 130, 98],
		[271, 213, 151, 119],
		[321, 251, 177, 137],
		[367, 287, 203, 155],
		[425, 331, 241, 177],
		[458, 362, 258, 194],
		[520, 412, 292, 220],
		[586, 450, 322, 250],
		[644, 504, 364, 280],
		[718, 560, 394, 310],
		[792, 624, 442, 338],
		[858, 666, 482, 382],
		[929, 711, 509, 403],
		[1003, 779, 565, 439],
		[1091, 857, 611, 461],
		[1171, 911, 661, 511],
		[1273, 997, 715, 535],
		[1367, 1059, 751, 593],
		[1465, 1125, 805, 625],
		[1528, 1190, 868, 658],
		[1628, 1264, 908, 698],
		[1732, 1370, 982, 742],
		[1840, 1452, 1030, 790],
		[1952, 1538, 1112, 842],
		[2068, 1628, 1168, 898],
		[2188, 1722, 1228, 958],
		[2303, 1809, 1283, 983],
		[2431, 1911, 1351, 1051],
		[2563, 1989, 1423, 1093],
		[2699, 2099, 1499, 1139],
		[2809, 2213, 1579, 1219],
		[2953, 2331, 1663, 1273]
	],
		p = function () {
			var t = function (t, e) {
				this._el = t, this._htOption = e
			};
			return t.prototype.draw = function (t) {
				function e(t, e) {
					var i = document.createElementNS("http://www.w3.org/2000/svg", t);
					for (var n in e) e.hasOwnProperty(n) && i.setAttribute(n, e[n]);
					return i
				}
				var i = this._htOption,
					n = this._el,
					s = t.getModuleCount();
				Math.floor(i.width / s), Math.floor(i.height / s), this.clear();
				var o = e("svg", {
					viewBox: "0 0 " + String(s) + " " + String(s),
					width: "100%",
					height: "100%",
					fill: i.colorLight
				});
				o.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), n.appendChild(o), o.appendChild(e("rect", {
					fill: i.colorDark,
					width: "1",
					height: "1",
					id: "template"
				}));
				for (var r = 0; s > r; r++)
					for (var a = 0; s > a; a++)
						if (t.isDark(r, a)) {
							var l = e("use", {
								x: String(r),
								y: String(a)
							});
							l.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#template"), o.appendChild(l)
						}
			}, t.prototype.clear = function () {
				for (; this._el.hasChildNodes();) this._el.removeChild(this._el.lastChild)
			}, t
		}(),
		g = "svg" === document.documentElement.tagName.toLowerCase(),
		m = g ? p : t() ? function () {
			function t() {
				this._elImage.src = this._elCanvas.toDataURL("image/png"), this._elImage.style.display = "block", this._elCanvas.style.display = "none"
			}

			function e(t, e) {
				var i = this;
				if (i._fFail = e, i._fSuccess = t, null === i._bSupportDataURI) {
					var n = document.createElement("img"),
						s = function () {
							i._bSupportDataURI = !1, i._fFail && _fFail.call(i)
						},
						o = function () {
							i._bSupportDataURI = !0, i._fSuccess && i._fSuccess.call(i)
						};
					return n.onabort = s, n.onerror = s, n.onload = o, n.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==", void 0
				}
				i._bSupportDataURI === !0 && i._fSuccess ? i._fSuccess.call(i) : i._bSupportDataURI === !1 && i._fFail && i._fFail.call(i)
			}
			if (this._android && this._android <= 2.1) {
				var h = 1 / window.devicePixelRatio,
					c = CanvasRenderingContext2D.prototype.drawImage;
				CanvasRenderingContext2D.prototype.drawImage = function (t, e, i, n, s, o, r, a) {
					if ("nodeName" in t && /img/i.test(t.nodeName))
						for (var l = arguments.length - 1; l >= 1; l--) arguments[l] = arguments[l] * h;
					else "undefined" == typeof a && (arguments[1] *= h, arguments[2] *= h, arguments[3] *= h, arguments[4] *= h);
					c.apply(this, arguments)
				}
			}
			var i = function (t, e) {
				this._bIsPainted = !1, this._android = n(), this._htOption = e, this._elCanvas = document.createElement("canvas"), this._elCanvas.width = e.width, this._elCanvas.height = e.height, t.appendChild(this._elCanvas), this._el = t, this._oContext = this._elCanvas.getContext("2d"), this._bIsPainted = !1, this._elImage = document.createElement("img"), this._elImage.style.display = "none", this._el.appendChild(this._elImage), this._bSupportDataURI = null
			};
			return i.prototype.draw = function (t) {
				var e = this._elImage,
					i = this._oContext,
					n = this._htOption,
					s = t.getModuleCount(),
					o = n.width / s,
					r = n.height / s,
					a = Math.round(o),
					l = Math.round(r);
				e.style.display = "none", this.clear();
				for (var h = 0; s > h; h++)
					for (var c = 0; s > c; c++) {
						var u = t.isDark(h, c),
							d = c * o,
							f = h * r;
						i.strokeStyle = u ? n.colorDark : n.colorLight, i.lineWidth = 1, i.fillStyle = u ? n.colorDark : n.colorLight, i.fillRect(d, f, o, r), i.strokeRect(Math.floor(d) + .5, Math.floor(f) + .5, a, l), i.strokeRect(Math.ceil(d) - .5, Math.ceil(f) - .5, a, l)
					}
				this._bIsPainted = !0
			}, i.prototype.makeImage = function () {
				this._bIsPainted && e.call(this, t)
			}, i.prototype.isPainted = function () {
				return this._bIsPainted
			}, i.prototype.clear = function () {
				this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height), this._bIsPainted = !1
			}, i.prototype.round = function (t) {
				return t ? Math.floor(1e3 * t) / 1e3 : t
			}, i
		}() : function () {
			var t = function (t, e) {
				this._el = t, this._htOption = e
			};
			return t.prototype.draw = function (t) {
				for (var e = this._htOption, i = this._el, n = t.getModuleCount(), s = Math.floor(e.width / n), o = Math.floor(e.height / n), r = ['<table style="border:0;border-collapse:collapse;">'], a = 0; n > a; a++) {
					r.push("<tr>");
					for (var l = 0; n > l; l++) r.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + s + "px;height:" + o + "px;background-color:" + (t.isDark(a, l) ? e.colorDark : e.colorLight) + ';"></td>');
					r.push("</tr>")
				}
				r.push("</table>"), i.innerHTML = r.join("");
				var h = i.childNodes[0],
					c = (e.width - h.offsetWidth) / 2,
					u = (e.height - h.offsetHeight) / 2;
				c > 0 && u > 0 && (h.style.margin = u + "px " + c + "px")
			}, t.prototype.clear = function () {
				this._el.innerHTML = ""
			}, t
		}();
	QRCode = function (t, e) {
		if (this._htOption = {
			width: 256,
			height: 256,
			typeNumber: 4,
			colorDark: "#000000",
			colorLight: "#ffffff",
			correctLevel: u.H
		}, "string" == typeof e && (e = {
			text: e
		}), e)
			for (var i in e) this._htOption[i] = e[i];
		"string" == typeof t && (t = document.getElementById(t)), this._android = n(), this._el = t, this._oQRCode = null, this._oDrawing = new m(this._el, this._htOption), this._htOption.text && this.makeCode(this._htOption.text)
	}, QRCode.prototype.makeCode = function (t) {
		this._oQRCode = new l(e(t, this._htOption.correctLevel), this._htOption.correctLevel), this._oQRCode.addData(t), this._oQRCode.make(), this._el.title = t, this._oDrawing.draw(this._oQRCode), this.makeImage()
	}, QRCode.prototype.makeImage = function () {
		"function" == typeof this._oDrawing.makeImage && (!this._android || this._android >= 3) && this._oDrawing.makeImage()
	}, QRCode.prototype.clear = function () {
		this._oDrawing.clear()
	}, QRCode.CorrectLevel = u
}();
"use strict";

function _typeof(t) {
	return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
		return typeof t
	} : function (t) {
		return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
	})(t)
} ! function (t, e) {
	"object" === ("undefined" == typeof exports ? "undefined" : _typeof(exports)) ? module.exports = e(t) : "function" == typeof define && define.amd ? define([], e) : t.LazyLoad = e(t)
}("undefined" != typeof global ? global : window, function (e) {
	"function" == typeof define && define.amd && (e = window);
	var i = {
		src: "data-original",
		srcset: "data-srcset",
		selector: ".lazyload",
		root: null,
		rootMargin: "0px",
		threshold: 0
	},
		n = function i() {
			var n = {},
				s = !1,
				t = 0,
				e = arguments.length;
			"[object Boolean]" === Object.prototype.toString.call(arguments[0]) && (s = arguments[0], t++);
			for (var o = function (t) {
				for (var e in t) Object.prototype.hasOwnProperty.call(t, e) && (s && "[object Object]" === Object.prototype.toString.call(t[e]) ? n[e] = i(!0, n[e], t[e]) : n[e] = t[e])
			}; t < e; t++) {
				o(arguments[t])
			}
			return n
		};

	function s(t, e) {
		this.settings = n(i, e || {}), this.images = t || document.querySelectorAll(this.settings.selector), this.observer = null, this.init()
	}
	if (s.prototype = {
		init: function () {
			if (e.IntersectionObserver) {
				var n = this,
					t = {
						root: this.settings.root,
						rootMargin: this.settings.rootMargin,
						threshold: [this.settings.threshold]
					};
				this.observer = new IntersectionObserver(function (t) {
					Array.prototype.forEach.call(t, function (t) {
						if (t.isIntersecting) {
							n.observer.unobserve(t.target);
							var e = t.target.getAttribute(n.settings.src),
								i = t.target.getAttribute(n.settings.srcset);
							"img" === t.target.tagName.toLowerCase() ? (e && (t.target.src = e), i && (t.target.srcset = i)) : t.target.style.backgroundImage = "url(" + e + ")"
						}
					})
				}, t), Array.prototype.forEach.call(this.images, function (t) {
					n.observer.observe(t)
				})
			} else this.loadImages()
		},
		loadAndDestroy: function () {
			this.settings && (this.loadImages(), this.destroy())
		},
		loadImages: function () {
			if (this.settings) {
				var n = this;
				Array.prototype.forEach.call(this.images, function (t) {
					var e = t.getAttribute(n.settings.src),
						i = t.getAttribute(n.settings.srcset);
					"img" === t.tagName.toLowerCase() ? (e && (t.src = e), i && (t.srcset = i)) : t.style.backgroundImage = "url('" + e + "')"
				})
			}
		},
		destroy: function () {
			this.settings && (this.observer.disconnect(), this.settings = null)
		}
	}, e.lazyload = function (t, e) {
		return new s(t, e)
	}, e.jQuery) {
		var o = e.jQuery;
		o.fn.lazyload = function (t) {
			return (t = t || {}).attribute = t.attribute || "data-original", new s(o.makeArray(this), t), this
		}
	}
	return s
});
! function (t, e) {
	"object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e()
}(this, function () {
	"use strict";
	var n = Object.freeze({
		__proto__: null,
		get Colors() {
			return Zo
		},
		get Decimation() {
			return tr
		},
		get Filler() {
			return vr
		},
		get Legend() {
			return xr
		},
		get SubTitle() {
			return Dr
		},
		get Title() {
			return kr
		},
		get Tooltip() {
			return Hr
		}
	});

	function t() { }
	const H = (() => {
		let t = 0;
		return () => t++
	})();

	function T(t) {
		return null == t
	}

	function I(t) {
		if (Array.isArray && Array.isArray(t)) return !0;
		const e = Object.prototype.toString.call(t);
		return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6)
	}

	function E(t) {
		return null !== t && "[object Object]" === Object.prototype.toString.call(t)
	}

	function p(t) {
		return ("number" == typeof t || t instanceof Number) && isFinite(+t)
	}

	function g(t, e) {
		return p(t) ? t : e
	}

	function O(t, e) {
		return void 0 === t ? e : t
	}
	const z = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : +t / e,
		W = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;

	function f(t, e, i) {
		if (t && "function" == typeof t.call) return t.apply(i, e)
	}

	function C(t, e, i, n) {
		let s, o, r;
		if (I(t))
			if (o = t.length, n)
				for (s = o - 1; s >= 0; s--) e.call(i, t[s], s);
			else
				for (s = 0; s < o; s++) e.call(i, t[s], s);
		else if (E(t))
			for (r = Object.keys(t), o = r.length, s = 0; s < o; s++) e.call(i, t[r[s]], r[s])
	}

	function B(t, e) {
		let i, n, s, o;
		if (!t || !e || t.length !== e.length) return !1;
		for (i = 0, n = t.length; i < n; ++i)
			if (s = t[i], o = e[i], s.datasetIndex !== o.datasetIndex || s.index !== o.index) return !1;
		return !0
	}

	function j(s) {
		if (I(s)) return s.map(j);
		if (E(s)) {
			const t = Object.create(null),
				e = Object.keys(s),
				i = e.length;
			let n = 0;
			for (; n < i; ++n) t[e[n]] = j(s[e[n]]);
			return t
		}
		return s
	}

	function Y(t) {
		return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
	}

	function V(t, e, i, n) {
		if (!Y(t)) return;
		const s = e[t],
			o = i[t];
		E(s) && E(o) ? $(s, o, n) : e[t] = j(o)
	}

	function $(i, t, n) {
		const e = I(t) ? t : [t],
			s = e.length;
		if (!E(i)) return i;
		const o = (n = n || {}).merger || V;
		let r;
		for (let t = 0; t < s; ++t) {
			if (r = e[t], !E(r)) continue;
			const I = Object.keys(r);
			for (let t = 0, e = I.length; t < e; ++t) o(I[t], i, r, n)
		}
		return i
	}

	function U(t, e) {
		return $(t, e, {
			merger: o
		})
	}

	function o(t, e, i) {
		if (!Y(t)) return;
		const n = e[t],
			s = i[t];
		E(n) && E(s) ? U(n, s) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = j(s))
	}
	const q = {
		"": t => t,
		x: t => t.x,
		y: t => t.y
	};

	function G(t) {
		const e = t.split("."),
			i = [];
		let n = "";
		for (const t of e) n += t, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (i.push(n), n = "");
		return i
	}

	function m(t, e) {
		const i = q[e] || (q[e] = function (t) {
			const i = G(t);
			return e => {
				for (const t of i) {
					if ("" === t) break;
					e = e && e[t]
				}
				return e
			}
		}(e));
		return i(t)
	}

	function K(t) {
		return t.charAt(0).toUpperCase() + t.slice(1)
	}
	const X = t => void 0 !== t,
		l = t => "function" == typeof t,
		Z = (e, i) => {
			if (e.size !== i.size) return !1;
			for (const t of e)
				if (!i.has(t)) return !1;
			return !0
		};

	function Q(t) {
		return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type
	}
	const A = Math.PI,
		y = 2 * A,
		J = y + A,
		tt = Number.POSITIVE_INFINITY,
		et = A / 180,
		L = A / 2,
		it = A / 4,
		nt = 2 * A / 3,
		h = Math.log10,
		v = Math.sign;

	function st(t, e, i) {
		return Math.abs(t - e) < i
	}

	function ot(t) {
		const e = Math.round(t);
		t = st(t, e, t / 1e3) ? e : t;
		const i = Math.pow(10, Math.floor(h(t))),
			n = t / i;
		return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * i
	}

	function rt(t) {
		const e = [],
			i = Math.sqrt(t);
		let n;
		for (n = 1; n < i; n++) t % n == 0 && (e.push(n), e.push(t / n));
		return i === (0 | i) && e.push(i), e.sort((t, e) => t - e).pop(), e
	}

	function at(t) {
		return !isNaN(parseFloat(t)) && isFinite(t)
	}

	function lt(t, e) {
		const i = Math.round(t);
		return i - e <= t && i + e >= t
	}

	function ht(t, e, i) {
		let n, s, o;
		for (n = 0, s = t.length; n < s; n++) o = t[n][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o))
	}

	function N(t) {
		return t * (A / 180)
	}

	function ct(t) {
		return t * (180 / A)
	}

	function ut(t) {
		if (!p(t)) return;
		let e = 1,
			i = 0;
		for (; Math.round(t * e) / e !== t;) e *= 10, i++;
		return i
	}

	function dt(t, e) {
		const i = e.x - t.x,
			n = e.y - t.y,
			s = Math.sqrt(i * i + n * n);
		let o = Math.atan2(n, i);
		return o < -.5 * A && (o += y), {
			angle: o,
			distance: s
		}
	}

	function ft(t, e) {
		return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
	}

	function pt(t, e) {
		return (t - e + J) % y - A
	}

	function b(t) {
		return (t % y + y) % y
	}

	function gt(t, e, i, n) {
		const s = b(t),
			o = b(e),
			r = b(i),
			a = b(o - s),
			l = b(r - s),
			h = b(s - o),
			c = b(s - r);
		return s === o || s === r || n && o === r || a > l && h < c
	}

	function _(t, e, i) {
		return Math.max(e, Math.min(i, t))
	}

	function mt(t) {
		return _(t, -32768, 32767)
	}

	function x(t, e, i, n = 1e-6) {
		return t >= Math.min(e, i) - n && t <= Math.max(e, i) + n
	}

	function vt(e, i, t) {
		t = t || (t => e[t] < i);
		let n, s = e.length - 1,
			o = 0;
		for (; s - o > 1;) n = o + s >> 1, t(n) ? o = n : s = n;
		return {
			lo: o,
			hi: s
		}
	}
	const w = (i, n, s, t) => vt(i, s, t ? t => {
		const e = i[t][n];
		return e < s || e === s && i[t + 1][n] === s
	} : t => i[t][n] < s),
		bt = (e, i, n) => vt(e, n, t => e[t][i] >= n);

	function _t(t, e, i) {
		let n = 0,
			s = t.length;
		for (; n < s && t[n] < e;) n++;
		for (; s > n && t[s - 1] > i;) s--;
		return n > 0 || s < t.length ? t.slice(n, s) : t
	}
	const yt = ["push", "pop", "shift", "splice", "unshift"];

	function xt(s, t) {
		s._chartjs ? s._chartjs.listeners.push(t) : (Object.defineProperty(s, "_chartjs", {
			configurable: !0,
			enumerable: !1,
			value: {
				listeners: [t]
			}
		}), yt.forEach(t => {
			const i = "_onData" + K(t),
				n = s[t];
			Object.defineProperty(s, t, {
				configurable: !0,
				enumerable: !1,
				value(...e) {
					const t = n.apply(this, e);
					return s._chartjs.listeners.forEach(t => {
						"function" == typeof t[i] && t[i](...e)
					}), t
				}
			})
		}))
	}

	function wt(e, t) {
		const i = e._chartjs;
		if (!i) return;
		const n = i.listeners,
			s = n.indexOf(t); - 1 !== s && n.splice(s, 1), n.length > 0 || (yt.forEach(t => {
				delete e[t]
			}), delete e._chartjs)
	}

	function kt(t) {
		const e = new Set(t);
		return e.size === t.length ? t : Array.from(e)
	}
	const Ct = "undefined" == typeof window ? function (t) {
		return t()
	} : window.requestAnimationFrame;

	function Dt(e, i) {
		let n = [],
			s = !1;
		return function (...t) {
			n = t, s || (s = !0, Ct.call(window, () => {
				s = !1, e.apply(i, n)
			}))
		}
	}

	function Mt(e, i) {
		let n;
		return function (...t) {
			return i ? (clearTimeout(n), n = setTimeout(e, i, t)) : e.apply(this, t), i
		}
	}
	const Tt = t => "start" === t ? "left" : "end" === t ? "right" : "center",
		M = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2,
		St = (t, e, i, n) => t === (n ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e;

	function Pt(a, l, h) {
		const c = l.length;
		let u = 0,
			d = c;
		if (a._sorted) {
			const {
				iScale: t,
				_parsed: e
			} = a, i = t.axis, {
				min: n,
				max: s,
				minDefined: o,
				maxDefined: r
			} = t.getUserBounds();
			o && (u = _(Math.min(w(e, t.axis, n).lo, h ? c : w(l, i, t.getPixelForValue(n)).lo), 0, c - 1)), d = r ? _(Math.max(w(e, t.axis, s, !0).hi + 1, h ? 0 : w(l, i, t.getPixelForValue(s), !0).hi + 1), u, c) - u : c - u
		}
		return {
			start: u,
			count: d
		}
	}

	function It(t) {
		const {
			xScale: e,
			yScale: i,
			_scaleRanges: n
		} = t, s = {
			xmin: e.min,
			xmax: e.max,
			ymin: i.min,
			ymax: i.max
		};
		if (!n) return t._scaleRanges = s, !0;
		const o = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== i.min || n.ymax !== i.max;
		return Object.assign(n, s), o
	}
	class Et {
		constructor() {
			this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
		}
		_notify(e, i, n, t) {
			const s = i.listeners[t],
				o = i.duration;
			s.forEach(t => t({
				chart: e,
				initial: i.initial,
				numSteps: o,
				currentStep: Math.min(n - i.start, o)
			}))
		}
		_refresh() {
			this._request || (this._running = !0, this._request = Ct.call(window, () => {
				this._update(), this._request = null, this._running && this._refresh()
			}))
		}
		_update(r = Date.now()) {
			let a = 0;
			this._charts.forEach((t, e) => {
				if (!t.running || !t.items.length) return;
				const i = t.items;
				let n, s = i.length - 1,
					o = !1;
				for (; s >= 0; --s) n = i[s], n._active ? (n._total > t.duration && (t.duration = n._total), n.tick(r), o = !0) : (i[s] = i[i.length - 1], i.pop());
				o && (e.draw(), this._notify(e, t, r, "progress")), i.length || (t.running = !1, this._notify(e, t, r, "complete"), t.initial = !1), a += i.length
			}), this._lastDate = r, 0 === a && (this._running = !1)
		}
		_getAnims(t) {
			const e = this._charts;
			let i = e.get(t);
			return i || (i = {
				running: !1,
				initial: !0,
				items: [],
				listeners: {
					complete: [],
					progress: []
				}
			}, e.set(t, i)), i
		}
		listen(t, e, i) {
			this._getAnims(t).listeners[e].push(i)
		}
		add(t, e) {
			e && e.length && this._getAnims(t).items.push(...e)
		}
		has(t) {
			return this._getAnims(t).items.length > 0
		}
		start(t) {
			const e = this._charts.get(t);
			e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e) => Math.max(t, e._duration), 0), this._refresh())
		}
		running(t) {
			if (!this._running) return !1;
			const e = this._charts.get(t);
			return !!(e && e.running && e.items.length)
		}
		stop(t) {
			const e = this._charts.get(t);
			if (!e || !e.items.length) return;
			const i = e.items;
			let n = i.length - 1;
			for (; n >= 0; --n) i[n].cancel();
			e.items = [], this._notify(t, e, Date.now(), "complete")
		}
		remove(t) {
			return this._charts.delete(t)
		}
	}
	var c = new Et;

	function Ot(t) {
		return t + .5 | 0
	}
	const At = (t, e, i) => Math.max(Math.min(t, i), e);

	function Lt(t) {
		return At(Ot(2.55 * t), 0, 255)
	}

	function Nt(t) {
		return At(Ot(255 * t), 0, 255)
	}

	function r(t) {
		return At(Ot(t / 2.55) / 100, 0, 1)
	}

	function Rt(t) {
		return At(Ot(100 * t), 0, 100)
	}
	const a = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	},
		Ft = [...
			"0123456789ABCDEF"
		],
		Ht = t => Ft[15 & t],
		zt = t => Ft[(240 & t) >> 4] + Ft[15 & t],
		Wt = t => (240 & t) >> 4 == (15 & t);

	function Bt(t) {
		var e = (t => Wt(t.r) && Wt(t.g) && Wt(t.b) && Wt(t.a))(t) ? Ht : zt;
		return t ? "#" + e(t.r) + e(t.g) + e(t.b) + ((t, e) => t < 255 ? e(t) : "")(t.a, e) : void 0
	}
	const jt = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

	function Yt(i, t, n) {
		const s = t * Math.min(n, 1 - n),
			e = (t, e = (t + i / 30) % 12) => n - s * Math.max(Math.min(e - 3, 9 - e, 1), -1);
		return [e(0), e(8), e(4)]
	}

	function Vt(i, n, s) {
		const t = (t, e = (t + i / 60) % 6) => s - s * n * Math.max(Math.min(e, 4 - e, 1), 0);
		return [t(5), t(3), t(1)]
	}

	function $t(t, e, i) {
		const n = Yt(t, 1, .5);
		let s;
		for (e + i > 1 && (s = 1 / (e + i), e *= s, i *= s), s = 0; s < 3; s++) n[s] *= 1 - e - i, n[s] += e;
		return n
	}

	function Ut(t) {
		const e = t.r / 255,
			i = t.g / 255,
			n = t.b / 255,
			s = Math.max(e, i, n),
			o = Math.min(e, i, n),
			r = (s + o) / 2;
		let a, l, h;
		return s !== o && (h = s - o, l = r > .5 ? h / (2 - s - o) : h / (s + o), a = function (t, e, i, n, s) {
			return t === s ? (e - i) / n + (e < i ? 6 : 0) : e === s ? (i - t) / n + 2 : (t - e) / n + 4
		}(e, i, n, h, s), a = 60 * a + .5), [0 | a, l || 0, r]
	}

	function qt(t, e, i, n) {
		return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, n)).map(Nt)
	}

	function Gt(t, e, i) {
		return qt(Yt, t, e, i)
	}

	function Kt(t) {
		return (t % 360 + 360) % 360
	}

	function Xt(t) {
		const e = jt.exec(t);
		let i, n = 255;
		if (!e) return;
		e[5] !== i && (n = e[6] ? Lt(+e[5]) : Nt(+e[5]));
		const s = Kt(+e[2]),
			o = +e[3] / 100,
			r = +e[4] / 100;
		return i = "hwb" === e[1] ? function (t, e, i) {
			return qt($t, t, e, i)
		}(s, o, r) : "hsv" === e[1] ? function (t, e, i) {
			return qt(Vt, t, e, i)
		}(s, o, r) : Gt(s, o, r), {
			r: i[0],
			g: i[1],
			b: i[2],
			a: n
		}
	}
	const Zt = {
		x: "dark",
		Z: "light",
		Y: "re",
		X: "blu",
		W: "gr",
		V: "medium",
		U: "slate",
		A: "ee",
		T: "ol",
		S: "or",
		B: "ra",
		C: "lateg",
		D: "ights",
		R: "in",
		Q: "turquois",
		E: "hi",
		P: "ro",
		O: "al",
		N: "le",
		M: "de",
		L: "yello",
		F: "en",
		K: "ch",
		G: "arks",
		H: "ea",
		I: "ightg",
		J: "wh"
	},
		Qt = {
			OiceXe: "f0f8ff",
			antiquewEte: "faebd7",
			aqua: "ffff",
			aquamarRe: "7fffd4",
			azuY: "f0ffff",
			beige: "f5f5dc",
			bisque: "ffe4c4",
			black: "0",
			blanKedOmond: "ffebcd",
			Xe: "ff",
			XeviTet: "8a2be2",
			bPwn: "a52a2a",
			burlywood: "deb887",
			caMtXe: "5f9ea0",
			KartYuse: "7fff00",
			KocTate: "d2691e",
			cSO: "ff7f50",
			cSnflowerXe: "6495ed",
			cSnsilk: "fff8dc",
			crimson: "dc143c",
			cyan: "ffff",
			xXe: "8b",
			xcyan: "8b8b",
			xgTMnPd: "b8860b",
			xWay: "a9a9a9",
			xgYF: "6400",
			xgYy: "a9a9a9",
			xkhaki: "bdb76b",
			xmagFta: "8b008b",
			xTivegYF: "556b2f",
			xSange: "ff8c00",
			xScEd: "9932cc",
			xYd: "8b0000",
			xsOmon: "e9967a",
			xsHgYF: "8fbc8f",
			xUXe: "483d8b",
			xUWay: "2f4f4f",
			xUgYy: "2f4f4f",
			xQe: "ced1",
			xviTet: "9400d3",
			dAppRk: "ff1493",
			dApskyXe: "bfff",
			dimWay: "696969",
			dimgYy: "696969",
			dodgerXe: "1e90ff",
			fiYbrick: "b22222",
			flSOwEte: "fffaf0",
			foYstWAn: "228b22",
			fuKsia: "ff00ff",
			gaRsbSo: "dcdcdc",
			ghostwEte: "f8f8ff",
			gTd: "ffd700",
			gTMnPd: "daa520",
			Way: "808080",
			gYF: "8000",
			gYFLw: "adff2f",
			gYy: "808080",
			honeyMw: "f0fff0",
			hotpRk: "ff69b4",
			RdianYd: "cd5c5c",
			Rdigo: "4b0082",
			ivSy: "fffff0",
			khaki: "f0e68c",
			lavFMr: "e6e6fa",
			lavFMrXsh: "fff0f5",
			lawngYF: "7cfc00",
			NmoncEffon: "fffacd",
			ZXe: "add8e6",
			ZcSO: "f08080",
			Zcyan: "e0ffff",
			ZgTMnPdLw: "fafad2",
			ZWay: "d3d3d3",
			ZgYF: "90ee90",
			ZgYy: "d3d3d3",
			ZpRk: "ffb6c1",
			ZsOmon: "ffa07a",
			ZsHgYF: "20b2aa",
			ZskyXe: "87cefa",
			ZUWay: "778899",
			ZUgYy: "778899",
			ZstAlXe: "b0c4de",
			ZLw: "ffffe0",
			lime: "ff00",
			limegYF: "32cd32",
			lRF: "faf0e6",
			magFta: "ff00ff",
			maPon: "800000",
			VaquamarRe: "66cdaa",
			VXe: "cd",
			VScEd: "ba55d3",
			VpurpN: "9370db",
			VsHgYF: "3cb371",
			VUXe: "7b68ee",
			VsprRggYF: "fa9a",
			VQe: "48d1cc",
			VviTetYd: "c71585",
			midnightXe: "191970",
			mRtcYam: "f5fffa",
			mistyPse: "ffe4e1",
			moccasR: "ffe4b5",
			navajowEte: "ffdead",
			navy: "80",
			Tdlace: "fdf5e6",
			Tive: "808000",
			TivedBb: "6b8e23",
			Sange: "ffa500",
			SangeYd: "ff4500",
			ScEd: "da70d6",
			pOegTMnPd: "eee8aa",
			pOegYF: "98fb98",
			pOeQe: "afeeee",
			pOeviTetYd: "db7093",
			papayawEp: "ffefd5",
			pHKpuff: "ffdab9",
			peru: "cd853f",
			pRk: "ffc0cb",
			plum: "dda0dd",
			powMrXe: "b0e0e6",
			purpN: "800080",
			YbeccapurpN: "663399",
			Yd: "ff0000",
			Psybrown: "bc8f8f",
			PyOXe: "4169e1",
			saddNbPwn: "8b4513",
			sOmon: "fa8072",
			sandybPwn: "f4a460",
			sHgYF: "2e8b57",
			sHshell: "fff5ee",
			siFna: "a0522d",
			silver: "c0c0c0",
			skyXe: "87ceeb",
			UXe: "6a5acd",
			UWay: "708090",
			UgYy: "708090",
			snow: "fffafa",
			sprRggYF: "ff7f",
			stAlXe: "4682b4",
			tan: "d2b48c",
			teO: "8080",
			tEstN: "d8bfd8",
			tomato: "ff6347",
			Qe: "40e0d0",
			viTet: "ee82ee",
			JHt: "f5deb3",
			wEte: "ffffff",
			wEtesmoke: "f5f5f5",
			Lw: "ffff00",
			LwgYF: "9acd32"
		};
	let Jt;

	function te(t) {
		Jt || (Jt = function () {
			const t = {},
				e = Object.keys(Qt),
				i = Object.keys(Zt);
			let n, s, o, r, a;
			for (n = 0; n < e.length; n++) {
				for (r = a = e[n], s = 0; s < i.length; s++) o = i[s], a = a.replace(o, Zt[o]);
				o = parseInt(Qt[r], 16), t[a] = [o >> 16 & 255, o >> 8 & 255, 255 & o]
			}
			return t
		}(), Jt.transparent = [0, 0, 0, 0]);
		const e = Jt[t.toLowerCase()];
		return e && {
			r: e[0],
			g: e[1],
			b: e[2],
			a: 4 === e.length ? e[3] : 255
		}
	}
	const ee = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
	const ie = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055,
		ne = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);

	function se(e, i, n) {
		if (e) {
			let t = Ut(e);
			t[i] = Math.max(0, Math.min(t[i] + t[i] * n, 0 === i ? 360 : 1)), t = Gt(t), e.r = t[0], e.g = t[1], e.b = t[2]
		}
	}

	function oe(t, e) {
		return t ? Object.assign(e || {}, t) : t
	}

	function re(t) {
		var e = {
			r: 0,
			g: 0,
			b: 0,
			a: 255
		};
		return Array.isArray(t) ? t.length >= 3 && (e = {
			r: t[0],
			g: t[1],
			b: t[2],
			a: 255
		}, t.length > 3 && (e.a = Nt(t[3]))) : (e = oe(t, {
			r: 0,
			g: 0,
			b: 0,
			a: 1
		})).a = Nt(e.a), e
	}

	function ae(t) {
		return "r" === t.charAt(0) ? function (t) {
			const e = ee.exec(t);
			let i, n, s, o = 255;
			if (e) {
				if (e[7] !== i) {
					const t = +e[7];
					o = e[8] ? Lt(t) : At(255 * t, 0, 255)
				}
				return i = +e[1], n = +e[3], s = +e[5], i = 255 & (e[2] ? Lt(i) : At(i, 0, 255)), n = 255 & (e[4] ? Lt(n) : At(n, 0, 255)), s = 255 & (e[6] ? Lt(s) : At(s, 0, 255)), {
					r: i,
					g: n,
					b: s,
					a: o
				}
			}
		}(t) : Xt(t)
	}
	class le {
		constructor(t) {
			if (t instanceof le) return t;
			const e = typeof t;
			let i;
			var n, s, o;
			"object" === e ? i = re(t) : "string" === e && (o = (n = t).length, "#" === n[0] && (4 === o || 5 === o ? s = {
				r: 255 & 17 * a[n[1]],
				g: 255 & 17 * a[n[2]],
				b: 255 & 17 * a[n[3]],
				a: 5 === o ? 17 * a[n[4]] : 255
			} : 7 !== o && 9 !== o || (s = {
				r: a[n[1]] << 4 | a[n[2]],
				g: a[n[3]] << 4 | a[n[4]],
				b: a[n[5]] << 4 | a[n[6]],
				a: 9 === o ? a[n[7]] << 4 | a[n[8]] : 255
			})), i = s || te(t) || ae(t)), this._rgb = i, this._valid = !!i
		}
		get valid() {
			return this._valid
		}
		get rgb() {
			var t = oe(this._rgb);
			return t && (t.a = r(t.a)), t
		}
		set rgb(t) {
			this._rgb = re(t)
		}
		rgbString() {
			return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r},${t.g},${t.b},${r(t.a)})` : `rgb(${t.r},${t.g},${t.b})`) : void 0;
			var t
		}
		hexString() {
			return this._valid ? Bt(this._rgb) : void 0
		}
		hslString() {
			return this._valid ? function (t) {
				if (!t) return;
				const e = Ut(t),
					i = e[0],
					n = Rt(e[1]),
					s = Rt(e[2]);
				return t.a < 255 ? `hsla(${i},${n}%,${s}%,${r(t.a)})` : `hsl(${i},${n}%,${s}%)`
			}(this._rgb) : void 0
		}
		mix(a, l) {
			if (a) {
				const t = this.rgb,
					e = a.rgb;
				let i;
				const n = l === i ? .5 : l,
					s = 2 * n - 1,
					o = t.a - e.a,
					r = ((s * o == -1 ? s : (s + o) / (1 + s * o)) + 1) / 2;
				i = 1 - r, t.r = 255 & r * t.r + i * e.r + .5, t.g = 255 & r * t.g + i * e.g + .5, t.b = 255 & r * t.b + i * e.b + .5, t.a = n * t.a + (1 - n) * e.a, this.rgb = t
			}
			return this
		}
		interpolate(t, e) {
			return t && (this._rgb = function (t, e, i) {
				const n = ne(r(t.r)),
					s = ne(r(t.g)),
					o = ne(r(t.b));
				return {
					r: Nt(ie(n + i * (ne(r(e.r)) - n))),
					g: Nt(ie(s + i * (ne(r(e.g)) - s))),
					b: Nt(ie(o + i * (ne(r(e.b)) - o))),
					a: t.a + i * (e.a - t.a)
				}
			}(this._rgb, t._rgb, e)), this
		}
		clone() {
			return new le(this.rgb)
		}
		alpha(t) {
			return this._rgb.a = Nt(t), this
		}
		clearer(t) {
			return this._rgb.a *= 1 - t, this
		}
		greyscale() {
			const t = this._rgb,
				e = Ot(.3 * t.r + .59 * t.g + .11 * t.b);
			return t.r = t.g = t.b = e, this
		}
		opaquer(t) {
			return this._rgb.a *= 1 + t, this
		}
		negate() {
			const t = this._rgb;
			return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this
		}
		lighten(t) {
			return se(this._rgb, 2, t), this
		}
		darken(t) {
			return se(this._rgb, 2, -t), this
		}
		saturate(t) {
			return se(this._rgb, 1, t), this
		}
		desaturate(t) {
			return se(this._rgb, 1, -t), this
		}
		rotate(t) {
			return function (t, e) {
				var i = Ut(t);
				i[0] = Kt(i[0] + e), i = Gt(i), t.r = i[0], t.g = i[1], t.b = i[2]
			}(this._rgb, t), this
		}
	}

	function he(e) {
		if (e && "object" == typeof e) {
			const t = e.toString();
			return "[object CanvasPattern]" === t || "[object CanvasGradient]" === t
		}
		return !1
	}

	function ce(t) {
		return he(t) ? t : new le(t)
	}

	function ue(t) {
		return he(t) ? t : new le(t).saturate(.5).darken(.1).hexString()
	}
	const de = ["x", "y", "borderWidth", "radius", "tension"],
		fe = ["color", "borderColor", "backgroundColor"];
	const pe = new Map;

	function ge(t, e, i) {
		return function (t, e) {
			e = e || {};
			const i = t + JSON.stringify(e);
			let n = pe.get(i);
			return n || (n = new Intl.NumberFormat(t, e), pe.set(i, n)), n
		}(e, i).format(t)
	}
	const me = {
		values: t => I(t) ? t : "" + t,
		numeric(t, e, i) {
			if (0 === t) return "0";
			const n = this.chart.options.locale;
			let s, o = t;
			if (i.length > 1) {
				const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
				(e < 1e-4 || e > 1e15) && (s = "scientific"), o = function (t, e) {
					let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
					Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));
					return i
				}(t, i)
			}
			const r = h(Math.abs(o)),
				a = isNaN(r) ? 1 : Math.max(Math.min(-1 * Math.floor(r), 20), 0),
				l = {
					notation: s,
					minimumFractionDigits: a,
					maximumFractionDigits: a
				};
			return Object.assign(l, this.options.ticks.format), ge(t, n, l)
		},
		logarithmic(t, e, i) {
			if (0 === t) return "0";
			const n = i[e].significand || t / Math.pow(10, Math.floor(h(t)));
			return [1, 2, 3, 5, 10, 15].includes(n) || e > .8 * i.length ? me.numeric.call(this, t, e, i) : ""
		}
	};
	var ve = {
		formatters: me
	};
	const be = Object.create(null),
		_e = Object.create(null);

	function ye(i, t) {
		if (!t) return i;
		const n = t.split(".");
		for (let e = 0, t = n.length; e < t; ++e) {
			const t = n[e];
			i = i[t] || (i[t] = Object.create(null))
		}
		return i
	}

	function xe(t, e, i) {
		return "string" == typeof e ? $(ye(t, e), i) : $(ye(t, ""), e)
	}
	class we {
		constructor(t, e) {
			this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
				family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
				size: 12,
				style: "normal",
				lineHeight: 1.2,
				weight: null
			}, this.hover = {}, this.hoverBackgroundColor = (t, e) => ue(e.backgroundColor), this.hoverBorderColor = (t, e) => ue(e.borderColor), this.hoverColor = (t, e) => ue(e.color), this.indexAxis = "x", this.interaction = {
				mode: "nearest",
				intersect: !0,
				includeInvisible: !1
			}, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e)
		}
		set(t, e) {
			return xe(this, t, e)
		}
		get(t) {
			return ye(this, t)
		}
		describe(t, e) {
			return xe(_e, t, e)
		}
		override(t, e) {
			return xe(be, t, e)
		}
		route(t, e, i, n) {
			const s = ye(this, t),
				o = ye(this, i),
				r = "_" + e;
			Object.defineProperties(s, {
				[r]: {
					value: s[e],
					writable: !0
				}, [e]: {
					enumerable: !0,
					get() {
						const t = this[r],
							e = o[n];
						return E(t) ? Object.assign({}, e, t) : O(t, e)
					},
					set(t) {
						this[r] = t
					}
				}
			})
		}
		apply(t) {
			t.forEach(t => t(this))
		}
	}
	var S = new we({
		_scriptable: t => !t.startsWith("on"),
		_indexable: t => "events" !== t,
		hover: {
			_fallback: "interaction"
		},
		interaction: {
			_scriptable: !1,
			_indexable: !1
		}
	}, [function (t) {
		t.set("animation", {
			delay: void 0,
			duration: 1e3,
			easing: "easeOutQuart",
			fn: void 0,
			from: void 0,
			loop: void 0,
			to: void 0,
			type: void 0
		}), t.describe("animation", {
			_fallback: !1,
			_indexable: !1,
			_scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t
		}), t.set("animations", {
			colors: {
				type: "color",
				properties: fe
			},
			numbers: {
				type: "number",
				properties: de
			}
		}), t.describe("animations", {
			_fallback: "animation"
		}), t.set("transitions", {
			active: {
				animation: {
					duration: 400
				}
			},
			resize: {
				animation: {
					duration: 0
				}
			},
			show: {
				animations: {
					colors: {
						from: "transparent"
					},
					visible: {
						type: "boolean",
						duration: 0
					}
				}
			},
			hide: {
				animations: {
					colors: {
						to: "transparent"
					},
					visible: {
						type: "boolean",
						easing: "linear",
						fn: t => 0 | t
					}
				}
			}
		})
	}, function (t) {
		t.set("layout", {
			autoPadding: !0,
			padding: {
				top: 0,
				right: 0,
				bottom: 0,
				left: 0
			}
		})
	}, function (t) {
		t.set("scale", {
			display: !0,
			offset: !1,
			reverse: !1,
			beginAtZero: !1,
			bounds: "ticks",
			grace: 0,
			grid: {
				display: !0,
				lineWidth: 1,
				drawOnChartArea: !0,
				drawTicks: !0,
				tickLength: 8,
				tickWidth: (t, e) => e.lineWidth,
				tickColor: (t, e) => e.color,
				offset: !1
			},
			border: {
				display: !0,
				dash: [],
				dashOffset: 0,
				width: 1
			},
			title: {
				display: !1,
				text: "",
				padding: {
					top: 4,
					bottom: 4
				}
			},
			ticks: {
				minRotation: 0,
				maxRotation: 50,
				mirror: !1,
				textStrokeWidth: 0,
				textStrokeColor: "",
				padding: 3,
				display: !0,
				autoSkip: !0,
				autoSkipPadding: 3,
				labelOffset: 0,
				callback: ve.formatters.values,
				minor: {},
				major: {},
				align: "center",
				crossAlign: "near",
				showLabelBackdrop: !1,
				backdropColor: "rgba(255, 255, 255, 0.75)",
				backdropPadding: 2
			}
		}), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", {
			_fallback: !1,
			_scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
			_indexable: t => "borderDash" !== t && "tickBorderDash" !== t && "dash" !== t
		}), t.describe("scales", {
			_fallback: "scale"
		}), t.describe("scale.ticks", {
			_scriptable: t => "backdropPadding" !== t && "callback" !== t,
			_indexable: t => "backdropPadding" !== t
		})
	}]);

	function ke() {
		return "undefined" != typeof window && "undefined" != typeof document
	}

	function Ce(t) {
		let e = t.parentNode;
		return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
	}

	function De(t, e, i) {
		let n;
		return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n
	}
	const Me = t => t.ownerDocument.defaultView.getComputedStyle(t, null);

	function Te(t, e) {
		return Me(t).getPropertyValue(e)
	}
	const Se = ["top", "right", "bottom", "left"];

	function Pe(i, n, s) {
		const o = {};
		s = s ? "-" + s : "";
		for (let e = 0; e < 4; e++) {
			const t = Se[e];
			o[t] = parseFloat(i[n + "-" + t + s]) || 0
		}
		return o.width = o.left + o.right, o.height = o.top + o.bottom, o
	}
	const Ie = (t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot);

	function Ee(t, e) {
		if ("native" in t) return t;
		const {
			canvas: i,
			currentDevicePixelRatio: n
		} = e, s = Me(i), o = "border-box" === s.boxSizing, r = Pe(s, "padding"), a = Pe(s, "border", "width"), {
			x: l,
			y: h,
			box: c
		} = function (t, e) {
			const i = t.touches,
				n = i && i.length ? i[0] : t,
				{
					offsetX: s,
					offsetY: o
				} = n;
			let r, a, l = !1;
			if (Ie(s, o, t.target)) r = s, a = o;
			else {
				const t = e.getBoundingClientRect();
				r = n.clientX - t.left, a = n.clientY - t.top, l = !0
			}
			return {
				x: r,
				y: a,
				box: l
			}
		}(t, i), u = r.left + (c && a.left), d = r.top + (c && a.top);
		let {
			width: f,
			height: p
		} = e;
		return o && (f -= r.width + a.width, p -= r.height + a.height), {
			x: Math.round((l - u) / f * i.width / n),
			y: Math.round((h - d) / p * i.height / n)
		}
	}
	const Oe = t => Math.round(10 * t) / 10;

	function Ae(t, e, i, n) {
		const s = Me(t),
			o = Pe(s, "margin"),
			r = De(s.maxWidth, t, "clientWidth") || tt,
			a = De(s.maxHeight, t, "clientHeight") || tt,
			l = function (s, o, r) {
				let a, l;
				if (void 0 === o || void 0 === r) {
					const n = Ce(s);
					if (n) {
						const s = n.getBoundingClientRect(),
							t = Me(n),
							e = Pe(t, "border", "width"),
							i = Pe(t, "padding");
						o = s.width - i.width - e.width, r = s.height - i.height - e.height, a = De(t.maxWidth, n, "clientWidth"), l = De(t.maxHeight, n, "clientHeight")
					} else o = s.clientWidth, r = s.clientHeight
				}
				return {
					width: o,
					height: r,
					maxWidth: a || tt,
					maxHeight: l || tt
				}
			}(t, e, i);
		let {
			width: h,
			height: c
		} = l;
		if ("content-box" === s.boxSizing) {
			const t = Pe(s, "border", "width"),
				e = Pe(s, "padding");
			h -= e.width + t.width, c -= e.height + t.height
		}
		h = Math.max(0, h - o.width), c = Math.max(0, n ? h / n : c - o.height), h = Oe(Math.min(h, r, l.maxWidth)), c = Oe(Math.min(c, a, l.maxHeight)), h && !c && (c = Oe(h / 2));
		return (void 0 !== e || void 0 !== i) && n && l.height && c > l.height && (c = l.height, h = Oe(Math.floor(c * n))), {
			width: h,
			height: c
		}
	}

	function Le(t, e, i) {
		const n = e || 1,
			s = Math.floor(t.height * n),
			o = Math.floor(t.width * n);
		t.height = Math.floor(t.height), t.width = Math.floor(t.width);
		const r = t.canvas;
		return r.style && (i || !r.style.height && !r.style.width) && (r.style.height = `${t.height}px`, r.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== n || r.height !== s || r.width !== o) && (t.currentDevicePixelRatio = n, r.height = s, r.width = o, t.ctx.setTransform(n, 0, 0, n, 0, 0), !0)
	}
	const Ne = function () {
		let e = !1;
		try {
			const t = {
				get passive() {
					return e = !0, !1
				}
			};
			window.addEventListener("test", null, t), window.removeEventListener("test", null, t)
		} catch (e) { }
		return e
	}();

	function Re(t, e) {
		const i = Te(t, e),
			n = i && i.match(/^(\d+)(\.\d+)?px$/);
		return n ? +n[1] : void 0
	}

	function Fe(t) {
		return !t || T(t.size) || T(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
	}

	function He(t, e, i, n, s) {
		let o = e[s];
		return o || (o = e[s] = t.measureText(s).width, i.push(s)), o > n && (n = o), n
	}

	function ze(t, e, i, n) {
		let s = (n = n || {}).data = n.data || {},
			o = n.garbageCollect = n.garbageCollect || [];
		n.font !== e && (s = n.data = {}, o = n.garbageCollect = [], n.font = e), t.save(), t.font = e;
		let r = 0;
		const a = i.length;
		let l, h, c, u, d;
		for (l = 0; l < a; l++)
			if (u = i[l], null == u || I(u)) {
				if (I(u))
					for (h = 0, c = u.length; h < c; h++) d = u[h], null == d || I(d) || (r = He(t, s, o, r, d))
			} else r = He(t, s, o, r, u);
		t.restore();
		const f = o.length / 2;
		if (f > i.length) {
			for (l = 0; l < f; l++) delete s[o[l]];
			o.splice(0, f)
		}
		return r
	}

	function We(t, e, i) {
		const n = t.currentDevicePixelRatio,
			s = 0 !== i ? Math.max(i / 2, .5) : 0;
		return Math.round((e - s) * n) / n + s
	}

	function Be(t, e) {
		(e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()
	}

	function je(t, e, i, n) {
		Ye(t, e, i, n, null)
	}

	function Ye(t, e, i, n, s) {
		let o, r, a, l, h, c, u, d;
		const f = e.pointStyle,
			p = e.rotation,
			g = e.radius;
		let m = (p || 0) * et;
		if (f && "object" == typeof f && (o = f.toString(), "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o)) return t.save(), t.translate(i, n), t.rotate(m), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void t.restore();
		if (!(isNaN(g) || g <= 0)) {
			switch (t.beginPath(), f) {
				default: s ? t.ellipse(i, n, s / 2, g, 0, 0, y) : t.arc(i, n, g, 0, y),
					t.closePath();
					break;
				case "triangle":
					c = s ? s / 2 : g,
						t.moveTo(i + Math.sin(m) * c, n - Math.cos(m) * g),
						m += nt,
						t.lineTo(i + Math.sin(m) * c, n - Math.cos(m) * g),
						m += nt,
						t.lineTo(i + Math.sin(m) * c, n - Math.cos(m) * g),
						t.closePath();
					break;
				case "rectRounded":
					h = .516 * g,
						l = g - h,
						r = Math.cos(m + it) * l,
						u = Math.cos(m + it) * (s ? s / 2 - h : l),
						a = Math.sin(m + it) * l,
						d = Math.sin(m + it) * (s ? s / 2 - h : l),
						t.arc(i - u, n - a, h, m - A, m - L),
						t.arc(i + d, n - r, h, m - L, m),
						t.arc(i + u, n + a, h, m, m + L),
						t.arc(i - d, n + r, h, m + L, m + A),
						t.closePath();
					break;
				case "rect":
					if (!p) {
						l = Math.SQRT1_2 * g, c = s ? s / 2 : l, t.rect(i - c, n - l, 2 * c, 2 * l);
						break
					} m += it;
				case "rectRot":
					u = Math.cos(m) * (s ? s / 2 : g),
						r = Math.cos(m) * g,
						a = Math.sin(m) * g,
						d = Math.sin(m) * (s ? s / 2 : g),
						t.moveTo(i - u, n - a),
						t.lineTo(i + d, n - r),
						t.lineTo(i + u, n + a),
						t.lineTo(i - d, n + r),
						t.closePath();
					break;
				case "crossRot":
					m += it;
				case "cross":
					u = Math.cos(m) * (s ? s / 2 : g),
						r = Math.cos(m) * g,
						a = Math.sin(m) * g,
						d = Math.sin(m) * (s ? s / 2 : g),
						t.moveTo(i - u, n - a),
						t.lineTo(i + u, n + a),
						t.moveTo(i + d, n - r),
						t.lineTo(i - d, n + r);
					break;
				case "star":
					u = Math.cos(m) * (s ? s / 2 : g),
						r = Math.cos(m) * g,
						a = Math.sin(m) * g,
						d = Math.sin(m) * (s ? s / 2 : g),
						t.moveTo(i - u, n - a),
						t.lineTo(i + u, n + a),
						t.moveTo(i + d, n - r),
						t.lineTo(i - d, n + r),
						m += it,
						u = Math.cos(m) * (s ? s / 2 : g),
						r = Math.cos(m) * g,
						a = Math.sin(m) * g,
						d = Math.sin(m) * (s ? s / 2 : g),
						t.moveTo(i - u, n - a),
						t.lineTo(i + u, n + a),
						t.moveTo(i + d, n - r),
						t.lineTo(i - d, n + r);
					break;
				case "line":
					r = s ? s / 2 : Math.cos(m) * g,
						a = Math.sin(m) * g,
						t.moveTo(i - r, n - a),
						t.lineTo(i + r, n + a);
					break;
				case "dash":
					t.moveTo(i, n),
						t.lineTo(i + Math.cos(m) * (s ? s / 2 : g), n + Math.sin(m) * g);
					break;
				case !1:
					t.closePath()
			}
			t.fill(), e.borderWidth > 0 && t.stroke()
		}
	}

	function u(t, e, i) {
		return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i
	}

	function Ve(t, e) {
		t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
	}

	function $e(t) {
		t.restore()
	}

	function Ue(t, e, i, n, s) {
		if (!e) return t.lineTo(i.x, i.y);
		if ("middle" === s) {
			const n = (e.x + i.x) / 2;
			t.lineTo(n, e.y), t.lineTo(n, i.y)
		} else "after" === s != !!n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
		t.lineTo(i.x, i.y)
	}

	function qe(t, e, i, n) {
		if (!e) return t.lineTo(i.x, i.y);
		t.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y)
	}

	function Ge(r, a, l, h, c) {
		if (c.strikethrough || c.underline) {
			const t = r.measureText(h),
				e = a - t.actualBoundingBoxLeft,
				i = a + t.actualBoundingBoxRight,
				n = l - t.actualBoundingBoxAscent,
				s = l + t.actualBoundingBoxDescent,
				o = c.strikethrough ? (n + s) / 2 : s;
			r.strokeStyle = r.fillStyle, r.beginPath(), r.lineWidth = c.decorationWidth || 2, r.moveTo(e, o), r.lineTo(i, o), r.stroke()
		}
	}

	function Ke(t, e) {
		const i = t.fillStyle;
		t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i
	}

	function Xe(t, e, i, n, s, o = {}) {
		const r = I(e) ? e : [e],
			a = o.strokeWidth > 0 && "" !== o.strokeColor;
		let l, h;
		for (t.save(), t.font = s.string, function (t, e) {
			e.translation && t.translate(e.translation[0], e.translation[1]), T(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline)
		}(t, o), l = 0; l < r.length; ++l) h = r[l], o.backdrop && Ke(t, o.backdrop), a && (o.strokeColor && (t.strokeStyle = o.strokeColor), T(o.strokeWidth) || (t.lineWidth = o.strokeWidth), t.strokeText(h, i, n, o.maxWidth)), t.fillText(h, i, n, o.maxWidth), Ge(t, i, n, h, o), n += Number(s.lineHeight);
		t.restore()
	}

	function Ze(t, e) {
		const {
			x: i,
			y: n,
			w: s,
			h: o,
			radius: r
		} = e;
		t.arc(i + r.topLeft, n + r.topLeft, r.topLeft, -L, A, !0), t.lineTo(i, n + o - r.bottomLeft), t.arc(i + r.bottomLeft, n + o - r.bottomLeft, r.bottomLeft, A, L, !0), t.lineTo(i + s - r.bottomRight, n + o), t.arc(i + s - r.bottomRight, n + o - r.bottomRight, r.bottomRight, L, 0, !0), t.lineTo(i + s, n + r.topRight), t.arc(i + s - r.topRight, n + r.topRight, r.topRight, 0, -L, !0), t.lineTo(i + r.topLeft, n)
	}

	function Qe(i, n = [""], t, e, s = () => i[0]) {
		const o = t || i;
		void 0 === e && (e = hi("_fallback", i));
		const r = {
			[Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: i, _rootScopes: o, _fallback: e, _getTarget: s, override: t => Qe([t, ...i], n, o, e)
		};
		return new Proxy(r, {
			deleteProperty: (t, e) => (delete t[e], delete t._keys, delete i[0][e], !0),
			get: (t, e) => ni(t, e, () => function (e, i, n, s) {
				let o;
				for (const t of i)
					if (o = hi(ei(t, e), n), void 0 !== o) return ii(e, o) ? ai(n, s, e, o) : o
			}(e, n, i, t)),
			getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
			getPrototypeOf: () => Reflect.getPrototypeOf(i[0]),
			has: (t, e) => ci(t).includes(e),
			ownKeys: t => ci(t),
			set(t, e, i) {
				const n = t._storage || (t._storage = s());
				return t[e] = n[e] = i, delete t._keys, !0
			}
		})
	}

	function Je(n, e, i, s) {
		const t = {
			_cacheable: !1,
			_proxy: n,
			_context: e,
			_subProxy: i,
			_stack: new Set,
			_descriptors: ti(n, s),
			setContext: t => Je(n, t, i, s),
			override: t => Je(n.override(t), e, i, s)
		};
		return new Proxy(t, {
			deleteProperty: (t, e) => (delete t[e], delete n[e], !0),
			get: (t, e, i) => ni(t, e, () => function (t, e, i) {
				const {
					_proxy: n,
					_context: s,
					_subProxy: o,
					_descriptors: r
				} = t;
				let a = n[e];
				l(a) && r.isScriptable(e) && (a = function (t, e, i, n) {
					const {
						_proxy: s,
						_context: o,
						_subProxy: r,
						_stack: a
					} = i;
					if (a.has(t)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t);
					a.add(t);
					let l = e(o, r || n);
					a.delete(t), ii(t, l) && (l = ai(s._scopes, s, t, l));
					return l
				}(e, a, t, i));
				I(a) && a.length && (a = function (t, e, i, n) {
					const {
						_proxy: s,
						_context: o,
						_subProxy: r,
						_descriptors: a
					} = i;
					if (void 0 !== o.index && n(t)) return e[o.index % e.length];
					if (E(e[0])) {
						const i = e,
							n = s._scopes.filter(t => t !== i);
						e = [];
						for (const E of i) {
							const i = ai(n, s, t, E);
							e.push(Je(i, o, r && r[t], a))
						}
					}
					return e
				}(e, a, t, r.isIndexable));
				ii(e, a) && (a = Je(a, s, o && o[e], r));
				return a
			}(t, e, i)),
			getOwnPropertyDescriptor: (t, e) => t._descriptors.allKeys ? Reflect.has(n, e) ? {
				enumerable: !0,
				configurable: !0
			} : void 0 : Reflect.getOwnPropertyDescriptor(n, e),
			getPrototypeOf: () => Reflect.getPrototypeOf(n),
			has: (t, e) => Reflect.has(n, e),
			ownKeys: () => Reflect.ownKeys(n),
			set: (t, e, i) => (n[e] = i, delete t[e], !0)
		})
	}

	function ti(t, e = {
		scriptable: !0,
		indexable: !0
	}) {
		const {
			_scriptable: i = e.scriptable,
			_indexable: n = e.indexable,
			_allKeys: s = e.allKeys
		} = t;
		return {
			allKeys: s,
			scriptable: i,
			indexable: n,
			isScriptable: l(i) ? i : () => i,
			isIndexable: l(n) ? n : () => n
		}
	}
	const ei = (t, e) => t ? t + K(e) : e,
		ii = (t, e) => E(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);

	function ni(t, e, i) {
		if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];
		const n = i();
		return t[e] = n, n
	}

	function si(t, e, i) {
		return l(t) ? t(e, i) : t
	}
	const oi = (t, e) => !0 === t ? e : "string" == typeof t ? m(e, t) : void 0;

	function ri(e, i, n, s, o) {
		for (const t of i) {
			const i = oi(n, t);
			if (i) {
				e.add(i);
				const t = si(i._fallback, n, o);
				if (void 0 !== t && t !== n && t !== s) return t
			} else if (!1 === i && void 0 !== s && n !== s) return null
		}
		return !1
	}

	function ai(t, e, i, n) {
		const s = e._rootScopes,
			o = si(e._fallback, i, n),
			r = [...t, ...s],
			a = new Set;
		a.add(n);
		let l = li(a, r, i, o || i, n);
		return null !== l && ((void 0 === o || o === i || (l = li(a, r, o, l, n), null !== l)) && Qe(Array.from(a), [""], s, o, () => function (t, e, i) {
			const n = t._getTarget();
			e in n || (n[e] = {});
			const s = n[e];
			if (I(s) && E(i)) return i;
			return s || {}
		}(e, i, n)))
	}

	function li(t, e, i, n, s) {
		for (; i;) i = ri(t, e, i, n, s);
		return i
	}

	function hi(e, i) {
		for (const t of i) {
			if (!t) continue;
			const i = t[e];
			if (void 0 !== i) return i
		}
	}

	function ci(t) {
		let e = t._keys;
		return e || (e = t._keys = function (e) {
			const i = new Set;
			for (const t of e)
				for (const e of Object.keys(t).filter(t => !t.startsWith("_"))) i.add(e);
			return Array.from(i)
		}(t._scopes)), e
	}

	function ui(t, e, i, n) {
		const {
			iScale: s
		} = t, {
			key: o = "r"
		} = this._parsing, r = new Array(n);
		let a, l, h, c;
		for (a = 0, l = n; a < l; ++a) h = a + i, c = e[h], r[a] = {
			r: s.parse(m(c, o), h)
		};
		return r
	}
	const di = Number.EPSILON || 1e-14,
		fi = (t, e) => e < t.length && !t[e].skip && t[e],
		pi = t => "x" === t ? "y" : "x";

	function gi(t, e, i, n) {
		const s = t.skip ? e : t,
			o = e,
			r = i.skip ? e : i,
			a = ft(o, s),
			l = ft(r, o);
		let h = a / (a + l),
			c = l / (a + l);
		h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;
		const u = n * h,
			d = n * c;
		return {
			previous: {
				x: o.x - u * (r.x - s.x),
				y: o.y - u * (r.y - s.y)
			},
			next: {
				x: o.x + d * (r.x - s.x),
				y: o.y + d * (r.y - s.y)
			}
		}
	}

	function mi(t, e = "x") {
		const i = pi(e),
			n = t.length,
			s = Array(n).fill(0),
			o = Array(n);
		let r, a, l, h = fi(t, 0);
		for (r = 0; r < n; ++r)
			if (a = l, l = h, h = fi(t, r + 1), l) {
				if (h) {
					const t = h[e] - l[e];
					s[r] = 0 !== t ? (h[i] - l[i]) / t : 0
				}
				o[r] = a ? h ? v(s[r - 1]) !== v(s[r]) ? 0 : (s[r - 1] + s[r]) / 2 : s[r - 1] : s[r]
			} ! function (e, i, n) {
				const s = e.length;
				let o, r, a, l, h, c = fi(e, 0);
				for (let t = 0; t < s - 1; ++t) h = c, c = fi(e, t + 1), h && c && (st(i[t], 0, di) ? n[t] = n[t + 1] = 0 : (o = n[t] / i[t], r = n[t + 1] / i[t], l = Math.pow(o, 2) + Math.pow(r, 2), l <= 9 || (a = 3 / Math.sqrt(l), n[t] = o * a * i[t], n[t + 1] = r * a * i[t])))
			}(t, s, o),
				function (i, n, s = "x") {
					const o = pi(s),
						r = i.length;
					let a, l, h, c = fi(i, 0);
					for (let e = 0; e < r; ++e) {
						if (l = h, h = c, c = fi(i, e + 1), !h) continue;
						const r = h[s],
							t = h[o];
						l && (a = (r - l[s]) / 3, h[`cp1${s}`] = r - a, h[`cp1${o}`] = t - a * n[e]), c && (a = (c[s] - r) / 3, h[`cp2${s}`] = r + a, h[`cp2${o}`] = t + a * n[e])
					}
				}(t, o, e)
	}

	function vi(t, e, i) {
		return Math.max(Math.min(t, i), e)
	}

	function bi(e, i, t, n, s) {
		let o, r, a, l;
		if (i.spanGaps && (e = e.filter(t => !t.skip)), "monotone" === i.cubicInterpolationMode) mi(e, s);
		else {
			let t = n ? e[e.length - 1] : e[0];
			for (o = 0, r = e.length; o < r; ++o) a = e[o], l = gi(t, a, e[Math.min(o + 1, r - (n ? 0 : 1)) % r], i.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, t = a
		}
		i.capBezierPoints && function (t, e) {
			let i, n, s, o, r, a = u(t[0], e);
			for (i = 0, n = t.length; i < n; ++i) r = o, o = a, a = i < n - 1 && u(t[i + 1], e), o && (s = t[i], r && (s.cp1x = vi(s.cp1x, e.left, e.right), s.cp1y = vi(s.cp1y, e.top, e.bottom)), a && (s.cp2x = vi(s.cp2x, e.left, e.right), s.cp2y = vi(s.cp2y, e.top, e.bottom)))
		}(e, t)
	}
	const _i = t => 0 === t || 1 === t,
		yi = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * y / i),
		xi = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * y / i) + 1,
		wi = {
			linear: t => t,
			easeInQuad: t => t * t,
			easeOutQuad: t => -t * (t - 2),
			easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
			easeInCubic: t => t * t * t,
			easeOutCubic: t => (t -= 1) * t * t + 1,
			easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
			easeInQuart: t => t * t * t * t,
			easeOutQuart: t => -((t -= 1) * t * t * t - 1),
			easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
			easeInQuint: t => t * t * t * t * t,
			easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
			easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
			easeInSine: t => 1 - Math.cos(t * L),
			easeOutSine: t => Math.sin(t * L),
			easeInOutSine: t => -.5 * (Math.cos(A * t) - 1),
			easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
			easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
			easeInOutExpo: t => _i(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
			easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
			easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
			easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
			easeInElastic: t => _i(t) ? t : yi(t, .075, .3),
			easeOutElastic: t => _i(t) ? t : xi(t, .075, .3),
			easeInOutElastic(t) {
				const e = .1125;
				return _i(t) ? t : t < .5 ? .5 * yi(2 * t, e, .45) : .5 + .5 * xi(2 * t - 1, e, .45)
			},
			easeInBack(t) {
				const e = 1.70158;
				return t * t * ((e + 1) * t - e)
			},
			easeOutBack(t) {
				const e = 1.70158;
				return (t -= 1) * t * ((e + 1) * t + e) + 1
			},
			easeInOutBack(t) {
				let e = 1.70158;
				return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
			},
			easeInBounce: t => 1 - wi.easeOutBounce(1 - t),
			easeOutBounce(t) {
				const e = 7.5625,
					i = 2.75;
				return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375
			},
			easeInOutBounce: t => t < .5 ? .5 * wi.easeInBounce(2 * t) : .5 * wi.easeOutBounce(2 * t - 1) + .5
		};

	function ki(t, e, i, n) {
		return {
			x: t.x + i * (e.x - t.x),
			y: t.y + i * (e.y - t.y)
		}
	}

	function Ci(t, e, i, n) {
		return {
			x: t.x + i * (e.x - t.x),
			y: "middle" === n ? i < .5 ? t.y : e.y : "after" === n ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y
		}
	}

	function Di(t, e, i, n) {
		const s = {
			x: t.cp2x,
			y: t.cp2y
		},
			o = {
				x: e.cp1x,
				y: e.cp1y
			},
			r = ki(t, s, i),
			a = ki(s, o, i),
			l = ki(o, e, i),
			h = ki(r, a, i),
			c = ki(a, l, i);
		return ki(h, c, i)
	}
	const Mi = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
		Ti = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;

	function Si(t, e) {
		const i = ("" + t).match(Mi);
		if (!i || "normal" === i[1]) return 1.2 * e;
		switch (t = +i[2], i[3]) {
			case "px":
				return t;
			case "%":
				t /= 100
		}
		return e * t
	}
	const Pi = t => +t || 0;

	function Ii(e, i) {
		const t = {},
			n = E(i),
			s = n ? Object.keys(i) : i,
			o = E(e) ? n ? t => O(e[t], e[i[t]]) : t => e[t] : () => e;
		for (const e of s) t[e] = Pi(o(e));
		return t
	}

	function Ei(t) {
		return Ii(t, {
			top: "y",
			right: "x",
			bottom: "y",
			left: "x"
		})
	}

	function Oi(t) {
		return Ii(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
	}

	function R(t) {
		const e = Ei(t);
		return e.width = e.left + e.right, e.height = e.top + e.bottom, e
	}

	function P(t, e) {
		t = t || {}, e = e || S.font;
		let i = O(t.size, e.size);
		"string" == typeof i && (i = parseInt(i, 10));
		let n = O(t.style, e.style);
		n && !("" + n).match(Ti) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
		const s = {
			family: O(t.family, e.family),
			lineHeight: Si(O(t.lineHeight, e.lineHeight), i),
			size: i,
			style: n,
			weight: O(t.weight, e.weight),
			string: ""
		};
		return s.string = Fe(s), s
	}

	function Ai(t, e, i, n) {
		let s, o, r, a = !0;
		for (s = 0, o = t.length; s < o; ++s)
			if (r = t[s], void 0 !== r && (void 0 !== e && "function" == typeof r && (r = r(e), a = !1), void 0 !== i && I(r) && (r = r[i % r.length], a = !1), void 0 !== r)) return n && !a && (n.cacheable = !1), r
	}

	function Li(t, e, i) {
		const {
			min: n,
			max: s
		} = t, o = W(e, (s - n) / 2), r = (t, e) => i && 0 === t ? 0 : t + e;
		return {
			min: r(n, -Math.abs(o)),
			max: r(s, o)
		}
	}

	function Ni(t, e) {
		return Object.assign(Object.create(t), e)
	}

	function Ri(t, e, i) {
		return t ? function (e, i) {
			return {
				x: t => e + e + i - t,
				setWidth(t) {
					i = t
				},
				textAlign: t => "center" === t ? t : "right" === t ? "left" : "right",
				xPlus: (t, e) => t - e,
				leftForLtr: (t, e) => t - e
			}
		}(e, i) : {
			x: t => t,
			setWidth(t) { },
			textAlign: t => t,
			xPlus: (t, e) => t + e,
			leftForLtr: (t, e) => t
		}
	}

	function Fi(t, e) {
		let i, n;
		"ltr" !== e && "rtl" !== e || (i = t.canvas.style, n = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = n)
	}

	function Hi(t, e) {
		void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]))
	}

	function zi(t) {
		return "angle" === t ? {
			between: gt,
			compare: pt,
			normalize: b
		} : {
			between: x,
			compare: (t, e) => t - e,
			normalize: t => t
		}
	}

	function Wi({
		start: t,
		end: e,
		count: i,
		loop: n,
		style: s
	}) {
		return {
			start: t % i,
			end: e % i,
			loop: n && (e - t + 1) % i == 0,
			style: s
		}
	}

	function Bi(t, i, e) {
		if (!e) return [t];
		const {
			property: n,
			start: s,
			end: o
		} = e, r = i.length, {
			compare: a,
			between: l,
			normalize: h
		} = zi(n), {
			start: c,
			end: u,
			loop: d,
			style: f
		} = function (t, e, i) {
			const {
				property: n,
				start: s,
				end: o
			} = i, {
				between: r,
				normalize: a
			} = zi(n), l = e.length;
			let h, c, {
				start: u,
				end: d,
				loop: f
			} = t;
			if (f) {
				for (u += l, d += l, h = 0, c = l; h < c && r(a(e[u % l][n]), s, o); ++h) u--, d--;
				u %= l, d %= l
			}
			return d < u && (d += l), {
				start: u,
				end: d,
				loop: f,
				style: t.style
			}
		}(t, i, e), p = [];
		let g, m, v, b = !1,
			_ = null;
		const y = () => b || l(s, v, g) && 0 !== a(s, v),
			x = () => !b || 0 === a(o, g) || l(o, v, g);
		for (let t = c, e = c; t <= u; ++t) m = i[t % r], m.skip || (g = h(m[n]), g !== v && (b = l(g, s, o), null === _ && y() && (_ = 0 === a(g, s) ? t : e), null !== _ && x() && (p.push(Wi({
			start: _,
			end: t,
			loop: d,
			count: r,
			style: f
		})), _ = null), e = t, v = g));
		return null !== _ && p.push(Wi({
			start: _,
			end: u,
			loop: d,
			count: r,
			style: f
		})), p
	}

	function ji(i, n) {
		const s = [],
			o = i.segments;
		for (let e = 0; e < o.length; e++) {
			const t = Bi(o[e], i.points, n);
			t.length && s.push(...t)
		}
		return s
	}

	function Yi(t, e) {
		const i = t.points,
			n = t.options.spanGaps,
			s = i.length;
		if (!s) return [];
		const o = !!t._loop,
			{
				start: r,
				end: a
			} = function (t, e, i, n) {
				let s = 0,
					o = e - 1;
				if (i && !n)
					for (; s < e && !t[s].skip;) s++;
				for (; s < e && t[s].skip;) s++;
				for (s %= e, i && (o += s); o > s && t[o % e].skip;) o--;
				return o %= e, {
					start: s,
					end: o
				}
			}(i, s, o, n);
		if (!0 === n) return Vi(t, [{
			start: r,
			end: a,
			loop: o
		}], i, e);
		return Vi(t, function (t, e, i, n) {
			const s = t.length,
				o = [];
			let r, a = e,
				l = t[e];
			for (r = e + 1; r <= i; ++r) {
				const i = t[r % s];
				i.skip || i.stop ? l.skip || (n = !1, o.push({
					start: e % s,
					end: (r - 1) % s,
					loop: n
				}), e = a = i.stop ? r : null) : (a = r, l.skip && (e = r)), l = i
			}
			return null !== a && o.push({
				start: e % s,
				end: a % s,
				loop: n
			}), o
		}(i, r, a < r ? a + s : a, !!t._fullLoop && 0 === r && a === s - 1), i, e)
	}

	function Vi(t, e, i, n) {
		return n && n.setContext && i ? function (i, t, o, n) {
			const s = i._chart.getContext(),
				e = $i(i.options),
				{
					_datasetIndex: r,
					options: {
						spanGaps: a
					}
				} = i,
				l = o.length,
				h = [];
			let c = e,
				u = t[0].start,
				d = u;

			function f(t, e, i, n) {
				const s = a ? -1 : 1;
				if (t !== e) {
					for (t += l; o[t % l].skip;) t -= s;
					for (; o[e % l].skip;) e += s;
					t % l != e % l && (h.push({
						start: t % l,
						end: e % l,
						loop: i,
						style: n
					}), c = n, u = e % l)
				}
			}
			for (const i of t) {
				u = a ? u : i.start;
				let t, e = o[u % l];
				for (d = u + 1; d <= i.end; d++) {
					const a = o[d % l];
					t = $i(n.setContext(Ni(s, {
						type: "segment",
						p0: e,
						p1: a,
						p0DataIndex: (d - 1) % l,
						p1DataIndex: d % l,
						datasetIndex: r
					}))), Ui(t, c) && f(u, d - 1, i.loop, c), e = a, c = t
				}
				u < d - 1 && f(u, d - 1, i.loop, c)
			}
			return h
		}(t, e, i, n) : e
	}

	function $i(t) {
		return {
			backgroundColor: t.backgroundColor,
			borderCapStyle: t.borderCapStyle,
			borderDash: t.borderDash,
			borderDashOffset: t.borderDashOffset,
			borderJoinStyle: t.borderJoinStyle,
			borderWidth: t.borderWidth,
			borderColor: t.borderColor
		}
	}

	function Ui(t, e) {
		if (!e) return !1;
		const i = [],
			n = function (t, e) {
				return he(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e
			};
		return JSON.stringify(t, n) !== JSON.stringify(e, n)
	}
	var qi = Object.freeze({
		__proto__: null,
		HALF_PI: L,
		INFINITY: tt,
		PI: A,
		PITAU: J,
		QUARTER_PI: it,
		RAD_PER_DEG: et,
		TAU: y,
		TWO_THIRDS_PI: nt,
		_addGrace: Li,
		_alignPixel: We,
		_alignStartEnd: M,
		_angleBetween: gt,
		_angleDiff: pt,
		_arrayUnique: kt,
		_attachContext: Je,
		_bezierCurveTo: qe,
		_bezierInterpolation: Di,
		_boundSegment: Bi,
		_boundSegments: ji,
		_capitalize: K,
		_computeSegments: Yi,
		_createResolver: Qe,
		_decimalPlaces: ut,
		_deprecated: function (t, e, i, n) {
			void 0 !== e && console.warn(t + ': "' + i + '" is deprecated. Please use "' + n + '" instead')
		},
		_descriptors: ti,
		_elementsEqual: B,
		_factorize: rt,
		_filterBetween: _t,
		_getParentNode: Ce,
		_getStartAndCountOfVisiblePoints: Pt,
		_int16Range: mt,
		_isBetween: x,
		_isClickEvent: Q,
		_isDomSupported: ke,
		_isPointInArea: u,
		_limitValue: _,
		_longestText: ze,
		_lookup: vt,
		_lookupByKey: w,
		_measureText: He,
		_merger: V,
		_mergerIf: o,
		_normalizeAngle: b,
		_parseObjectDataRadialScale: ui,
		_pointInLine: ki,
		_readValueToProps: Ii,
		_rlookupByKey: bt,
		_scaleRangesChanged: It,
		_setMinAndMaxByKey: ht,
		_splitKey: G,
		_steppedInterpolation: Ci,
		_steppedLineTo: Ue,
		_textX: St,
		_toLeftRightCenter: Tt,
		_updateBezierControlPoints: bi,
		addRoundedRectPath: Ze,
		almostEquals: st,
		almostWhole: lt,
		callback: f,
		clearCanvas: Be,
		clipArea: Ve,
		clone: j,
		color: ce,
		createContext: Ni,
		debounce: Mt,
		defined: X,
		distanceBetweenPoints: ft,
		drawPoint: je,
		drawPointLegend: Ye,
		each: C,
		easingEffects: wi,
		finiteOrDefault: g,
		fontString: function (t, e, i) {
			return e + " " + t + "px " + i
		},
		formatNumber: ge,
		getAngleFromPoint: dt,
		getHoverColor: ue,
		getMaximumSize: Ae,
		getRelativePosition: Ee,
		getRtlAdapter: Ri,
		getStyle: Te,
		isArray: I,
		isFinite: p,
		isFunction: l,
		isNullOrUndef: T,
		isNumber: at,
		isObject: E,
		isPatternOrGradient: he,
		listenArrayEvents: xt,
		log10: h,
		merge: $,
		mergeIf: U,
		niceNum: ot,
		noop: t,
		overrideTextDirection: Fi,
		readUsedSize: Re,
		renderText: Xe,
		requestAnimFrame: Ct,
		resolve: Ai,
		resolveObjectKey: m,
		restoreTextDirection: Hi,
		retinaScale: Le,
		setsEqual: Z,
		sign: v,
		splineCurve: gi,
		splineCurveMonotone: mi,
		supportsEventListenerOptions: Ne,
		throttled: Dt,
		toDegrees: ct,
		toDimension: W,
		toFont: P,
		toFontString: Fe,
		toLineHeight: Si,
		toPadding: R,
		toPercentage: z,
		toRadians: N,
		toTRBL: Ei,
		toTRBLCorners: Oi,
		uid: H,
		unclipArea: $e,
		unlistenArrayEvents: wt,
		valueOrDefault: O
	});

	function Gi(t, e, i, n) {
		const {
			controller: s,
			data: o,
			_sorted: r
		} = t, a = s._cachedMeta.iScale;
		if (a && e === a.axis && "r" !== e && r && o.length) {
			const t = a._reversePixels ? bt : w;
			if (!n) return t(o, e, i);
			if (s._sharedOptions) {
				const n = o[0],
					s = "function" == typeof n.getRange && n.getRange(e);
				if (s) {
					const n = t(o, e, i - s),
						r = t(o, e, i + s);
					return {
						lo: n.lo,
						hi: r.hi
					}
				}
			}
		}
		return {
			lo: 0,
			hi: o.length - 1
		}
	}

	function Ki(t, s, o, r, a) {
		const l = t.getSortedVisibleDatasetMetas(),
			h = o[s];
		for (let t = 0, e = l.length; t < e; ++t) {
			const {
				index: o,
				data: e
			} = l[t], {
				lo: i,
				hi: n
			} = Gi(l[t], s, h, a);
			for (let t = i; t <= n; ++t) {
				const s = e[t];
				s.skip || r(s, o, t)
			}
		}
	}

	function Xi(n, s, t, o, r) {
		const a = [];
		if (!r && !n.isPointInArea(s)) return a;
		return Ki(n, t, s, function (t, e, i) {
			(r || u(t, n.chartArea, 0)) && t.inRange(s.x, s.y, o) && a.push({
				element: t,
				datasetIndex: e,
				index: i
			})
		}, !0), a
	}

	function Zi(r, a, t, l, h, c) {
		let u = [];
		const d = function (t) {
			const s = -1 !== t.indexOf("x"),
				o = -1 !== t.indexOf("y");
			return function (t, e) {
				const i = s ? Math.abs(t.x - e.x) : 0,
					n = o ? Math.abs(t.y - e.y) : 0;
				return Math.sqrt(Math.pow(i, 2) + Math.pow(n, 2))
			}
		}(t);
		let f = Number.POSITIVE_INFINITY;
		return Ki(r, t, a, function (t, e, i) {
			const n = t.inRange(a.x, a.y, h);
			if (l && !n) return;
			const s = t.getCenterPoint(h);
			if (!(!!c || r.isPointInArea(s)) && !n) return;
			const o = d(a, s);
			o < f ? (u = [{
				element: t,
				datasetIndex: e,
				index: i
			}], f = o) : o === f && u.push({
				element: t,
				datasetIndex: e,
				index: i
			})
		}), u
	}

	function Qi(t, e, i, n, s, o) {
		return o || t.isPointInArea(e) ? "r" !== i || n ? Zi(t, e, i, n, s, o) : function (t, r, e, a) {
			let l = [];
			return Ki(t, e, r, function (t, e, i) {
				const {
					startAngle: n,
					endAngle: s
				} = t.getProps(["startAngle", "endAngle"], a), {
					angle: o
				} = dt(t, {
					x: r.x,
					y: r.y
				});
				gt(o, n, s) && l.push({
					element: t,
					datasetIndex: e,
					index: i
				})
			}), l
		}(t, e, i, s) : []
	}

	function Ji(t, n, s, e, o) {
		const r = [],
			a = "x" === s ? "inXRange" : "inYRange";
		let l = !1;
		return Ki(t, s, n, (t, e, i) => {
			t[a](n[s], o) && (r.push({
				element: t,
				datasetIndex: e,
				index: i
			}), l = l || t.inRange(n.x, n.y, o))
		}), e && !l ? [] : r
	}
	var tn = {
		evaluateInteractionItems: Ki,
		modes: {
			index(t, e, i, n) {
				const s = Ee(e, t),
					o = i.axis || "x",
					r = i.includeInvisible || !1,
					a = i.intersect ? Xi(t, s, o, n, r) : Qi(t, s, o, !1, n, r),
					l = [];
				return a.length ? (t.getSortedVisibleDatasetMetas().forEach(t => {
					const e = a[0].index,
						i = t.data[e];
					i && !i.skip && l.push({
						element: i,
						datasetIndex: t.index,
						index: e
					})
				}), l) : []
			}, dataset(t, e, i, n) {
				const s = Ee(e, t),
					o = i.axis || "xy",
					r = i.includeInvisible || !1;
				let a = i.intersect ? Xi(t, s, o, n, r) : Qi(t, s, o, !1, n, r);
				if (a.length > 0) {
					const e = a[0].datasetIndex,
						i = t.getDatasetMeta(e).data;
					a = [];
					for (let t = 0; t < i.length; ++t) a.push({
						element: i[t],
						datasetIndex: e,
						index: t
					})
				}
				return a
			}, point: (t, e, i, n) => Xi(t, Ee(e, t), i.axis || "xy", n, i.includeInvisible || !1), nearest(t, e, i, n) {
				const s = Ee(e, t),
					o = i.axis || "xy",
					r = i.includeInvisible || !1;
				return Qi(t, s, o, i.intersect, n, r)
			}, x: (t, e, i, n) => Ji(t, Ee(e, t), "x", i.intersect, n), y: (t, e, i, n) => Ji(t, Ee(e, t), "y", i.intersect, n)
		}
	};
	const en = ["left", "top", "right", "bottom"];

	function nn(t, e) {
		return t.filter(t => t.pos === e)
	}

	function sn(t, e) {
		return t.filter(t => -1 === en.indexOf(t.pos) && t.box.axis === e)
	}

	function on(t, s) {
		return t.sort((t, e) => {
			const i = s ? e : t,
				n = s ? t : e;
			return i.weight === n.weight ? i.index - n.index : i.weight - n.weight
		})
	}

	function rn(i, n) {
		const s = function (s) {
			const o = {};
			for (const n of s) {
				const {
					stack: s,
					pos: t,
					stackWeight: e
				} = n;
				if (!s || !en.includes(t)) continue;
				const i = o[s] || (o[s] = {
					count: 0,
					placed: 0,
					weight: 0,
					size: 0
				});
				i.count++, i.weight += e
			}
			return o
		}(i),
			{
				vBoxMaxWidth: o,
				hBoxMaxHeight: r
			} = n;
		let a, l, h;
		for (a = 0, l = i.length; a < l; ++a) {
			h = i[a];
			const {
				fullSize: l
			} = h.box, t = s[h.stack], e = t && h.stackWeight / t.weight;
			h.horizontal ? (h.width = e ? e * o : l && n.availableWidth, h.height = r) : (h.width = o, h.height = e ? e * r : l && n.availableHeight)
		}
		return s
	}

	function an(t, e, i, n) {
		return Math.max(t[i], e[i]) + Math.max(t[n], e[n])
	}

	function ln(t, e) {
		t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right)
	}

	function hn(t, e, i, n) {
		const {
			pos: s,
			box: o
		} = i, r = t.maxPadding;
		if (!E(s)) {
			i.size && (t[s] -= i.size);
			const e = n[i.stack] || {
				size: 0,
				count: 1
			};
			e.size = Math.max(e.size, i.horizontal ? o.height : o.width), i.size = e.size / e.count, t[s] += i.size
		}
		o.getPadding && ln(r, o.getPadding());
		const a = Math.max(0, e.outerWidth - an(r, t, "left", "right")),
			l = Math.max(0, e.outerHeight - an(r, t, "top", "bottom")),
			h = a !== t.w,
			c = l !== t.h;
		return t.w = a, t.h = l, i.horizontal ? {
			same: h,
			other: c
		} : {
			same: c,
			other: h
		}
	}

	function cn(t, i) {
		const n = i.maxPadding;

		function e(t) {
			const e = {
				left: 0,
				top: 0,
				right: 0,
				bottom: 0
			};
			return t.forEach(t => {
				e[t] = Math.max(i[t], n[t])
			}), e
		}
		return e(t ? ["left", "right"] : ["top", "bottom"])
	}

	function un(e, i, n, s) {
		const o = [];
		let r, a, l, h, c, u;
		for (r = 0, a = e.length, c = 0; r < a; ++r) {
			l = e[r], h = l.box, h.update(l.width || i.w, l.height || i.h, cn(l.horizontal, i));
			const {
				same: a,
				other: t
			} = hn(i, n, l, s);
			c |= a && o.length, u = u || t, h.fullSize || o.push(l)
		}
		return c && un(o, i, n, s) || u
	}

	function dn(t, e, i, n, s) {
		t.top = i, t.left = e, t.right = e + n, t.bottom = i + s, t.width = n, t.height = s
	}

	function fn(n, s, o, r) {
		const a = o.padding;
		let {
			x: l,
			y: h
		} = s;
		for (const i of n) {
			const n = i.box,
				t = r[i.stack] || {
					count: 1,
					placed: 0,
					weight: 1
				},
				e = i.stackWeight / t.weight || 1;
			if (i.horizontal) {
				const r = s.w * e,
					l = t.size || n.height;
				X(t.start) && (h = t.start), n.fullSize ? dn(n, a.left, h, o.outerWidth - a.right - a.left, l) : dn(n, s.left + t.placed, h, r, l), t.start = h, t.placed += r, h = n.bottom
			} else {
				const r = s.h * e,
					h = t.size || n.width;
				X(t.start) && (l = t.start), n.fullSize ? dn(n, l, a.top, h, o.outerHeight - a.bottom - a.top) : dn(n, l, s.top + t.placed, h, r), t.start = l, t.placed += r, l = n.right
			}
		}
		s.x = l, s.y = h
	}
	var s = {
		addBox(t, e) {
			t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () {
				return [{
					z: 0,
					draw(t) {
						e.draw(t)
					}
				}]
			}, t.boxes.push(e)
		}, removeBox(t, e) {
			const i = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== i && t.boxes.splice(i, 1)
		}, configure(t, e, i) {
			e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight
		}, update(i, t, e, n) {
			if (!i) return;
			const s = R(i.options.layout.padding),
				o = Math.max(t - s.width, 0),
				r = Math.max(e - s.height, 0),
				a = function (t) {
					const e = function (t) {
						const e = [];
						let i, n, s, o, r, a;
						for (i = 0, n = (t || []).length; i < n; ++i) s = t[i], {
							position: o,
							options: {
								stack: r,
								stackWeight: a = 1
							}
						} = s, e.push({
							index: i,
							box: s,
							pos: o,
							horizontal: s.isHorizontal(),
							weight: s.weight,
							stack: r && o + r,
							stackWeight: a
						});
						return e
					}(t),
						i = on(e.filter(t => t.box.fullSize), !0),
						n = on(nn(e, "left"), !0),
						s = on(nn(e, "right")),
						o = on(nn(e, "top"), !0),
						r = on(nn(e, "bottom")),
						a = sn(e, "x"),
						l = sn(e, "y");
					return {
						fullSize: i,
						leftAndTop: n.concat(o),
						rightAndBottom: s.concat(l).concat(r).concat(a),
						chartArea: nn(e, "chartArea"),
						vertical: n.concat(s).concat(l),
						horizontal: o.concat(r).concat(a)
					}
				}(i.boxes),
				l = a.vertical,
				h = a.horizontal;
			C(i.boxes, t => {
				"function" == typeof t.beforeLayout && t.beforeLayout()
			});
			const c = l.reduce((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1,
				u = Object.freeze({
					outerWidth: t,
					outerHeight: e,
					padding: s,
					availableWidth: o,
					availableHeight: r,
					vBoxMaxWidth: o / 2 / c,
					hBoxMaxHeight: r / 2
				}),
				d = Object.assign({}, s);
			ln(d, R(n));
			const f = Object.assign({
				maxPadding: d,
				w: o,
				h: r,
				x: s.left,
				y: s.top
			}, s),
				p = rn(l.concat(h), u);
			un(a.fullSize, f, u, p), un(l, f, u, p), un(h, f, u, p) && un(l, f, u, p),
				function (i) {
					const n = i.maxPadding;

					function t(t) {
						const e = Math.max(n[t] - i[t], 0);
						return i[t] += e, e
					}
					i.y += t("top"), i.x += t("left"), t("right"), t("bottom")
				}(f), fn(a.leftAndTop, f, u, p), f.x += f.w, f.y += f.h, fn(a.rightAndBottom, f, u, p), i.chartArea = {
					left: f.left,
					top: f.top,
					right: f.left + f.w,
					bottom: f.top + f.h,
					height: f.h,
					width: f.w
				}, C(a.chartArea, t => {
					const e = t.box;
					Object.assign(e, i.chartArea), e.update(f.w, f.h, {
						left: 0,
						top: 0,
						right: 0,
						bottom: 0
					})
				})
		}
	};
	class pn {
		acquireContext(t, e) { }
		releaseContext(t) {
			return !1
		}
		addEventListener(t, e, i) { }
		removeEventListener(t, e, i) { }
		getDevicePixelRatio() {
			return 1
		}
		getMaximumSize(t, e, i, n) {
			return e = Math.max(0, e || t.width), i = i || t.height, {
				width: e,
				height: Math.max(0, n ? Math.floor(e / n) : i)
			}
		}
		isAttached(t) {
			return !0
		}
		updateConfig(t) { }
	}
	class gn extends pn {
		acquireContext(t) {
			return t && t.getContext && t.getContext("2d") || null
		}
		updateConfig(t) {
			t.options.animation = !1
		}
	}
	const mn = "$chartjs",
		vn = {
			touchstart: "mousedown",
			touchmove: "mousemove",
			touchend: "mouseup",
			pointerenter: "mouseenter",
			pointerdown: "mousedown",
			pointermove: "mousemove",
			pointerup: "mouseup",
			pointerleave: "mouseout",
			pointerout: "mouseout"
		},
		bn = t => null === t || "" === t;
	const _n = !!Ne && {
		passive: !0
	};

	function yn(t, e, i) {
		t.canvas.removeEventListener(e, i, _n)
	}

	function xn(e, i) {
		for (const t of e)
			if (t === i || t.contains(i)) return !0
	}

	function wn(t, e, i) {
		const n = t.canvas,
			s = new MutationObserver(t => {
				let e = !1;
				for (const i of t) e = e || xn(i.addedNodes, n), e = e && !xn(i.removedNodes, n);
				e && i()
			});
		return s.observe(document, {
			childList: !0,
			subtree: !0
		}), s
	}

	function kn(t, e, i) {
		const n = t.canvas,
			s = new MutationObserver(t => {
				let e = !1;
				for (const i of t) e = e || xn(i.removedNodes, n), e = e && !xn(i.addedNodes, n);
				e && i()
			});
		return s.observe(document, {
			childList: !0,
			subtree: !0
		}), s
	}
	const Cn = new Map;
	let Dn = 0;

	function Mn() {
		const i = window.devicePixelRatio;
		i !== Dn && (Dn = i, Cn.forEach((t, e) => {
			e.currentDevicePixelRatio !== i && t()
		}))
	}

	function Tn(t, e, n) {
		const i = t.canvas,
			s = i && Ce(i);
		if (!s) return;
		const o = Dt((t, e) => {
			const i = s.clientWidth;
			n(t, e), i < s.clientWidth && n()
		}, window),
			r = new ResizeObserver(t => {
				const e = t[0],
					i = e.contentRect.width,
					n = e.contentRect.height;
				0 === i && 0 === n || o(i, n)
			});
		return r.observe(s),
			function (t, e) {
				Cn.size || window.addEventListener("resize", Mn), Cn.set(t, e)
			}(t, o), r
	}

	function Sn(t, e, i) {
		i && i.disconnect(), "resize" === e && function (t) {
			Cn.delete(t), Cn.size || window.removeEventListener("resize", Mn)
		}(t)
	}

	function Pn(e, t, i) {
		const n = e.canvas,
			s = Dt(t => {
				null !== e.ctx && i(function (t, e) {
					const i = vn[t.type] || t.type,
						{
							x: n,
							y: s
						} = Ee(t, e);
					return {
						type: i,
						chart: e,
						native: t,
						x: void 0 !== n ? n : null,
						y: void 0 !== s ? s : null
					}
				}(t, e))
			}, e);
		return function (t, e, i) {
			t.addEventListener(e, i, _n)
		}(n, t, s), s
	}
	class In extends pn {
		acquireContext(t, e) {
			const i = t && t.getContext && t.getContext("2d");
			return i && i.canvas === t ? (function (t, e) {
				const i = t.style,
					n = t.getAttribute("height"),
					s = t.getAttribute("width");
				if (t[mn] = {
					initial: {
						height: n,
						width: s,
						style: {
							display: i.display,
							height: i.height,
							width: i.width
						}
					}
				}, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", bn(s)) {
					const e = Re(t, "width");
					void 0 !== e && (t.width = e)
				}
				if (bn(n))
					if ("" === t.style.height) t.height = t.width / (e || 2);
					else {
						const e = Re(t, "height");
						void 0 !== e && (t.height = e)
					}
			}(t, e), i) : null
		}
		releaseContext(t) {
			const i = t.canvas;
			if (!i[mn]) return !1;
			const n = i[mn].initial;
			["height", "width"].forEach(t => {
				const e = n[t];
				T(e) ? i.removeAttribute(t) : i.setAttribute(t, e)
			});
			const e = n.style || {};
			return Object.keys(e).forEach(t => {
				i.style[t] = e[t]
			}), i.width = i.width, delete i[mn], !0
		}
		addEventListener(t, e, i) {
			this.removeEventListener(t, e);
			const n = t.$proxies || (t.$proxies = {}),
				s = {
					attach: wn,
					detach: kn,
					resize: Tn
				}[e] || Pn;
			n[e] = s(t, e, i)
		}
		removeEventListener(t, e) {
			const i = t.$proxies || (t.$proxies = {}),
				n = i[e];
			if (!n) return;
			({
				attach: Sn,
				detach: Sn,
				resize: Sn
			}[e] || yn)(t, e, n), i[e] = void 0
		}
		getDevicePixelRatio() {
			return window.devicePixelRatio
		}
		getMaximumSize(t, e, i, n) {
			return Ae(t, e, i, n)
		}
		isAttached(t) {
			const e = Ce(t);
			return !(!e || !e.isConnected)
		}
	}

	function En(t) {
		return !ke() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? gn : In
	}
	var On = Object.freeze({
		__proto__: null,
		BasePlatform: pn,
		BasicPlatform: gn,
		DomPlatform: In,
		_detectPlatform: En
	});
	const An = "transparent",
		Ln = {
			boolean: (t, e, i) => i > .5 ? e : t,
			color(t, e, i) {
				const n = ce(t || An),
					s = n.valid && ce(e || An);
				return s && s.valid ? s.mix(n, i).hexString() : e
			},
			number: (t, e, i) => t + (e - t) * i
		};
	class Nn {
		constructor(t, e, i, n) {
			const s = e[i];
			n = Ai([t.to, n, s, t.from]);
			const o = Ai([t.from, s, n]);
			this._active = !0, this._fn = t.fn || Ln[t.type || typeof o], this._easing = wi[t.easing] || wi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = n, this._promises = void 0
		}
		active() {
			return this._active
		}
		update(n, s, o) {
			if (this._active) {
				this._notify(!1);
				const t = this._target[this._prop],
					e = o - this._start,
					i = this._duration - e;
				this._start = o, this._duration = Math.floor(Math.max(i, n.duration)), this._total += e, this._loop = !!n.loop, this._to = Ai([n.to, s, t, n.from]), this._from = Ai([n.from, t, s])
			}
		}
		cancel() {
			this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
		}
		tick(t) {
			const e = t - this._start,
				i = this._duration,
				n = this._prop,
				s = this._from,
				o = this._loop,
				r = this._to;
			let a;
			if (this._active = s !== r && (o || e < i), !this._active) return this._target[n] = r, void this._notify(!0);
			e < 0 ? this._target[n] = s : (a = e / i % 2, a = o && a > 1 ? 2 - a : a, a = this._easing(Math.min(1, Math.max(0, a))), this._target[n] = this._fn(s, r, a))
		}
		wait() {
			const i = this._promises || (this._promises = []);
			return new Promise((t, e) => {
				i.push({
					res: t,
					rej: e
				})
			})
		}
		_notify(t) {
			const e = t ? "res" : "rej",
				i = this._promises || [];
			for (let t = 0; t < i.length; t++) i[t][e]()
		}
	}
	class Rn {
		constructor(t, e) {
			this._chart = t, this._properties = new Map, this.configure(e)
		}
		configure(n) {
			if (!E(n)) return;
			const s = Object.keys(S.animation),
				o = this._properties;
			Object.getOwnPropertyNames(n).forEach(e => {
				const t = n[e];
				if (!E(t)) return;
				const i = {};
				for (const n of s) i[n] = t[n];
				(I(t.properties) && t.properties || [e]).forEach(t => {
					t !== e && o.has(t) || o.set(t, i)
				})
			})
		}
		_animateOptions(t, e) {
			const i = e.options,
				n = function (t, e) {
					if (!e) return;
					let i = t.options;
					if (!i) return void (t.options = e);
					i.$shared && (t.options = i = Object.assign({}, i, {
						$shared: !1,
						$animations: {}
					}));
					return i
				}(t, i);
			if (!n) return [];
			const s = this._createAnimations(n, i);
			return i.$shared && function (i, t) {
				const n = [],
					s = Object.keys(t);
				for (let e = 0; e < s.length; e++) {
					const t = i[s[e]];
					t && t.active() && n.push(t.wait())
				}
				return Promise.all(n)
			}(t.options.$animations, i).then(() => {
				t.options = i
			}, () => { }), s
		}
		_createAnimations(s, o) {
			const r = this._properties,
				a = [],
				l = s.$animations || (s.$animations = {}),
				h = Object.keys(o),
				c = Date.now();
			let u;
			for (u = h.length - 1; u >= 0; --u) {
				const t = h[u];
				if ("$" === t.charAt(0)) continue;
				if ("options" === t) {
					a.push(...this._animateOptions(s, o));
					continue
				}
				const e = o[t];
				let i = l[t];
				const n = r.get(t);
				if (i) {
					if (n && i.active()) {
						i.update(n, e, c);
						continue
					}
					i.cancel()
				}
				n && n.duration ? (l[t] = i = new Nn(n, s, t, e), a.push(i)) : s[t] = e
			}
			return a
		}
		update(t, e) {
			if (0 === this._properties.size) return void Object.assign(t, e);
			const i = this._createAnimations(t, e);
			return i.length ? (c.add(this._chart, i), !0) : void 0
		}
	}

	function Fn(t, e) {
		const i = t && t.options || {},
			n = i.reverse,
			s = void 0 === i.min ? e : 0,
			o = void 0 === i.max ? e : 0;
		return {
			start: n ? o : s,
			end: n ? s : o
		}
	}

	function Hn(t, e) {
		const i = [],
			n = t._getSortedDatasetMetas(e);
		let s, o;
		for (s = 0, o = n.length; s < o; ++s) i.push(n[s].index);
		return i
	}

	function zn(t, e, i, n = {}) {
		const s = t.keys,
			o = "single" === n.mode;
		let r, a, l, h;
		if (null !== e) {
			for (r = 0, a = s.length; r < a; ++r) {
				if (l = +s[r], l === i) {
					if (n.all) continue;
					break
				}
				h = t.values[l], p(h) && (o || 0 === e || v(e) === v(h)) && (e += h)
			}
			return e
		}
	}

	function Wn(t, e) {
		const i = t && t.options.stacked;
		return i || void 0 === i && void 0 !== e.stack
	}

	function Bn(t, e, i) {
		const n = t[e] || (t[e] = {});
		return n[i] || (n[i] = {})
	}

	function jn(e, i, n, s) {
		for (const t of i.getMatchingVisibleMetas(s).reverse()) {
			const i = e[t.index];
			if (n && i > 0 || !n && i < 0) return t.index
		}
		return null
	}

	function Yn(t, e) {
		const {
			chart: i,
			_cachedMeta: n
		} = t, s = i._stacks || (i._stacks = {}), {
			iScale: o,
			vScale: r,
			index: a
		} = n, l = o.axis, h = r.axis, c = function (t, e, i) {
			return `${t.id}.${e.id}.${i.stack || i.type}`
		}(o, r, n), u = e.length;
		let d;
		for (let t = 0; t < u; ++t) {
			const i = e[t],
				{
					[l]: o, [h]: u
				} = i;
			d = (i._stacks || (i._stacks = {}))[h] = Bn(s, c, o), d[a] = u, d._top = jn(d, r, !0, n.type), d._bottom = jn(d, r, !1, n.type);
			(d._visualValues || (d._visualValues = {}))[a] = u
		}
	}

	function Vn(t, e) {
		const i = t.scales;
		return Object.keys(i).filter(t => i[t].axis === e).shift()
	}

	function $n(t, e) {
		const i = t.controller.index,
			n = t.vScale && t.vScale.axis;
		if (n) {
			e = e || t._parsed;
			for (const t of e) {
				const e = t._stacks;
				if (!e || void 0 === e[n] || void 0 === e[n][i]) return;
				delete e[n][i], void 0 !== e[n]._visualValues && void 0 !== e[n]._visualValues[i] && delete e[n]._visualValues[i]
			}
		}
	}
	const Un = t => "reset" === t || "none" === t,
		qn = (t, e) => e ? t : Object.assign({}, t);
	class Gn {
		static defaults = {};
		static datasetElementType = null;
		static dataElementType = null;
		constructor(t, e) {
			this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize()
		}
		initialize() {
			const t = this._cachedMeta;
			this.configure(), this.linkScales(), t._stacked = Wn(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")
		}
		updateIndex(t) {
			this.index !== t && $n(this._cachedMeta), this.index = t
		}
		linkScales() {
			const t = this.chart,
				e = this._cachedMeta,
				i = this.getDataset(),
				n = (t, e, i, n) => "x" === t ? e : "r" === t ? n : i,
				s = e.xAxisID = O(i.xAxisID, Vn(t, "x")),
				o = e.yAxisID = O(i.yAxisID, Vn(t, "y")),
				r = e.rAxisID = O(i.rAxisID, Vn(t, "r")),
				a = e.indexAxis,
				l = e.iAxisID = n(a, s, o, r),
				h = e.vAxisID = n(a, o, s, r);
			e.xScale = this.getScaleForId(s), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(r), e.iScale = this.getScaleForId(l), e.vScale = this.getScaleForId(h)
		}
		getDataset() {
			return this.chart.data.datasets[this.index]
		}
		getMeta() {
			return this.chart.getDatasetMeta(this.index)
		}
		getScaleForId(t) {
			return this.chart.scales[t]
		}
		_getOtherScale(t) {
			const e = this._cachedMeta;
			return t === e.iScale ? e.vScale : e.iScale
		}
		reset() {
			this._update("reset")
		}
		_destroy() {
			const t = this._cachedMeta;
			this._data && wt(this._data, this), t._stacked && $n(t)
		}
		_dataCheck() {
			const t = this.getDataset(),
				e = t.data || (t.data = []),
				i = this._data;
			if (E(e)) this._data = function (t) {
				const e = Object.keys(t),
					i = new Array(e.length);
				let n, s, o;
				for (n = 0, s = e.length; n < s; ++n) o = e[n], i[n] = {
					x: o,
					y: t[o]
				};
				return i
			}(e);
			else if (i !== e) {
				if (i) {
					wt(i, this);
					const t = this._cachedMeta;
					$n(t), t._parsed = []
				}
				e && Object.isExtensible(e) && xt(e, this), this._syncList = [], this._data = e
			}
		}
		addElements() {
			const t = this._cachedMeta;
			this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType)
		}
		buildOrUpdateElements(t) {
			const e = this._cachedMeta,
				i = this.getDataset();
			let n = !1;
			this._dataCheck();
			const s = e._stacked;
			e._stacked = Wn(e.vScale, e), e.stack !== i.stack && (n = !0, $n(e), e.stack = i.stack), this._resyncElements(t), (n || s !== e._stacked) && Yn(this, e._parsed)
		}
		configure() {
			const t = this.chart.config,
				e = t.datasetScopeKeys(this._type),
				i = t.getOptionScopes(this.getDataset(), e, !0);
			this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}
		}
		parse(t, e) {
			const {
				_cachedMeta: i,
				_data: n
			} = this, {
				iScale: s,
				_stacked: o
			} = i, r = s.axis;
			let a, l, h, c = 0 === t && e === n.length || i._sorted,
				u = t > 0 && i._parsed[t - 1];
			if (!1 === this._parsing) i._parsed = n, i._sorted = !0, h = n;
			else {
				h = I(n[t]) ? this.parseArrayData(i, n, t, e) : E(n[t]) ? this.parseObjectData(i, n, t, e) : this.parsePrimitiveData(i, n, t, e);
				const s = () => null === l[r] || u && l[r] < u[r];
				for (a = 0; a < e; ++a) i._parsed[a + t] = l = h[a], c && (s() && (c = !1), u = l);
				i._sorted = c
			}
			o && Yn(this, h)
		}
		parsePrimitiveData(t, e, i, n) {
			const {
				iScale: s,
				vScale: o
			} = t, r = s.axis, a = o.axis, l = s.getLabels(), h = s === o, c = new Array(n);
			let u, d, f;
			for (u = 0, d = n; u < d; ++u) f = u + i, c[u] = {
				[r]: h || s.parse(l[f], f), [a]: o.parse(e[f], f)
			};
			return c
		}
		parseArrayData(t, e, i, n) {
			const {
				xScale: s,
				yScale: o
			} = t, r = new Array(n);
			let a, l, h, c;
			for (a = 0, l = n; a < l; ++a) h = a + i, c = e[h], r[a] = {
				x: s.parse(c[0], h),
				y: o.parse(c[1], h)
			};
			return r
		}
		parseObjectData(t, e, i, n) {
			const {
				xScale: s,
				yScale: o
			} = t, {
				xAxisKey: r = "x",
				yAxisKey: a = "y"
			} = this._parsing, l = new Array(n);
			let h, c, u, d;
			for (h = 0, c = n; h < c; ++h) u = h + i, d = e[u], l[h] = {
				x: s.parse(m(d, r), u),
				y: o.parse(m(d, a), u)
			};
			return l
		}
		getParsed(t) {
			return this._cachedMeta._parsed[t]
		}
		getDataElement(t) {
			return this._cachedMeta.data[t]
		}
		applyStack(t, e, i) {
			const n = this.chart,
				s = this._cachedMeta,
				o = e[t.axis];
			return zn({
				keys: Hn(n, !0),
				values: e._stacks[t.axis]._visualValues
			}, o, s.index, {
				mode: i
			})
		}
		updateRangeFromParsed(t, e, i, n) {
			const s = i[e.axis];
			let o = null === s ? NaN : s;
			const r = n && i._stacks[e.axis];
			n && r && (n.values = r, o = zn(n, s, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)
		}
		getMinMax(e, t) {
			const i = this._cachedMeta,
				n = i._parsed,
				s = i._sorted && e === i.iScale,
				o = n.length,
				r = this._getOtherScale(e),
				a = ((t, e, i) => t && !e.hidden && e._stacked && {
					keys: Hn(i, !0),
					values: null
				})(t, i, this.chart),
				l = {
					min: Number.POSITIVE_INFINITY,
					max: Number.NEGATIVE_INFINITY
				},
				{
					min: h,
					max: c
				} = function (t) {
					const {
						min: e,
						max: i,
						minDefined: n,
						maxDefined: s
					} = t.getUserBounds();
					return {
						min: n ? e : Number.NEGATIVE_INFINITY,
						max: s ? i : Number.POSITIVE_INFINITY
					}
				}(r);
			let u, d;

			function f() {
				d = n[u];
				const t = d[r.axis];
				return !p(d[e.axis]) || h > t || c < t
			}
			for (u = 0; u < o && (f() || (this.updateRangeFromParsed(l, e, d, a), !s)); ++u);
			if (s)
				for (u = o - 1; u >= 0; --u)
					if (!f()) {
						this.updateRangeFromParsed(l, e, d, a);
						break
					}
			return l
		}
		getAllParsedValues(t) {
			const e = this._cachedMeta._parsed,
				i = [];
			let n, s, o;
			for (n = 0, s = e.length; n < s; ++n) o = e[n][t.axis], p(o) && i.push(o);
			return i
		}
		getMaxOverflow() {
			return !1
		}
		getLabelAndValue(t) {
			const e = this._cachedMeta,
				i = e.iScale,
				n = e.vScale,
				s = this.getParsed(t);
			return {
				label: i ? "" + i.getLabelForValue(s[i.axis]) : "",
				value: n ? "" + n.getLabelForValue(s[n.axis]) : ""
			}
		}
		_update(t) {
			const e = this._cachedMeta;
			this.update(t || "default"), e._clip = function (t) {
				let e, i, n, s;
				return E(t) ? (e = t.top, i = t.right, n = t.bottom, s = t.left) : e = i = n = s = t, {
					top: e,
					right: i,
					bottom: n,
					left: s,
					disabled: !1 === t
				}
			}(O(this.options.clip, function (t, e, i) {
				if (!1 === i) return !1;
				const n = Fn(t, i),
					s = Fn(e, i);
				return {
					top: s.end,
					right: n.end,
					bottom: s.start,
					left: n.start
				}
			}(e.xScale, e.yScale, this.getMaxOverflow())))
		}
		update(t) { }
		draw() {
			const t = this._ctx,
				e = this.chart,
				i = this._cachedMeta,
				n = i.data || [],
				s = e.chartArea,
				o = [],
				r = this._drawStart || 0,
				a = this._drawCount || n.length - r,
				l = this.options.drawActiveElementsOnTop;
			let h;
			for (i.dataset && i.dataset.draw(t, s, r, a), h = r; h < r + a; ++h) {
				const e = n[h];
				e.hidden || (e.active && l ? o.push(e) : e.draw(t, s))
			}
			for (h = 0; h < o.length; ++h) o[h].draw(t, s)
		}
		getStyle(t, e) {
			const i = e ? "active" : "default";
			return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i)
		}
		getContext(t, e, i) {
			const n = this.getDataset();
			let s;
			if (t >= 0 && t < this._cachedMeta.data.length) {
				const e = this._cachedMeta.data[t];
				s = e.$context || (e.$context = function (t, e, i) {
					return Ni(t, {
						active: !1,
						dataIndex: e,
						parsed: void 0,
						raw: void 0,
						element: i,
						index: e,
						mode: "default",
						type: "data"
					})
				}(this.getContext(), t, e)), s.parsed = this.getParsed(t), s.raw = n.data[t], s.index = s.dataIndex = t
			} else s = this.$context || (this.$context = function (t, e) {
				return Ni(t, {
					active: !1,
					dataset: void 0,
					datasetIndex: e,
					index: e,
					mode: "default",
					type: "dataset"
				})
			}(this.chart.getContext(), this.index)), s.dataset = n, s.index = s.datasetIndex = this.index;
			return s.active = !!e, s.mode = i, s
		}
		resolveDatasetElementOptions(t) {
			return this._resolveElementOptions(this.datasetElementType.id, t)
		}
		resolveDataElementOptions(t, e) {
			return this._resolveElementOptions(this.dataElementType.id, e, t)
		}
		_resolveElementOptions(t, e = "default", i) {
			const n = "active" === e,
				s = this._cachedDataOpts,
				o = t + "-" + e,
				r = s[o],
				a = this.enableOptionSharing && X(i);
			if (r) return qn(r, a);
			const l = this.chart.config,
				h = l.datasetElementScopeKeys(this._type, t),
				c = n ? [`${t}Hover`, "hover", t, ""] : [t, ""],
				u = l.getOptionScopes(this.getDataset(), h),
				d = Object.keys(S.elements[t]),
				f = l.resolveNamedOptions(u, d, () => this.getContext(i, n, e), c);
			return f.$shared && (f.$shared = a, s[o] = Object.freeze(qn(f, a))), f
		}
		_resolveAnimations(t, e, i) {
			const n = this.chart,
				s = this._cachedDataOpts,
				o = `animation-${e}`,
				r = s[o];
			if (r) return r;
			let a;
			if (!1 !== n.options.animation) {
				const n = this.chart.config,
					s = n.datasetAnimationScopeKeys(this._type, e),
					o = n.getOptionScopes(this.getDataset(), s);
				a = n.createResolver(o, this.getContext(t, i, e))
			}
			const l = new Rn(n, a && a.animations);
			return a && a._cacheable && (s[o] = Object.freeze(l)), l
		}
		getSharedOptions(t) {
			if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
		}
		includeOptions(t, e) {
			return !e || Un(t) || this.chart._animationsDisabled
		}
		_getSharedOptions(t, e) {
			const i = this.resolveDataElementOptions(t, e),
				n = this._sharedOptions,
				s = this.getSharedOptions(i),
				o = this.includeOptions(e, s) || s !== n;
			return this.updateSharedOptions(s, e, i), {
				sharedOptions: s,
				includeOptions: o
			}
		}
		updateElement(t, e, i, n) {
			Un(n) ? Object.assign(t, i) : this._resolveAnimations(e, n).update(t, i)
		}
		updateSharedOptions(t, e, i) {
			t && !Un(e) && this._resolveAnimations(void 0, e).update(t, i)
		}
		_setStyle(t, e, i, n) {
			t.active = n;
			const s = this.getStyle(e, n);
			this._resolveAnimations(e, i, n).update(t, {
				options: !n && this.getSharedOptions(s) || s
			})
		}
		removeHoverStyle(t, e, i) {
			this._setStyle(t, i, "active", !1)
		}
		setHoverStyle(t, e, i) {
			this._setStyle(t, i, "active", !0)
		}
		_removeDatasetHoverStyle() {
			const t = this._cachedMeta.dataset;
			t && this._setStyle(t, void 0, "active", !1)
		}
		_setDatasetHoverStyle() {
			const t = this._cachedMeta.dataset;
			t && this._setStyle(t, void 0, "active", !0)
		}
		_resyncElements(t) {
			const e = this._data,
				i = this._cachedMeta.data;
			for (const [t, e, i] of this._syncList) this[t](e, i);
			this._syncList = [];
			const n = i.length,
				s = e.length,
				o = Math.min(s, n);
			o && this.parse(0, o), s > n ? this._insertElements(n, s - n, t) : s < n && this._removeElements(s, n - s)
		}
		_insertElements(t, e, i = !0) {
			const n = this._cachedMeta,
				s = n.data,
				o = t + e;
			let r;
			const a = t => {
				for (t.length += e, r = t.length - 1; r >= o; r--) t[r] = t[r - e]
			};
			for (a(s), r = t; r < o; ++r) s[r] = new this.dataElementType;
			this._parsing && a(n._parsed), this.parse(t, e), i && this.updateElements(s, t, e, "reset")
		}
		updateElements(t, e, i, n) { }
		_removeElements(e, i) {
			const n = this._cachedMeta;
			if (this._parsing) {
				const t = n._parsed.splice(e, i);
				n._stacked && $n(n, t)
			}
			n.data.splice(e, i)
		}
		_sync(n) {
			if (this._parsing) this._syncList.push(n);
			else {
				const [t, e, i] = n;
				this[t](e, i)
			}
			this.chart._dataChanges.push([this.index, ...n])
		}
		_onDataPush() {
			const t = arguments.length;
			this._sync(["_insertElements", this.getDataset().data.length - t, t])
		}
		_onDataPop() {
			this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
		}
		_onDataShift() {
			this._sync(["_removeElements", 0, 1])
		}
		_onDataSplice(t, e) {
			e && this._sync(["_removeElements", t, e]);
			const i = arguments.length - 2;
			i && this._sync(["_insertElements", t, i])
		}
		_onDataUnshift() {
			this._sync(["_insertElements", 0, arguments.length])
		}
	}
	class e {
		static defaults = {};
		static defaultRoutes = void 0;
		x;
		y;
		active = !1;
		options;
		$animations;
		tooltipPosition(t) {
			const {
				x: e,
				y: i
			} = this.getProps(["x", "y"], t);
			return {
				x: e,
				y: i
			}
		}
		hasValue() {
			return at(this.x) && at(this.y)
		}
		getProps(t, e) {
			const i = this.$animations;
			if (!e || !i) return this;
			const n = {};
			return t.forEach(t => {
				n[t] = i[t] && i[t].active() ? i[t]._to : this[t]
			}), n
		}
	}

	function Kn(t, i) {
		const e = t.options.ticks,
			n = function (t) {
				const e = t.options.offset,
					i = t._tickSize(),
					n = t._length / i + (e ? 0 : 1),
					s = t._maxLength / i;
				return Math.floor(Math.min(n, s))
			}(t),
			s = Math.min(e.maxTicksLimit || n, n),
			o = e.major.enabled ? function (t) {
				const e = [];
				let i, n;
				for (i = 0, n = t.length; i < n; i++) t[i].major && e.push(i);
				return e
			}(i) : [],
			r = o.length,
			a = o[0],
			l = o[r - 1],
			h = [];
		if (r > s) return function (t, e, i, n) {
			let s, o = 0,
				r = i[0];
			for (n = Math.ceil(n), s = 0; s < t.length; s++) s === r && (e.push(t[s]), o++, r = i[o * n])
		}(i, h, o, r / s), h;
		const c = function (t, i, e) {
			const n = function (t) {
				const e = t.length;
				let i, n;
				if (e < 2) return !1;
				for (n = t[0], i = 1; i < e; ++i)
					if (t[i] - t[i - 1] !== n) return !1;
				return n
			}(t),
				s = i.length / e;
			if (!n) return Math.max(s, 1);
			const o = rt(n);
			for (let t = 0, e = o.length - 1; t < e; t++) {
				const i = o[t];
				if (i > s) return i
			}
			return Math.max(s, 1)
		}(o, i, s);
		if (r > 0) {
			let t, e;
			const n = r > 1 ? Math.round((l - a) / (r - 1)) : null;
			for (Xn(i, h, c, T(n) ? 0 : a - n, a), t = 0, e = r - 1; t < e; t++) Xn(i, h, c, o[t], o[t + 1]);
			return Xn(i, h, c, l, T(n) ? i.length : l + n), h
		}
		return Xn(i, h, c), h
	}

	function Xn(t, e, i, n, s) {
		const o = O(n, 0),
			r = Math.min(O(s, t.length), t.length);
		let a, l, h, c = 0;
		for (i = Math.ceil(i), s && (a = s - n, i = a / Math.floor(a / i)), h = o; h < 0;) c++, h = Math.round(o + c * i);
		for (l = Math.max(o, 0); l < r; l++) l === h && (e.push(t[l]), c++, h = Math.round(o + c * i))
	}
	const Zn = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i,
		Qn = (t, e) => Math.min(e || t, t);

	function Jn(t, e) {
		const i = [],
			n = t.length / e,
			s = t.length;
		let o = 0;
		for (; o < s; o += n) i.push(t[Math.floor(o)]);
		return i
	}

	function ts(t, e, i) {
		const n = t.ticks.length,
			s = Math.min(e, n - 1),
			o = t._startPixel,
			r = t._endPixel,
			a = 1e-6;
		let l, h = t.getPixelForTick(s);
		if (!(i && (l = 1 === n ? Math.max(h - o, r - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(s - 1)) / 2, h += s < e ? l : -l, h < o - a || h > r + a))) return h
	}

	function es(t) {
		return t.drawTicks ? t.tickLength : 0
	}

	function is(t, e) {
		if (!t.display) return 0;
		const i = P(t.font, e),
			n = R(t.padding);
		return (I(t.text) ? t.text.length : 1) * i.lineHeight + n.height
	}

	function ns(t, e, i) {
		let n = Tt(t);
		return (i && "right" !== e || !i && "right" === e) && (n = (t => "left" === t ? "right" : "right" === t ? "left" : t)(n)), n
	}
	class ss extends e {
		constructor(t) {
			super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
				left: 0,
				right: 0,
				top: 0,
				bottom: 0
			}, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
		}
		init(t) {
			this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax)
		}
		parse(t, e) {
			return t
		}
		getUserBounds() {
			let {
				_userMin: t,
				_userMax: e,
				_suggestedMin: i,
				_suggestedMax: n
			} = this;
			return t = g(t, Number.POSITIVE_INFINITY), e = g(e, Number.NEGATIVE_INFINITY), i = g(i, Number.POSITIVE_INFINITY), n = g(n, Number.NEGATIVE_INFINITY), {
				min: g(t, i),
				max: g(e, n),
				minDefined: p(t),
				maxDefined: p(e)
			}
		}
		getMinMax(i) {
			let n, {
				min: s,
				max: o,
				minDefined: r,
				maxDefined: a
			} = this.getUserBounds();
			if (r && a) return {
				min: s,
				max: o
			};
			const l = this.getMatchingVisibleMetas();
			for (let t = 0, e = l.length; t < e; ++t) n = l[t].controller.getMinMax(this, i), r || (s = Math.min(s, n.min)), a || (o = Math.max(o, n.max));
			return s = a && s > o ? o : s, o = r && s > o ? s : o, {
				min: g(s, g(o, s)),
				max: g(o, g(s, o))
			}
		}
		getPadding() {
			return {
				left: this.paddingLeft || 0,
				top: this.paddingTop || 0,
				right: this.paddingRight || 0,
				bottom: this.paddingBottom || 0
			}
		}
		getTicks() {
			return this.ticks
		}
		getLabels() {
			const t = this.chart.data;
			return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
		}
		getLabelItems(t = this.chart.chartArea) {
			return this._labelItems || (this._labelItems = this._computeLabelItems(t))
		}
		beforeLayout() {
			this._cache = {}, this._dataLimitsCached = !1
		}
		beforeUpdate() {
			f(this.options.beforeUpdate, [this])
		}
		update(t, e, i) {
			const {
				beginAtZero: n,
				grace: s,
				ticks: o
			} = this.options, r = o.sampleSize;
			this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({
				left: 0,
				right: 0,
				top: 0,
				bottom: 0
			}, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Li(this, s, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
			const a = r < this.ticks.length;
			this._convertTicksToLabels(a ? Jn(this.ticks, r) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = Kn(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), a && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
		}
		configure() {
			let t, e, i = this.options.reverse;
			this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels
		}
		afterUpdate() {
			f(this.options.afterUpdate, [this])
		}
		beforeSetDimensions() {
			f(this.options.beforeSetDimensions, [this])
		}
		setDimensions() {
			this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
		}
		afterSetDimensions() {
			f(this.options.afterSetDimensions, [this])
		}
		_callHooks(t) {
			this.chart.notifyPlugins(t, this.getContext()), f(this.options[t], [this])
		}
		beforeDataLimits() {
			this._callHooks("beforeDataLimits")
		}
		determineDataLimits() { }
		afterDataLimits() {
			this._callHooks("afterDataLimits")
		}
		beforeBuildTicks() {
			this._callHooks("beforeBuildTicks")
		}
		buildTicks() {
			return []
		}
		afterBuildTicks() {
			this._callHooks("afterBuildTicks")
		}
		beforeTickToLabelConversion() {
			f(this.options.beforeTickToLabelConversion, [this])
		}
		generateTickLabels(t) {
			const e = this.options.ticks;
			let i, n, s;
			for (i = 0, n = t.length; i < n; i++) s = t[i], s.label = f(e.callback, [s.value, i, t], this)
		}
		afterTickToLabelConversion() {
			f(this.options.afterTickToLabelConversion, [this])
		}
		beforeCalculateLabelRotation() {
			f(this.options.beforeCalculateLabelRotation, [this])
		}
		calculateLabelRotation() {
			const t = this.options,
				e = t.ticks,
				i = Qn(this.ticks.length, t.ticks.maxTicksLimit),
				n = e.minRotation || 0,
				s = e.maxRotation;
			let o, r, a, l = n;
			if (!this._isVisible() || !e.display || n >= s || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = n);
			const h = this._getLabelSizes(),
				c = h.widest.width,
				u = h.highest.height,
				d = _(this.chart.width - c, 0, this.maxWidth);
			o = t.offset ? this.maxWidth / i : d / (i - 1), c + 6 > o && (o = d / (i - (t.offset ? .5 : 1)), r = this.maxHeight - es(t.grid) - e.padding - is(t.title, this.chart.options.font), a = Math.sqrt(c * c + u * u), l = ct(Math.min(Math.asin(_((h.highest.height + 6) / o, -1, 1)), Math.asin(_(r / a, -1, 1)) - Math.asin(_(u / a, -1, 1)))), l = Math.max(n, Math.min(s, l))), this.labelRotation = l
		}
		afterCalculateLabelRotation() {
			f(this.options.afterCalculateLabelRotation, [this])
		}
		afterAutoSkip() { }
		beforeFit() {
			f(this.options.beforeFit, [this])
		}
		fit() {
			const s = {
				width: 0,
				height: 0
			},
				{
					chart: o,
					options: {
						ticks: r,
						title: a,
						grid: l
					}
				} = this,
				h = this._isVisible(),
				c = this.isHorizontal();
			if (h) {
				const h = is(a, o.options.font);
				if (c ? (s.width = this.maxWidth, s.height = es(l) + h) : (s.height = this.maxHeight, s.width = es(l) + h), r.display && this.ticks.length) {
					const {
						first: o,
						last: a,
						widest: l,
						highest: h
					} = this._getLabelSizes(), t = 2 * r.padding, e = N(this.labelRotation), i = Math.cos(e), n = Math.sin(e);
					if (c) {
						const o = r.mirror ? 0 : n * l.width + i * h.height;
						s.height = Math.min(this.maxHeight, s.height + o + t)
					} else {
						const o = r.mirror ? 0 : i * l.width + n * h.height;
						s.width = Math.min(this.maxWidth, s.width + o + t)
					}
					this._calculatePadding(o, a, n, i)
				}
			}
			this._handleMargins(), c ? (this.width = this._length = o.width - this._margins.left - this._margins.right, this.height = s.height) : (this.width = s.width, this.height = this._length = o.height - this._margins.top - this._margins.bottom)
		}
		_calculatePadding(n, s, o, r) {
			const {
				ticks: {
					align: a,
					padding: l
				},
				position: h
			} = this.options, c = 0 !== this.labelRotation, u = "top" !== h && "x" === this.axis;
			if (this.isHorizontal()) {
				const h = this.getPixelForTick(0) - this.left,
					t = this.right - this.getPixelForTick(this.ticks.length - 1);
				let e = 0,
					i = 0;
				c ? u ? (e = r * n.width, i = o * s.height) : (e = o * n.height, i = r * s.width) : "start" === a ? i = s.width : "end" === a ? e = n.width : "inner" !== a && (e = n.width / 2, i = s.width / 2), this.paddingLeft = Math.max((e - h + l) * this.width / (this.width - h), 0), this.paddingRight = Math.max((i - t + l) * this.width / (this.width - t), 0)
			} else {
				let t = s.height / 2,
					e = n.height / 2;
				"start" === a ? (t = 0, e = n.height) : "end" === a && (t = s.height, e = 0), this.paddingTop = t + l, this.paddingBottom = e + l
			}
		}
		_handleMargins() {
			this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
		}
		afterFit() {
			f(this.options.afterFit, [this])
		}
		isHorizontal() {
			const {
				axis: t,
				position: e
			} = this.options;
			return "top" === e || "bottom" === e || "x" === t
		}
		isFullSize() {
			return this.options.fullSize
		}
		_convertTicksToLabels(t) {
			let e, i;
			for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++) T(t[e].label) && (t.splice(e, 1), i--, e--);
			this.afterTickToLabelConversion()
		}
		_getLabelSizes() {
			let i = this._labelSizes;
			if (!i) {
				const t = this.options.ticks.sampleSize;
				let e = this.ticks;
				t < e.length && (e = Jn(e, t)), this._labelSizes = i = this._computeLabelSizes(e, e.length, this.options.ticks.maxTicksLimit)
			}
			return i
		}
		_computeLabelSizes(t, e, i) {
			const {
				ctx: n,
				_longestTextCache: s
			} = this, o = [], r = [], a = Math.floor(e / Qn(e, i));
			let l, h, c, u, d, f, p, g, m, v, b, _ = 0,
				y = 0;
			for (l = 0; l < e; l += a) {
				if (u = t[l].label, d = this._resolveTickFontOptions(l), n.font = f = d.string, p = s[f] = s[f] || {
					data: {},
					gc: []
				}, g = d.lineHeight, m = v = 0, T(u) || I(u)) {
					if (I(u))
						for (h = 0, c = u.length; h < c; ++h) b = u[h], T(b) || I(b) || (m = He(n, p.data, p.gc, m, b), v += g)
				} else m = He(n, p.data, p.gc, m, u), v = g;
				o.push(m), r.push(v), _ = Math.max(m, _), y = Math.max(v, y)
			} ! function (t, s) {
				C(t, t => {
					const e = t.gc,
						i = e.length / 2;
					let n;
					if (i > s) {
						for (n = 0; n < i; ++n) delete t.data[e[n]];
						e.splice(0, i)
					}
				})
			}(s, e);
			const x = o.indexOf(_),
				w = r.indexOf(y),
				k = t => ({
					width: o[t] || 0,
					height: r[t] || 0
				});
			return {
				first: k(0),
				last: k(e - 1),
				widest: k(x),
				highest: k(w),
				widths: o,
				heights: r
			}
		}
		getLabelForValue(t) {
			return t
		}
		getPixelForValue(t, e) {
			return NaN
		}
		getValueForPixel(t) { }
		getPixelForTick(t) {
			const e = this.ticks;
			return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
		}
		getPixelForDecimal(t) {
			this._reversePixels && (t = 1 - t);
			const e = this._startPixel + t * this._length;
			return mt(this._alignToPixels ? We(this.chart, e, 0) : e)
		}
		getDecimalForPixel(t) {
			const e = (t - this._startPixel) / this._length;
			return this._reversePixels ? 1 - e : e
		}
		getBasePixel() {
			return this.getPixelForValue(this.getBaseValue())
		}
		getBaseValue() {
			const {
				min: t,
				max: e
			} = this;
			return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
		}
		getContext(e) {
			const i = this.ticks || [];
			if (e >= 0 && e < i.length) {
				const t = i[e];
				return t.$context || (t.$context = function (t, e, i) {
					return Ni(t, {
						tick: i,
						index: e,
						type: "tick"
					})
				}(this.getContext(), e, t))
			}
			return this.$context || (this.$context = Ni(this.chart.getContext(), {
				scale: this,
				type: "scale"
			}))
		}
		_tickSize() {
			const t = this.options.ticks,
				e = N(this.labelRotation),
				i = Math.abs(Math.cos(e)),
				n = Math.abs(Math.sin(e)),
				s = this._getLabelSizes(),
				o = t.autoSkipPadding || 0,
				r = s ? s.widest.width + o : 0,
				a = s ? s.highest.height + o : 0;
			return this.isHorizontal() ? a * i > r * n ? r / i : a / n : a * n < r * i ? a / i : r / n
		}
		_isVisible() {
			const t = this.options.display;
			return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0
		}
		_computeGridLineItems(t) {
			const e = this.axis,
				i = this.chart,
				n = this.options,
				{
					grid: s,
					position: o,
					border: r
				} = n,
				a = s.offset,
				l = this.isHorizontal(),
				h = this.ticks.length + (a ? 1 : 0),
				c = es(s),
				u = [],
				d = r.setContext(this.getContext()),
				f = d.display ? d.width : 0,
				p = f / 2,
				g = function (t) {
					return We(i, t, f)
				};
			let m, v, b, _, y, x, w, k, C, D, M, T;
			if ("top" === o) m = g(this.bottom), x = this.bottom - c, k = m - p, D = g(t.top) + p, T = t.bottom;
			else if ("bottom" === o) m = g(this.top), D = t.top, T = g(t.bottom) - p, x = m + p, k = this.top + c;
			else if ("left" === o) m = g(this.right), y = this.right - c, w = m - p, C = g(t.left) + p, M = t.right;
			else if ("right" === o) m = g(this.left), C = t.left, M = g(t.right) - p, y = m + p, w = this.left + c;
			else if ("x" === e) {
				if ("center" === o) m = g((t.top + t.bottom) / 2 + .5);
				else if (E(o)) {
					const t = Object.keys(o)[0],
						e = o[t];
					m = g(this.chart.scales[t].getPixelForValue(e))
				}
				D = t.top, T = t.bottom, x = m + p, k = x + c
			} else if ("y" === e) {
				if ("center" === o) m = g((t.left + t.right) / 2);
				else if (E(o)) {
					const t = Object.keys(o)[0],
						e = o[t];
					m = g(this.chart.scales[t].getPixelForValue(e))
				}
				y = m - p, w = y - c, C = t.left, M = t.right
			}
			const S = O(n.ticks.maxTicksLimit, h),
				P = Math.max(1, Math.ceil(h / S));
			for (v = 0; v < h; v += P) {
				const t = this.getContext(v),
					e = s.setContext(t),
					n = r.setContext(t),
					E = e.lineWidth,
					o = e.color,
					O = n.dash || [],
					h = n.dashOffset,
					c = e.tickWidth,
					d = e.tickColor,
					f = e.tickBorderDash || [],
					p = e.tickBorderDashOffset;
				b = ts(this, v, a), void 0 !== b && (_ = We(i, b, E), l ? y = w = C = M = _ : x = k = D = T = _, u.push({
					tx1: y,
					ty1: x,
					tx2: w,
					ty2: k,
					x1: C,
					y1: D,
					x2: M,
					y2: T,
					width: E,
					color: o,
					borderDash: O,
					borderDashOffset: h,
					tickWidth: c,
					tickColor: d,
					tickBorderDash: f,
					tickBorderDashOffset: p
				}))
			}
			return this._ticksLength = h, this._borderValue = m, u
		}
		_computeLabelItems(n) {
			const s = this.axis,
				o = this.options,
				{
					position: r,
					ticks: e
				} = o,
				a = this.isHorizontal(),
				l = this.ticks,
				{
					align: h,
					crossAlign: c,
					padding: t,
					mirror: u
				} = e,
				i = es(o.grid),
				d = i + t,
				f = u ? -t : d,
				p = -N(this.labelRotation),
				g = [];
			let m, v, b, _, y, x, w, k, C, D, M, T, S = "middle";
			if ("top" === r) x = this.bottom - f, w = this._getXAxisLabelAlignment();
			else if ("bottom" === r) x = this.top + f, w = this._getXAxisLabelAlignment();
			else if ("left" === r) {
				const n = this._getYAxisLabelAlignment(i);
				w = n.textAlign, y = n.x
			} else if ("right" === r) {
				const n = this._getYAxisLabelAlignment(i);
				w = n.textAlign, y = n.x
			} else if ("x" === s) {
				if ("center" === r) x = (n.top + n.bottom) / 2 + d;
				else if (E(r)) {
					const n = Object.keys(r)[0],
						s = r[n];
					x = this.chart.scales[n].getPixelForValue(s) + d
				}
				w = this._getXAxisLabelAlignment()
			} else if ("y" === s) {
				if ("center" === r) y = (n.left + n.right) / 2 - d;
				else if (E(r)) {
					const n = Object.keys(r)[0],
						s = r[n];
					y = this.chart.scales[n].getPixelForValue(s)
				}
				w = this._getYAxisLabelAlignment(i).textAlign
			}
			"y" === s && ("start" === h ? S = "top" : "end" === h && (S = "bottom"));
			const P = this._getLabelSizes();
			for (m = 0, v = l.length; m < v; ++m) {
				b = l[m], _ = b.label;
				const n = e.setContext(this.getContext(m));
				k = this.getPixelForTick(m) + e.labelOffset, C = this._resolveTickFontOptions(m), D = C.lineHeight, M = I(_) ? _.length : 1;
				const s = M / 2,
					o = n.color,
					E = n.textStrokeColor,
					h = n.textStrokeWidth;
				let i, t = w;
				if (a ? (y = k, "inner" === w && (t = m === v - 1 ? this.options.reverse ? "left" : "right" : 0 === m ? this.options.reverse ? "right" : "left" : "center"), T = "top" === r ? "near" === c || 0 !== p ? -M * D + D / 2 : "center" === c ? -P.highest.height / 2 - s * D + D : -P.highest.height + D / 2 : "near" === c || 0 !== p ? D / 2 : "center" === c ? P.highest.height / 2 - s * D : P.highest.height - M * D, u && (T *= -1), 0 === p || n.showLabelBackdrop || (y += D / 2 * Math.sin(p))) : (x = k, T = (1 - M) * D / 2), n.showLabelBackdrop) {
					const s = R(n.backdropPadding),
						o = P.heights[m],
						r = P.widths[m];
					let t = T - s.top,
						e = 0 - s.left;
					switch (S) {
						case "middle":
							t -= o / 2;
							break;
						case "bottom":
							t -= o
					}
					switch (w) {
						case "center":
							e -= r / 2;
							break;
						case "right":
							e -= r
					}
					i = {
						left: e,
						top: t,
						width: r + s.width,
						height: o + s.height,
						color: n.backdropColor
					}
				}
				g.push({
					label: _,
					font: C,
					textOffset: T,
					options: {
						rotation: p,
						color: o,
						strokeColor: E,
						strokeWidth: h,
						textAlign: t,
						textBaseline: S,
						translation: [y, x],
						backdrop: i
					}
				})
			}
			return g
		}
		_getXAxisLabelAlignment() {
			const {
				position: t,
				ticks: e
			} = this.options;
			if (-N(this.labelRotation)) return "top" === t ? "left" : "right";
			let i = "center";
			return "start" === e.align ? i = "left" : "end" === e.align ? i = "right" : "inner" === e.align && (i = "inner"), i
		}
		_getYAxisLabelAlignment(t) {
			const {
				position: e,
				ticks: {
					crossAlign: i,
					mirror: n,
					padding: s
				}
			} = this.options, o = t + s, r = this._getLabelSizes().widest.width;
			let a, l;
			return "left" === e ? n ? (l = this.right + s, "near" === i ? a = "left" : "center" === i ? (a = "center", l += r / 2) : (a = "right", l += r)) : (l = this.right - o, "near" === i ? a = "right" : "center" === i ? (a = "center", l -= r / 2) : (a = "left", l = this.left)) : "right" === e ? n ? (l = this.left + s, "near" === i ? a = "right" : "center" === i ? (a = "center", l -= r / 2) : (a = "left", l -= r)) : (l = this.left + o, "near" === i ? a = "left" : "center" === i ? (a = "center", l += r / 2) : (a = "right", l = this.right)) : a = "right", {
				textAlign: a,
				x: l
			}
		}
		_computeLabelArea() {
			if (this.options.ticks.mirror) return;
			const t = this.chart,
				e = this.options.position;
			return "left" === e || "right" === e ? {
				top: 0,
				left: this.left,
				bottom: t.height,
				right: this.right
			} : "top" === e || "bottom" === e ? {
				top: this.top,
				left: 0,
				bottom: this.bottom,
				right: t.width
			} : void 0
		}
		drawBackground() {
			const {
				ctx: t,
				options: {
					backgroundColor: e
				},
				left: i,
				top: n,
				width: s,
				height: o
			} = this;
			e && (t.save(), t.fillStyle = e, t.fillRect(i, n, s, o), t.restore())
		}
		getLineWidthForValue(e) {
			const t = this.options.grid;
			if (!this._isVisible() || !t.display) return 0;
			const i = this.ticks.findIndex(t => t.value === e);
			if (i >= 0) {
				return t.setContext(this.getContext(i)).lineWidth
			}
			return 0
		}
		drawGrid(t) {
			const e = this.options.grid,
				n = this.ctx,
				i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
			let s, o;
			const r = (t, e, i) => {
				i.width && i.color && (n.save(), n.lineWidth = i.width, n.strokeStyle = i.color, n.setLineDash(i.borderDash || []), n.lineDashOffset = i.borderDashOffset, n.beginPath(), n.moveTo(t.x, t.y), n.lineTo(e.x, e.y), n.stroke(), n.restore())
			};
			if (e.display)
				for (s = 0, o = i.length; s < o; ++s) {
					const t = i[s];
					e.drawOnChartArea && r({
						x: t.x1,
						y: t.y1
					}, {
						x: t.x2,
						y: t.y2
					}, t), e.drawTicks && r({
						x: t.tx1,
						y: t.ty1
					}, {
						x: t.tx2,
						y: t.ty2
					}, {
						color: t.tickColor,
						width: t.tickWidth,
						borderDash: t.tickBorderDash,
						borderDashOffset: t.tickBorderDashOffset
					})
				}
		}
		drawBorder() {
			const {
				chart: t,
				ctx: e,
				options: {
					border: i,
					grid: n
				}
			} = this, s = i.setContext(this.getContext()), o = i.display ? s.width : 0;
			if (!o) return;
			const r = n.setContext(this.getContext(0)).lineWidth,
				a = this._borderValue;
			let l, h, c, u;
			this.isHorizontal() ? (l = We(t, this.left, o) - o / 2, h = We(t, this.right, r) + r / 2, c = u = a) : (c = We(t, this.top, o) - o / 2, u = We(t, this.bottom, r) + r / 2, l = h = a), e.save(), e.lineWidth = s.width, e.strokeStyle = s.color, e.beginPath(), e.moveTo(l, c), e.lineTo(h, u), e.stroke(), e.restore()
		}
		drawLabels(t) {
			if (!this.options.ticks.display) return;
			const e = this.ctx,
				i = this._computeLabelArea();
			i && Ve(e, i);
			const n = this.getLabelItems(t);
			for (const t of n) {
				const i = t.options,
					n = t.font;
				Xe(e, t.label, 0, t.textOffset, n, i)
			}
			i && $e(e)
		}
		drawTitle() {
			const {
				ctx: t,
				options: {
					position: e,
					title: i,
					reverse: n
				}
			} = this;
			if (!i.display) return;
			const s = P(i.font),
				o = R(i.padding),
				r = i.align;
			let a = s.lineHeight / 2;
			"bottom" === e || "center" === e || E(e) ? (a += o.bottom, I(i.text) && (a += s.lineHeight * (i.text.length - 1))) : a += o.top;
			const {
				titleX: l,
				titleY: h,
				maxWidth: c,
				rotation: u
			} = function (t, e, i, n) {
				const {
					top: s,
					left: o,
					bottom: r,
					right: a,
					chart: l
				} = t, {
					chartArea: h,
					scales: c
				} = l;
				let u, d, f, p = 0;
				const g = r - s,
					m = a - o;
				if (t.isHorizontal()) {
					if (d = M(n, o, a), E(i)) {
						const t = Object.keys(i)[0],
							n = i[t];
						f = c[t].getPixelForValue(n) + g - e
					} else f = "center" === i ? (h.bottom + h.top) / 2 + g - e : Zn(t, i, e);
					u = a - o
				} else {
					if (E(i)) {
						const t = Object.keys(i)[0],
							n = i[t];
						d = c[t].getPixelForValue(n) - m + e
					} else d = "center" === i ? (h.left + h.right) / 2 - m + e : Zn(t, i, e);
					f = M(n, r, s), p = "left" === i ? -L : L
				}
				return {
					titleX: d,
					titleY: f,
					maxWidth: u,
					rotation: p
				}
			}(this, a, e, r);
			Xe(t, i.text, 0, 0, s, {
				color: i.color,
				maxWidth: c,
				rotation: u,
				textAlign: ns(r, e, n),
				textBaseline: "middle",
				translation: [l, h]
			})
		}
		draw(t) {
			this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))
		}
		_layers() {
			const t = this.options,
				e = t.ticks && t.ticks.z || 0,
				i = O(t.grid && t.grid.z, -1),
				n = O(t.border && t.border.z, 0);
			return this._isVisible() && this.draw === ss.prototype.draw ? [{
				z: i,
				draw: t => {
					this.drawBackground(), this.drawGrid(t), this.drawTitle()
				}
			}, {
				z: n,
				draw: () => {
					this.drawBorder()
				}
			}, {
				z: e,
				draw: t => {
					this.drawLabels(t)
				}
			}] : [{
				z: e,
				draw: t => {
					this.draw(t)
				}
			}]
		}
		getMatchingVisibleMetas(t) {
			const e = this.chart.getSortedVisibleDatasetMetas(),
				i = this.axis + "AxisID",
				n = [];
			let s, o;
			for (s = 0, o = e.length; s < o; ++s) {
				const o = e[s];
				o[i] !== this.id || t && o.type !== t || n.push(o)
			}
			return n
		}
		_resolveTickFontOptions(t) {
			return P(this.options.ticks.setContext(this.getContext(t)).font)
		}
		_maxDigits() {
			const t = this._resolveTickFontOptions(0).lineHeight;
			return (this.isHorizontal() ? this.width : this.height) / t
		}
	}
	class os {
		constructor(t, e, i) {
			this.type = t, this.scope = e, this.override = i, this.items = Object.create(null)
		}
		isForType(t) {
			return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
		}
		register(t) {
			const e = Object.getPrototypeOf(t);
			let i;
			(function (t) {
				return "id" in t && "defaults" in t
			})(e) && (i = this.register(e));
			const n = this.items,
				s = t.id,
				o = this.scope + "." + s;
			if (!s) throw new Error("class does not have id: " + t);
			return s in n || (n[s] = t, function (t, e, i) {
				const n = $(Object.create(null), [i ? S.get(i) : {}, S.get(e), t.defaults]);
				S.set(e, n), t.defaultRoutes && function (a, l) {
					Object.keys(l).forEach(t => {
						const e = t.split("."),
							i = e.pop(),
							n = [a].concat(e).join("."),
							s = l[t].split("."),
							o = s.pop(),
							r = s.join(".");
						S.route(n, i, r, o)
					})
				}(e, t.defaultRoutes);
				t.descriptors && S.describe(e, t.descriptors)
			}(t, o, i), this.override && S.override(t.id, t.overrides)), o
		}
		get(t) {
			return this.items[t]
		}
		unregister(t) {
			const e = this.items,
				i = t.id,
				n = this.scope;
			i in e && delete e[i], n && i in S[n] && (delete S[n][i], this.override && delete be[i])
		}
	}
	class rs {
		constructor() {
			this.controllers = new os(Gn, "datasets", !0), this.elements = new os(e, "elements"), this.plugins = new os(Object, "plugins"), this.scales = new os(ss, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
		}
		add(...t) {
			this._each("register", t)
		}
		remove(...t) {
			this._each("unregister", t)
		}
		addControllers(...t) {
			this._each("register", t, this.controllers)
		}
		addElements(...t) {
			this._each("register", t, this.elements)
		}
		addPlugins(...t) {
			this._each("register", t, this.plugins)
		}
		addScales(...t) {
			this._each("register", t, this.scales)
		}
		getController(t) {
			return this._get(t, this.controllers, "controller")
		}
		getElement(t) {
			return this._get(t, this.elements, "element")
		}
		getPlugin(t) {
			return this._get(t, this.plugins, "plugin")
		}
		getScale(t) {
			return this._get(t, this.scales, "scale")
		}
		removeControllers(...t) {
			this._each("unregister", t, this.controllers)
		}
		removeElements(...t) {
			this._each("unregister", t, this.elements)
		}
		removePlugins(...t) {
			this._each("unregister", t, this.plugins)
		}
		removeScales(...t) {
			this._each("unregister", t, this.scales)
		}
		_each(i, t, n) {
			[...t].forEach(t => {
				const e = n || this._getRegistryForType(t);
				n || e.isForType(t) || e === this.plugins && t.id ? this._exec(i, e, t) : C(t, t => {
					const e = n || this._getRegistryForType(t);
					this._exec(i, e, t)
				})
			})
		}
		_exec(t, e, i) {
			const n = K(t);
			f(i["before" + n], [], i), e[t](i), f(i["after" + n], [], i)
		}
		_getRegistryForType(i) {
			for (let e = 0; e < this._typedRegistries.length; e++) {
				const t = this._typedRegistries[e];
				if (t.isForType(i)) return t
			}
			return this.plugins
		}
		_get(t, e, i) {
			const n = e.get(t);
			if (void 0 === n) throw new Error('"' + t + '" is not a registered ' + i + ".");
			return n
		}
	}
	var d = new rs;
	class as {
		constructor() {
			this._init = []
		}
		notify(t, e, i, n) {
			"beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
			const s = n ? this._descriptors(t).filter(n) : this._descriptors(t),
				o = this._notify(s, t, e, i);
			return "afterDestroy" === e && (this._notify(s, t, "stop"), this._notify(this._init, t, "uninstall")), o
		}
		_notify(e, i, n, s) {
			s = s || {};
			for (const t of e) {
				const e = t.plugin;
				if (!1 === f(e[n], [i, s, t.options], e) && s.cancelable) return !1
			}
			return !0
		}
		invalidate() {
			T(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
		}
		_descriptors(t) {
			if (this._cache) return this._cache;
			const e = this._cache = this._createDescriptors(t);
			return this._notifyStateChanges(t), e
		}
		_createDescriptors(t, e) {
			const i = t && t.config,
				n = O(i.options && i.options.plugins, {}),
				s = function (t) {
					const e = {},
						i = [],
						n = Object.keys(d.plugins.items);
					for (let t = 0; t < n.length; t++) i.push(d.getPlugin(n[t]));
					const s = t.plugins || [];
					for (let t = 0; t < s.length; t++) {
						const n = s[t]; - 1 === i.indexOf(n) && (i.push(n), e[n.id] = !0)
					}
					return {
						plugins: i,
						localIds: e
					}
				}(i);
			return !1 !== n || e ? function (i, {
				plugins: n,
				localIds: s
			}, o, r) {
				const a = [],
					l = i.getContext();
				for (const e of n) {
					const n = e.id,
						t = ls(o[n], r);
					null !== t && a.push({
						plugin: e,
						options: hs(i.config, {
							plugin: e,
							local: s[n]
						}, t, l)
					})
				}
				return a
			}(t, s, n, e) : []
		}
		_notifyStateChanges(t) {
			const e = this._oldCache || [],
				i = this._cache,
				n = (t, i) => t.filter(e => !i.some(t => e.plugin.id === t.plugin.id));
			this._notify(n(e, i), t, "stop"), this._notify(n(i, e), t, "start")
		}
	}

	function ls(t, e) {
		return e || !1 !== t ? !0 === t ? {} : t : null
	}

	function hs(t, {
		plugin: e,
		local: i
	}, n, s) {
		const o = t.pluginScopeKeys(e),
			r = t.getOptionScopes(n, o);
		return i && e.defaults && r.push(e.defaults), t.createResolver(r, s, [""], {
			scriptable: !1,
			indexable: !1,
			allKeys: !0
		})
	}

	function cs(t, e) {
		const i = S.datasets[t] || {};
		return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x"
	}

	function us(t) {
		if ("x" === t || "y" === t || "r" === t) return t
	}

	function ds(e, ...i) {
		if (us(e)) return e;
		for (const t of i) {
			const i = t.axis || ("top" === (n = t.position) || "bottom" === n ? "x" : "left" === n || "right" === n ? "y" : void 0) || e.length > 1 && us(e[0].toLowerCase());
			if (i) return i
		}
		var n;
		throw new Error(`Cannot determine type of'${e}'axis.Please provide'axis'or'position'option.`)
	}

	function fs(t, e, i) {
		if (i[e + "AxisID"] === t) return {
			axis: e
		}
	}

	function ps(r, e) {
		const o = be[r.type] || {
			scales: {}
		},
			a = e.scales || {},
			l = cs(r.type, e),
			h = Object.create(null);
		return Object.keys(a).forEach(t => {
			const e = a[t];
			if (!E(e)) return console.error(`Invalid scale configuration for scale:${t}`);
			if (e._proxy) return console.warn(`Ignoring resolver passed as options for scale:${t}`);
			const i = ds(t, e, function (e, i) {
				if (i.data && i.data.datasets) {
					const t = i.data.datasets.filter(t => t.xAxisID === e || t.yAxisID === e);
					if (t.length) return fs(e, "x", t[0]) || fs(e, "y", t[0])
				}
				return {}
			}(t, r), S.scales[e.type]),
				n = function (t, e) {
					return t === e ? "_index_" : "_value_"
				}(i, l),
				s = o.scales || {};
			h[t] = U(Object.create(null), [{
				axis: i
			}, e, s[i], s[n]])
		}), r.data.datasets.forEach(n => {
			const t = n.type || r.type,
				s = n.indexAxis || cs(t, e),
				o = (be[t] || {}).scales || {};
			Object.keys(o).forEach(t => {
				const e = function (t, e) {
					let i = t;
					return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i
				}(t, s),
					i = n[e + "AxisID"] || e;
				h[i] = h[i] || Object.create(null), U(h[i], [{
					axis: e
				}, a[i], o[t]])
			})
		}), Object.keys(h).forEach(t => {
			const e = h[t];
			U(e, [S.scales[e.type], S.scale])
		}), h
	}

	function gs(t) {
		const e = t.options || (t.options = {});
		e.plugins = O(e.plugins, {}), e.scales = ps(t, e)
	}

	function ms(t) {
		return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t
	}
	const vs = new Map,
		bs = new Set;

	function _s(t, e) {
		let i = vs.get(t);
		return i || (i = e(), vs.set(t, i), bs.add(i)), i
	}
	const ys = (t, e, i) => {
		const n = m(e, i);
		void 0 !== n && t.add(n)
	};
	class xs {
		constructor(t) {
			this._config = function (t) {
				return (t = t || {}).data = ms(t.data), gs(t), t
			}(t), this._scopeCache = new Map, this._resolverCache = new Map
		}
		get platform() {
			return this._config.platform
		}
		get type() {
			return this._config.type
		}
		set type(t) {
			this._config.type = t
		}
		get data() {
			return this._config.data
		}
		set data(t) {
			this._config.data = ms(t)
		}
		get options() {
			return this._config.options
		}
		set options(t) {
			this._config.options = t
		}
		get plugins() {
			return this._config.plugins
		}
		update() {
			const t = this._config;
			this.clearCache(), gs(t)
		}
		clearCache() {
			this._scopeCache.clear(), this._resolverCache.clear()
		}
		datasetScopeKeys(t) {
			return _s(t, () => [
				[`datasets.${t}`, ""]
			])
		}
		datasetAnimationScopeKeys(t, e) {
			return _s(`${t}.transition.${e}`, () => [
				[`datasets.${t}.transitions.${e}`, `transitions.${e}`],
				[`datasets.${t}`, ""]
			])
		}
		datasetElementScopeKeys(t, e) {
			return _s(`${t}-${e}`, () => [
				[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]
			])
		}
		pluginScopeKeys(t) {
			const e = t.id;
			return _s(`${this.type}-plugin-${e}`, () => [
				[`plugins.${e}`, ...t.additionalOptionScopes || []]
			])
		}
		_cachedScopes(t, e) {
			const i = this._scopeCache;
			let n = i.get(t);
			return n && !e || (n = new Map, i.set(t, n)), n
		}
		getOptionScopes(e, t, i) {
			const {
				options: n,
				type: s
			} = this, o = this._cachedScopes(e, i), r = o.get(t);
			if (r) return r;
			const a = new Set;
			t.forEach(t => {
				e && (a.add(e), t.forEach(t => ys(a, e, t))), t.forEach(t => ys(a, n, t)), t.forEach(t => ys(a, be[s] || {}, t)), t.forEach(t => ys(a, S, t)), t.forEach(t => ys(a, _e, t))
			});
			const l = Array.from(a);
			return 0 === l.length && l.push(Object.create(null)), bs.has(t) && o.set(t, l), l
		}
		chartOptionScopes() {
			const {
				options: t,
				type: e
			} = this;
			return [t, be[e] || {}, S.datasets[e] || {}, {
				type: e
			}, S, _e]
		}
		resolveNamedOptions(t, e, i, n = [""]) {
			const s = {
				$shared: !0
			},
				{
					resolver: o,
					subPrefixes: r
				} = ws(this._resolverCache, t, n);
			let a = o;
			if (function (n, s) {
				const {
					isScriptable: o,
					isIndexable: r
				} = ti(n);
				for (const i of s) {
					const s = o(i),
						t = r(i),
						e = (t || s) && n[i];
					if (s && (l(e) || ks(e)) || t && I(e)) return !0
				}
				return !1
			}(o, e)) {
				s.$shared = !1;
				a = Je(o, i = l(i) ? i() : i, this.createResolver(t, i, r))
			}
			for (const t of e) s[t] = a[t];
			return s
		}
		createResolver(t, e, i = [""], n) {
			const {
				resolver: s
			} = ws(this._resolverCache, t, i);
			return E(e) ? Je(s, e, void 0, n) : s
		}
	}

	function ws(t, e, i) {
		let n = t.get(e);
		n || (n = new Map, t.set(e, n));
		const s = i.join();
		let o = n.get(s);
		if (!o) {
			o = {
				resolver: Qe(e, i),
				subPrefixes: i.filter(t => !t.toLowerCase().includes("hover"))
			}, n.set(s, o)
		}
		return o
	}
	const ks = i => E(i) && Object.getOwnPropertyNames(i).reduce((t, e) => t || l(i[e]), !1);
	const Cs = ["top", "bottom", "left", "right", "chartArea"];

	function Ds(t, e) {
		return "top" === t || "bottom" === t || -1 === Cs.indexOf(t) && "x" === e
	}

	function Ms(i, n) {
		return function (t, e) {
			return t[i] === e[i] ? t[n] - e[n] : t[i] - e[i]
		}
	}

	function Ts(t) {
		const e = t.chart,
			i = e.options.animation;
		e.notifyPlugins("afterRender"), f(i && i.onComplete, [t], e)
	}

	function Ss(t) {
		const e = t.chart,
			i = e.options.animation;
		f(i && i.onProgress, [t], e)
	}

	function Ps(t) {
		return ke() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t
	}
	const Is = {},
		Es = t => {
			const e = Ps(t);
			return Object.values(Is).filter(t => t.canvas === e).pop()
		};

	function Os(i, n, s) {
		const o = Object.keys(i);
		for (const e of o) {
			const o = +e;
			if (o >= n) {
				const t = i[e];
				delete i[e], (s > 0 || o > n) && (i[o + s] = t)
			}
		}
	}
	class i {
		static defaults = S;
		static instances = Is;
		static overrides = be;
		static registry = d;
		static version = "4.3.0";
		static getChart = Es;
		static register(...t) {
			d.add(...t), As()
		}
		static unregister(...t) {
			d.remove(...t), As()
		}
		constructor(t, e) {
			const i = this.config = new xs(e),
				n = Ps(t),
				s = Es(n);
			if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused.");
			const o = i.createResolver(i.chartOptionScopes(), this.getContext());
			this.platform = new (i.platform || En(n)), this.platform.updateConfig(i);
			const r = this.platform.acquireContext(n, o.aspectRatio),
				a = r && r.canvas,
				l = a && a.height,
				h = a && a.width;
			this.id = H(), this.ctx = r, this.canvas = a, this.width = h, this.height = l, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new as, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Mt(t => this.update(t), o.resizeDelay || 0), this._dataChanges = [], Is[this.id] = this, r && a ? (c.listen(this, "complete", Ts), c.listen(this, "progress", Ss), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
		}
		get aspectRatio() {
			const {
				options: {
					aspectRatio: t,
					maintainAspectRatio: e
				},
				width: i,
				height: n,
				_aspectRatio: s
			} = this;
			return T(t) ? e && s ? s : n ? i / n : null : t
		}
		get data() {
			return this.config.data
		}
		set data(t) {
			this.config.data = t
		}
		get options() {
			return this._options
		}
		set options(t) {
			this.config.options = t
		}
		get registry() {
			return d
		}
		_initialize() {
			return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Le(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
		}
		clear() {
			return Be(this.canvas, this.ctx), this
		}
		stop() {
			return c.stop(this), this
		}
		resize(t, e) {
			c.running(this) ? this._resizeBeforeDraw = {
				width: t,
				height: e
			} : this._resize(t, e)
		}
		_resize(t, e) {
			const i = this.options,
				n = this.canvas,
				s = i.maintainAspectRatio && this.aspectRatio,
				o = this.platform.getMaximumSize(n, t, e, s),
				r = i.devicePixelRatio || this.platform.getDevicePixelRatio(),
				a = this.width ? "resize" : "attach";
			this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, Le(this, r, !0) && (this.notifyPlugins("resize", {
				size: o
			}), f(i.onResize, [this, o], this), this.attached && this._doResize(a) && this.render())
		}
		ensureScalesHaveIDs() {
			C(this.options.scales || {}, (t, e) => {
				t.id = e
			})
		}
		buildOrUpdateScales() {
			const r = this.options,
				o = r.scales,
				a = this.scales,
				l = Object.keys(a).reduce((t, e) => (t[e] = !1, t), {});
			let t = [];
			o && (t = t.concat(Object.keys(o).map(t => {
				const e = o[t],
					i = ds(t, e),
					n = "r" === i,
					s = "x" === i;
				return {
					options: e,
					dposition: n ? "chartArea" : s ? "bottom" : "left",
					dtype: n ? "radialLinear" : s ? "category" : "linear"
				}
			}))), C(t, t => {
				const e = t.options,
					i = e.id,
					n = ds(i, e),
					s = O(e.type, t.dtype);
				void 0 !== e.position && Ds(e.position, n) === Ds(t.dposition) || (e.position = t.dposition), l[i] = !0;
				let o = null;
				if (i in a && a[i].type === s) o = a[i];
				else {
					o = new (d.getScale(s))({
						id: i,
						type: s,
						ctx: this.ctx,
						chart: this
					}), a[o.id] = o
				}
				o.init(e, r)
			}), C(l, (t, e) => {
				t || delete a[e]
			}), C(a, t => {
				s.configure(this, t, t.options), s.addBox(this, t)
			})
		}
		_updateMetasets() {
			const t = this._metasets,
				e = this.data.datasets.length,
				i = t.length;
			if (t.sort((t, e) => t.index - e.index), i > e) {
				for (let t = e; t < i; ++t) this._destroyDatasetMeta(t);
				t.splice(e, i - e)
			}
			this._sortedMetasets = t.slice(0).sort(Ms("order", "index"))
		}
		_removeUnreferencedMetasets() {
			const {
				_metasets: t,
				data: {
					datasets: i
				}
			} = this;
			t.length > i.length && delete this._stacks, t.forEach((e, t) => {
				0 === i.filter(t => t === e._dataset).length && this._destroyDatasetMeta(t)
			})
		}
		buildOrUpdateControllers() {
			const n = [],
				s = this.data.datasets;
			let o, r;
			for (this._removeUnreferencedMetasets(), o = 0, r = s.length; o < r; o++) {
				const r = s[o];
				let e = this.getDatasetMeta(o);
				const i = r.type || this.config.type;
				if (e.type && e.type !== i && (this._destroyDatasetMeta(o), e = this.getDatasetMeta(o)), e.type = i, e.indexAxis = r.indexAxis || cs(i, this.options), e.order = r.order || 0, e.index = o, e.label = "" + r.label, e.visible = this.isDatasetVisible(o), e.controller) e.controller.updateIndex(o), e.controller.linkScales();
				else {
					const s = d.getController(i),
						{
							datasetElementType: r,
							dataElementType: t
						} = S.datasets[i];
					Object.assign(s, {
						dataElementType: d.getElement(t),
						datasetElementType: r && d.getElement(r)
					}), e.controller = new s(this, o), n.push(e.controller)
				}
			}
			return this._updateMetasets(), n
		}
		_resetElements() {
			C(this.data.datasets, (t, e) => {
				this.getDatasetMeta(e).controller.reset()
			}, this)
		}
		reset() {
			this._resetElements(), this.notifyPlugins("reset")
		}
		update(t) {
			const i = this.config;
			i.update();
			const n = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()),
				s = this._animationsDisabled = !n.animation;
			if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", {
				mode: t,
				cancelable: !0
			})) return;
			const o = this.buildOrUpdateControllers();
			this.notifyPlugins("beforeElementsUpdate");
			let r = 0;
			for (let t = 0, e = this.data.datasets.length; t < e; t++) {
				const {
					controller: i
				} = this.getDatasetMeta(t), n = !s && -1 === o.indexOf(i);
				i.buildOrUpdateElements(n), r = Math.max(+i.getMaxOverflow(), r)
			}
			r = this._minPadding = n.layout.autoPadding ? r : 0, this._updateLayout(r), s || C(o, t => {
				t.reset()
			}), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
				mode: t
			}), this._layers.sort(Ms("z", "_idx"));
			const {
				_active: e,
				_lastEvent: a
			} = this;
			a ? this._eventHandler(a, !0) : e.length && this._updateHoverStyles(e, e, !0), this.render()
		}
		_updateScales() {
			C(this.scales, t => {
				s.removeBox(this, t)
			}), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()
		}
		_checkEventBindings() {
			const t = this.options,
				e = new Set(Object.keys(this._listeners)),
				i = new Set(t.events);
			Z(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents())
		}
		_updateHiddenIndices() {
			const {
				_hiddenIndices: n
			} = this, s = this._getUniformDataChanges() || [];
			for (const {
				method: t,
				start: e,
				count: i
			}
				of s) {
				Os(n, e, "_removeElements" === t ? -i : i)
			}
		}
		_getUniformDataChanges() {
			const t = this._dataChanges;
			if (!t || !t.length) return;
			this._dataChanges = [];
			const e = this.data.datasets.length,
				i = e => new Set(t.filter(t => t[0] === e).map((t, e) => e + "," + t.splice(1).join(","))),
				n = i(0);
			for (let t = 1; t < e; t++)
				if (!Z(n, i(t))) return;
			return Array.from(n).map(t => t.split(",")).map(t => ({
				method: t[1],
				start: +t[2],
				count: +t[3]
			}))
		}
		_updateLayout(t) {
			if (!1 === this.notifyPlugins("beforeLayout", {
				cancelable: !0
			})) return;
			s.update(this, this.width, this.height, t);
			const e = this.chartArea,
				i = e.width <= 0 || e.height <= 0;
			this._layers = [], C(this.boxes, t => {
				i && "chartArea" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()))
			}, this), this._layers.forEach((t, e) => {
				t._idx = e
			}), this.notifyPlugins("afterLayout")
		}
		_updateDatasets(i) {
			if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
				mode: i,
				cancelable: !0
			})) {
				for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.getDatasetMeta(t).controller.configure();
				for (let t = 0, e = this.data.datasets.length; t < e; ++t) this._updateDataset(t, l(i) ? i({
					datasetIndex: t
				}) : i);
				this.notifyPlugins("afterDatasetsUpdate", {
					mode: i
				})
			}
		}
		_updateDataset(t, e) {
			const i = this.getDatasetMeta(t),
				n = {
					meta: i,
					index: t,
					mode: e,
					cancelable: !0
				};
			!1 !== this.notifyPlugins("beforeDatasetUpdate", n) && (i.controller._update(e), n.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", n))
		}
		render() {
			!1 !== this.notifyPlugins("beforeRender", {
				cancelable: !0
			}) && (c.has(this) ? this.attached && !c.running(this) && c.start(this) : (this.draw(), Ts({
				chart: this
			})))
		}
		draw() {
			let t;
			if (this._resizeBeforeDraw) {
				const {
					width: t,
					height: e
				} = this._resizeBeforeDraw;
				this._resize(t, e), this._resizeBeforeDraw = null
			}
			if (this.clear(), this.width <= 0 || this.height <= 0) return;
			if (!1 === this.notifyPlugins("beforeDraw", {
				cancelable: !0
			})) return;
			const e = this._layers;
			for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);
			for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);
			this.notifyPlugins("afterDraw")
		}
		_getSortedDatasetMetas(t) {
			const e = this._sortedMetasets,
				i = [];
			let n, s;
			for (n = 0, s = e.length; n < s; ++n) {
				const s = e[n];
				t && !s.visible || i.push(s)
			}
			return i
		}
		getSortedVisibleDatasetMetas() {
			return this._getSortedDatasetMetas(!0)
		}
		_drawDatasets() {
			if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
				cancelable: !0
			})) return;
			const e = this.getSortedVisibleDatasetMetas();
			for (let t = e.length - 1; t >= 0; --t) this._drawDataset(e[t]);
			this.notifyPlugins("afterDatasetsDraw")
		}
		_drawDataset(t) {
			const e = this.ctx,
				i = t._clip,
				n = !i.disabled,
				s = function (t) {
					const {
						xScale: e,
						yScale: i
					} = t;
					if (e && i) return {
						left: e.left,
						right: e.right,
						top: i.top,
						bottom: i.bottom
					}
				}(t) || this.chartArea,
				o = {
					meta: t,
					index: t.index,
					cancelable: !0
				};
			!1 !== this.notifyPlugins("beforeDatasetDraw", o) && (n && Ve(e, {
				left: !1 === i.left ? 0 : s.left - i.left,
				right: !1 === i.right ? this.width : s.right + i.right,
				top: !1 === i.top ? 0 : s.top - i.top,
				bottom: !1 === i.bottom ? this.height : s.bottom + i.bottom
			}), t.controller.draw(), n && $e(e), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o))
		}
		isPointInArea(t) {
			return u(t, this.chartArea, this._minPadding)
		}
		getElementsAtEventForMode(t, e, i, n) {
			const s = tn.modes[e];
			return "function" == typeof s ? s(this, t, i, n) : []
		}
		getDatasetMeta(t) {
			const e = this.data.datasets[t],
				i = this._metasets;
			let n = i.filter(t => t && t._dataset === e).pop();
			return n || (n = {
				type: null,
				data: [],
				dataset: null,
				controller: null,
				hidden: null,
				xAxisID: null,
				yAxisID: null,
				order: e && e.order || 0,
				index: t,
				_dataset: e,
				_parsed: [],
				_sorted: !1
			}, i.push(n)), n
		}
		getContext() {
			return this.$context || (this.$context = Ni(null, {
				chart: this,
				type: "chart"
			}))
		}
		getVisibleDatasetCount() {
			return this.getSortedVisibleDatasetMetas().length
		}
		isDatasetVisible(t) {
			const e = this.data.datasets[t];
			if (!e) return !1;
			const i = this.getDatasetMeta(t);
			return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden
		}
		setDatasetVisibility(t, e) {
			this.getDatasetMeta(t).hidden = !e
		}
		toggleDataVisibility(t) {
			this._hiddenIndices[t] = !this._hiddenIndices[t]
		}
		getDataVisibility(t) {
			return !this._hiddenIndices[t]
		}
		_updateVisibility(e, t, i) {
			const n = i ? "show" : "hide",
				s = this.getDatasetMeta(e),
				o = s.controller._resolveAnimations(void 0, n);
			X(t) ? (s.data[t].hidden = !i, this.update()) : (this.setDatasetVisibility(e, i), o.update(s, {
				visible: i
			}), this.update(t => t.datasetIndex === e ? n : void 0))
		}
		hide(t, e) {
			this._updateVisibility(t, e, !1)
		}
		show(t, e) {
			this._updateVisibility(t, e, !0)
		}
		_destroyDatasetMeta(t) {
			const e = this._metasets[t];
			e && e.controller && e.controller._destroy(), delete this._metasets[t]
		}
		_stop() {
			let t, e;
			for (this.stop(), c.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t)
		}
		destroy() {
			this.notifyPlugins("beforeDestroy");
			const {
				canvas: t,
				ctx: e
			} = this;
			this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Be(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Is[this.id], this.notifyPlugins("afterDestroy")
		}
		toBase64Image(...t) {
			return this.canvas.toDataURL(...t)
		}
		bindEvents() {
			this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
		}
		bindUserEvents() {
			const i = this._listeners,
				n = this.platform,
				e = (t, e) => {
					n.addEventListener(this, t, e), i[t] = e
				},
				s = (t, e, i) => {
					t.offsetX = e, t.offsetY = i, this._eventHandler(t)
				};
			C(this.options.events, t => e(t, s))
		}
		bindResponsiveEvents() {
			this._responsiveListeners || (this._responsiveListeners = {});
			const i = this._responsiveListeners,
				n = this.platform,
				t = (t, e) => {
					n.addEventListener(this, t, e), i[t] = e
				},
				e = (t, e) => {
					i[t] && (n.removeEventListener(this, t, e), delete i[t])
				},
				s = (t, e) => {
					this.canvas && this.resize(t, e)
				};
			let o;
			const r = () => {
				e("attach", r), this.attached = !0, this.resize(), t("resize", s), t("detach", o)
			};
			o = () => {
				this.attached = !1, e("resize", s), this._stop(), this._resize(0, 0), t("attach", r)
			}, n.isAttached(this.canvas) ? r() : o()
		}
		unbindEvents() {
			C(this._listeners, (t, e) => {
				this.platform.removeEventListener(this, e, t)
			}), this._listeners = {}, C(this._responsiveListeners, (t, e) => {
				this.platform.removeEventListener(this, e, t)
			}), this._responsiveListeners = void 0
		}
		updateHoverStyle(t, e, i) {
			const n = i ? "set" : "remove";
			let s, o, r, a;
			for ("dataset" === e && (s = this.getDatasetMeta(t[0].datasetIndex), s.controller["_" + n + "DatasetHoverStyle"]()), r = 0, a = t.length; r < a; ++r) {
				o = t[r];
				const e = o && this.getDatasetMeta(o.datasetIndex).controller;
				e && e[n + "HoverStyle"](o.element, o.datasetIndex, o.index)
			}
		}
		getActiveElements() {
			return this._active || []
		}
		setActiveElements(t) {
			const e = this._active || [],
				i = t.map(({
					datasetIndex: t,
					index: e
				}) => {
					const i = this.getDatasetMeta(t);
					if (!i) throw new Error("No dataset found at index " + t);
					return {
						datasetIndex: t,
						element: i.data[e],
						index: e
					}
				});
			!B(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e))
		}
		notifyPlugins(t, e, i) {
			return this._plugins.notify(this, t, e, i)
		}
		isPluginEnabled(e) {
			return 1 === this._plugins._cache.filter(t => t.plugin.id === e).length
		}
		_updateHoverStyles(t, e, i) {
			const n = this.options.hover,
				s = (t, i) => t.filter(e => !i.some(t => e.datasetIndex === t.datasetIndex && e.index === t.index)),
				o = s(e, t),
				r = i ? t : s(t, e);
			o.length && this.updateHoverStyle(o, n.mode, !1), r.length && n.mode && this.updateHoverStyle(r, n.mode, !0)
		}
		_eventHandler(e, t) {
			const i = {
				event: e,
				replay: t,
				cancelable: !0,
				inChartArea: this.isPointInArea(e)
			},
				n = t => (t.options.events || this.options.events).includes(e.native.type);
			if (!1 === this.notifyPlugins("beforeEvent", i, n)) return;
			const s = this._handleEvent(e, t, i.inChartArea);
			return i.cancelable = !1, this.notifyPlugins("afterEvent", i, n), (s || i.changed) && this.render(), this
		}
		_handleEvent(t, e, i) {
			const {
				_active: n = [],
				options: s
			} = this, o = e, r = this._getActiveElements(t, n, i, o), a = Q(t), l = function (t, e, i, n) {
				return i && "mouseout" !== t.type ? n ? e : t : null
			}(t, this._lastEvent, i, a);
			i && (this._lastEvent = null, f(s.onHover, [t, r, this], this), a && f(s.onClick, [t, r, this], this));
			const h = !B(r, n);
			return (h || e) && (this._active = r, this._updateHoverStyles(r, n, e)), this._lastEvent = l, h
		}
		_getActiveElements(t, e, i, n) {
			if ("mouseout" === t.type) return [];
			if (!i) return e;
			const s = this.options.hover;
			return this.getElementsAtEventForMode(t, s.mode, s, n)
		}
	}

	function As() {
		return C(i.instances, t => t._plugins.invalidate())
	}

	function Ls() {
		throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
	}
	class Ns {
		static override(t) {
			Object.assign(Ns.prototype, t)
		}
		options;
		constructor(t) {
			this.options = t || {}
		}
		init() { }
		formats() {
			return Ls()
		}
		parse() {
			return Ls()
		}
		format() {
			return Ls()
		}
		add() {
			return Ls()
		}
		diff() {
			return Ls()
		}
		startOf() {
			return Ls()
		}
		endOf() {
			return Ls()
		}
	}
	var Rs = {
		_date: Ns
	};

	function Fs(t) {
		const e = t.iScale,
			i = function (s, t) {
				if (!s._cache.$bar) {
					const i = s.getMatchingVisibleMetas(t);
					let n = [];
					for (let t = 0, e = i.length; t < e; t++) n = n.concat(i[t].controller.getAllParsedValues(s));
					s._cache.$bar = kt(n.sort((t, e) => t - e))
				}
				return s._cache.$bar
			}(e, t.type);
		let n, s, o, r, a = e._length;
		const l = () => {
			32767 !== o && -32768 !== o && (X(r) && (a = Math.min(a, Math.abs(o - r) || a)), r = o)
		};
		for (n = 0, s = i.length; n < s; ++n) o = e.getPixelForValue(i[n]), l();
		for (r = void 0, n = 0, s = e.ticks.length; n < s; ++n) o = e.getPixelForTick(n), l();
		return a
	}

	function Hs(t, e, i, n) {
		return I(t) ? function (t, e, i, n) {
			const s = i.parse(t[0], n),
				o = i.parse(t[1], n),
				r = Math.min(s, o),
				a = Math.max(s, o);
			let l = r,
				h = a;
			Math.abs(r) > Math.abs(a) && (l = a, h = r), e[i.axis] = h, e._custom = {
				barStart: l,
				barEnd: h,
				start: s,
				end: o,
				min: r,
				max: a
			}
		}(t, e, i, n) : e[i.axis] = i.parse(t, n), e
	}

	function zs(t, e, i, n) {
		const s = t.iScale,
			o = t.vScale,
			r = s.getLabels(),
			a = s === o,
			l = [];
		let h, c, u, d;
		for (h = i, c = i + n; h < c; ++h) d = e[h], u = {}, u[s.axis] = a || s.parse(r[h], h), l.push(Hs(d, u, o, h));
		return l
	}

	function Ws(t) {
		return t && void 0 !== t.barStart && void 0 !== t.barEnd
	}

	function Bs(t, e, i, n) {
		let s = e.borderSkipped;
		const o = {};
		if (!s) return void (t.borderSkipped = o);
		if (!0 === s) return void (t.borderSkipped = {
			top: !0,
			right: !0,
			bottom: !0,
			left: !0
		});
		const {
			start: r,
			end: a,
			reverse: l,
			top: h,
			bottom: c
		} = function (t) {
			let e, i, n, s, o;
			return t.horizontal ? (e = t.base > t.x, i = "left", n = "right") : (e = t.base < t.y, i = "bottom", n = "top"), e ? (s = "end", o = "start") : (s = "start", o = "end"), {
				start: i,
				end: n,
				reverse: e,
				top: s,
				bottom: o
			}
		}(t);
		"middle" === s && i && (t.enableBorderRadius = !0, (i._top || 0) === n ? s = h : (i._bottom || 0) === n ? s = c : (o[js(c, r, a, l)] = !0, s = h)), o[js(s, r, a, l)] = !0, t.borderSkipped = o
	}

	function js(t, e, i, n) {
		var s, o, r;
		return n ? (r = i, t = Ys(t = (s = t) === (o = e) ? r : s === r ? o : s, i, e)) : t = Ys(t, e, i), t
	}

	function Ys(t, e, i) {
		return "start" === t ? e : "end" === t ? i : t
	}

	function Vs(t, {
		inflateAmount: e
	}, i) {
		t.inflateAmount = "auto" === e ? 1 === i ? .33 : 0 : e
	}
	class $s extends Gn {
		static id = "doughnut";
		static defaults = {
			datasetElementType: !1,
			dataElementType: "arc",
			animation: {
				animateRotate: !0,
				animateScale: !1
			},
			animations: {
				numbers: {
					type: "number",
					properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
				}
			},
			cutout: "50%",
			rotation: 0,
			circumference: 360,
			radius: "100%",
			spacing: 0,
			indexAxis: "r"
		};
		static descriptors = {
			_scriptable: t => "spacing" !== t,
			_indexable: t => "spacing" !== t && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
		};
		static overrides = {
			aspectRatio: 1,
			plugins: {
				legend: {
					labels: {
						generateLabels(o) {
							const t = o.data;
							if (t.labels.length && t.datasets.length) {
								const {
									labels: {
										pointStyle: n,
										color: s
									}
								} = o.legend.options;
								return t.labels.map((t, e) => {
									const i = o.getDatasetMeta(0).controller.getStyle(e);
									return {
										text: t,
										fillStyle: i.backgroundColor,
										strokeStyle: i.borderColor,
										fontColor: s,
										lineWidth: i.borderWidth,
										pointStyle: n,
										hidden: !o.getDataVisibility(e),
										index: e
									}
								})
							}
							return []
						}
					},
					onClick(t, e, i) {
						i.chart.toggleDataVisibility(e.index), i.chart.update()
					}
				}
			}
		};
		constructor(t, e) {
			super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
		}
		linkScales() { }
		parse(n, s) {
			const o = this.getDataset().data,
				r = this._cachedMeta;
			if (!1 === this._parsing) r._parsed = o;
			else {
				let t, e, i = t => +o[t];
				if (E(o[n])) {
					const {
						key: n = "value"
					} = this._parsing;
					i = t => +m(o[t], n)
				}
				for (t = n, e = n + s; t < e; ++t) r._parsed[t] = i(t)
			}
		}
		_getRotation() {
			return N(this.options.rotation - 90)
		}
		_getCircumference() {
			return N(this.options.circumference)
		}
		_getRotationExtents() {
			let s = y,
				o = -y;
			for (let n = 0; n < this.chart.data.datasets.length; ++n)
				if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
					const t = this.chart.getDatasetMeta(n).controller,
						e = t._getRotation(),
						i = t._getCircumference();
					s = Math.min(s, e), o = Math.max(o, e + i)
				}
			return {
				rotation: s,
				circumference: o - s
			}
		}
		update(t) {
			const e = this.chart,
				{
					chartArea: i
				} = e,
				n = this._cachedMeta,
				s = n.data,
				o = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing,
				r = Math.max((Math.min(i.width, i.height) - o) / 2, 0),
				a = Math.min(z(this.options.cutout, r), 1),
				l = this._getRingWeight(this.index),
				{
					circumference: h,
					rotation: c
				} = this._getRotationExtents(),
				{
					ratioX: u,
					ratioY: d,
					offsetX: f,
					offsetY: p
				} = function (d, f, p) {
					let g = 1,
						m = 1,
						v = 0,
						b = 0;
					if (f < y) {
						const n = d,
							s = n + f,
							t = Math.cos(n),
							e = Math.sin(n),
							i = Math.cos(s),
							o = Math.sin(s),
							r = (t, e, i) => gt(t, n, s, !0) ? 1 : Math.max(e, e * p, i, i * p),
							a = (t, e, i) => gt(t, n, s, !0) ? -1 : Math.min(e, e * p, i, i * p),
							l = r(0, t, i),
							h = r(L, e, o),
							c = a(A, t, i),
							u = a(A + L, e, o);
						g = (l - c) / 2, m = (h - u) / 2, v = -(l + c) / 2, b = -(h + u) / 2
					}
					return {
						ratioX: g,
						ratioY: m,
						offsetX: v,
						offsetY: b
					}
				}(c, h, a),
				g = (i.width - o) / u,
				m = (i.height - o) / d,
				v = Math.max(Math.min(g, m) / 2, 0),
				b = W(this.options.radius, v),
				_ = (b - Math.max(b * a, 0)) / this._getVisibleDatasetWeightTotal();
			this.offsetX = f * b, this.offsetY = p * b, n.total = this.calculateTotal(), this.outerRadius = b - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * l, 0), this.updateElements(s, 0, s.length, t)
		}
		_circumference(t, e) {
			const i = this.options,
				n = this._cachedMeta,
				s = this._getCircumference();
			return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === n._parsed[t] || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * s / y)
		}
		updateElements(t, e, i, n) {
			const s = "reset" === n,
				o = this.chart,
				r = o.chartArea,
				a = o.options.animation,
				l = (r.left + r.right) / 2,
				h = (r.top + r.bottom) / 2,
				c = s && a.animateScale,
				u = c ? 0 : this.innerRadius,
				d = c ? 0 : this.outerRadius,
				{
					sharedOptions: f,
					includeOptions: p
				} = this._getSharedOptions(e, n);
			let g, m = this._getRotation();
			for (g = 0; g < e; ++g) m += this._circumference(g, s);
			for (g = e; g < e + i; ++g) {
				const e = this._circumference(g, s),
					i = t[g],
					o = {
						x: l + this.offsetX,
						y: h + this.offsetY,
						startAngle: m,
						endAngle: m + e,
						circumference: e,
						outerRadius: d,
						innerRadius: u
					};
				p && (o.options = f || this.resolveDataElementOptions(g, i.active ? "active" : n)), m += e, this.updateElement(i, g, o, n)
			}
		}
		calculateTotal() {
			const e = this._cachedMeta,
				i = e.data;
			let n, s = 0;
			for (n = 0; n < i.length; n++) {
				const t = e._parsed[n];
				null === t || isNaN(t) || !this.chart.getDataVisibility(n) || i[n].hidden || (s += Math.abs(t))
			}
			return s
		}
		calculateCircumference(t) {
			const e = this._cachedMeta.total;
			return e > 0 && !isNaN(t) ? y * (Math.abs(t) / e) : 0
		}
		getLabelAndValue(t) {
			const e = this._cachedMeta,
				i = this.chart,
				n = i.data.labels || [],
				s = ge(e._parsed[t], i.options.locale);
			return {
				label: n[t] || "",
				value: s
			}
		}
		getMaxBorderWidth(t) {
			let e = 0;
			const i = this.chart;
			let n, s, o, r, a;
			if (!t)
				for (n = 0, s = i.data.datasets.length; n < s; ++n)
					if (i.isDatasetVisible(n)) {
						o = i.getDatasetMeta(n), t = o.data, r = o.controller;
						break
					}
			if (!t) return 0;
			for (n = 0, s = t.length; n < s; ++n) a = r.resolveDataElementOptions(n), "inner" !== a.borderAlign && (e = Math.max(e, a.borderWidth || 0, a.hoverBorderWidth || 0));
			return e
		}
		getMaxOffset(i) {
			let n = 0;
			for (let t = 0, e = i.length; t < e; ++t) {
				const i = this.resolveDataElementOptions(t);
				n = Math.max(n, i.offset || 0, i.hoverOffset || 0)
			}
			return n
		}
		_getRingWeightOffset(e) {
			let i = 0;
			for (let t = 0; t < e; ++t) this.chart.isDatasetVisible(t) && (i += this._getRingWeight(t));
			return i
		}
		_getRingWeight(t) {
			return Math.max(O(this.chart.data.datasets[t].weight, 1), 0)
		}
		_getVisibleDatasetWeightTotal() {
			return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
		}
	}
	class Us extends Gn {
		static id = "polarArea";
		static defaults = {
			dataElementType: "arc",
			animation: {
				animateRotate: !0,
				animateScale: !0
			},
			animations: {
				numbers: {
					type: "number",
					properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
				}
			},
			indexAxis: "r",
			startAngle: 0
		};
		static overrides = {
			aspectRatio: 1,
			plugins: {
				legend: {
					labels: {
						generateLabels(o) {
							const t = o.data;
							if (t.labels.length && t.datasets.length) {
								const {
									labels: {
										pointStyle: n,
										color: s
									}
								} = o.legend.options;
								return t.labels.map((t, e) => {
									const i = o.getDatasetMeta(0).controller.getStyle(e);
									return {
										text: t,
										fillStyle: i.backgroundColor,
										strokeStyle: i.borderColor,
										fontColor: s,
										lineWidth: i.borderWidth,
										pointStyle: n,
										hidden: !o.getDataVisibility(e),
										index: e
									}
								})
							}
							return []
						}
					},
					onClick(t, e, i) {
						i.chart.toggleDataVisibility(e.index), i.chart.update()
					}
				}
			},
			scales: {
				r: {
					type: "radialLinear",
					angleLines: {
						display: !1
					},
					beginAtZero: !0,
					grid: {
						circular: !0
					},
					pointLabels: {
						display: !1
					},
					startAngle: 0
				}
			}
		};
		constructor(t, e) {
			super(t, e), this.innerRadius = void 0, this.outerRadius = void 0
		}
		getLabelAndValue(t) {
			const e = this._cachedMeta,
				i = this.chart,
				n = i.data.labels || [],
				s = ge(e._parsed[t].r, i.options.locale);
			return {
				label: n[t] || "",
				value: s
			}
		}
		parseObjectData(t, e, i, n) {
			return ui.bind(this)(t, e, i, n)
		}
		update(t) {
			const e = this._cachedMeta.data;
			this._updateRadius(), this.updateElements(e, 0, e.length, t)
		}
		getMinMax() {
			const t = this._cachedMeta,
				n = {
					min: Number.POSITIVE_INFINITY,
					max: Number.NEGATIVE_INFINITY
				};
			return t.data.forEach((t, e) => {
				const i = this.getParsed(e).r;
				!isNaN(i) && this.chart.getDataVisibility(e) && (i < n.min && (n.min = i), i > n.max && (n.max = i))
			}), n
		}
		_updateRadius() {
			const t = this.chart,
				e = t.chartArea,
				i = t.options,
				n = Math.min(e.right - e.left, e.bottom - e.top),
				s = Math.max(n / 2, 0),
				o = (s - Math.max(i.cutoutPercentage ? s / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
			this.outerRadius = s - o * this.index, this.innerRadius = this.outerRadius - o
		}
		updateElements(s, o, t, r) {
			const a = "reset" === r,
				l = this.chart,
				h = l.options.animation,
				c = this._cachedMeta.rScale,
				u = c.xCenter,
				d = c.yCenter,
				f = c.getIndexAngle(0) - .5 * A;
			let p, g = f;
			const m = 360 / this.countVisibleElements();
			for (p = 0; p < o; ++p) g += this._computeAngle(p, r, m);
			for (p = o; p < o + t; p++) {
				const o = s[p];
				let t = g,
					e = g + this._computeAngle(p, r, m),
					i = l.getDataVisibility(p) ? c.getDistanceFromCenterForValue(this.getParsed(p).r) : 0;
				g = e, a && (h.animateScale && (i = 0), h.animateRotate && (t = e = f));
				const n = {
					x: u,
					y: d,
					innerRadius: 0,
					outerRadius: i,
					startAngle: t,
					endAngle: e,
					options: this.resolveDataElementOptions(p, o.active ? "active" : r)
				};
				this.updateElement(o, p, n, r)
			}
		}
		countVisibleElements() {
			const t = this._cachedMeta;
			let i = 0;
			return t.data.forEach((t, e) => {
				!isNaN(this.getParsed(e).r) && this.chart.getDataVisibility(e) && i++
			}), i
		}
		_computeAngle(t, e, i) {
			return this.chart.getDataVisibility(t) ? N(this.resolveDataElementOptions(t, e).angle || i) : 0
		}
	}
	var qs = Object.freeze({
		__proto__: null,
		BarController: class extends Gn {
			static id = "bar";
			static defaults = {
				datasetElementType: !1,
				dataElementType: "bar",
				categoryPercentage: .8,
				barPercentage: .9,
				grouped: !0,
				animations: {
					numbers: {
						type: "number",
						properties: ["x", "y", "base", "width", "height"]
					}
				}
			};
			static overrides = {
				scales: {
					_index_: {
						type: "category",
						offset: !0,
						grid: {
							offset: !0
						}
					},
					_value_: {
						type: "linear",
						beginAtZero: !0
					}
				}
			};
			parsePrimitiveData(t, e, i, n) {
				return zs(t, e, i, n)
			}
			parseArrayData(t, e, i, n) {
				return zs(t, e, i, n)
			}
			parseObjectData(t, e, i, n) {
				const {
					iScale: s,
					vScale: o
				} = t, {
					xAxisKey: r = "x",
					yAxisKey: a = "y"
				} = this._parsing, l = "x" === s.axis ? r : a, h = "x" === o.axis ? r : a, c = [];
				let u, d, f, p;
				for (u = i, d = i + n; u < d; ++u) p = e[u], f = {}, f[s.axis] = s.parse(m(p, l), u), c.push(Hs(m(p, h), f, o, u));
				return c
			}
			updateRangeFromParsed(t, e, i, n) {
				super.updateRangeFromParsed(t, e, i, n);
				const s = i._custom;
				s && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, s.min), t.max = Math.max(t.max, s.max))
			}
			getMaxOverflow() {
				return 0
			}
			getLabelAndValue(t) {
				const e = this._cachedMeta,
					{
						iScale: i,
						vScale: n
					} = e,
					s = this.getParsed(t),
					o = s._custom,
					r = Ws(o) ? "[" + o.start + ", " + o.end + "]" : "" + n.getLabelForValue(s[n.axis]);
				return {
					label: "" + i.getLabelForValue(s[i.axis]),
					value: r
				}
			}
			initialize() {
				this.enableOptionSharing = !0, super.initialize();
				this._cachedMeta.stack = this.getDataset().stack
			}
			update(t) {
				const e = this._cachedMeta;
				this.updateElements(e.data, 0, e.data.length, t)
			}
			updateElements(o, r, a, l) {
				const h = "reset" === l,
					{
						index: c,
						_cachedMeta: {
							vScale: u
						}
					} = this,
					d = u.getBasePixel(),
					f = u.isHorizontal(),
					p = this._getRuler(),
					{
						sharedOptions: g,
						includeOptions: m
					} = this._getSharedOptions(r, l);
				for (let s = r; s < r + a; s++) {
					const r = this.getParsed(s),
						a = h || T(r[u.axis]) ? {
							base: d,
							head: d
						} : this._calculateBarValuePixels(s),
						t = this._calculateBarIndexPixels(s, p),
						e = (r._stacks || {})[u.axis],
						i = {
							horizontal: f,
							base: a.base,
							enableBorderRadius: !e || Ws(r._custom) || c === e._top || c === e._bottom,
							x: f ? a.head : t.center,
							y: f ? t.center : a.head,
							height: f ? t.size : Math.abs(a.size),
							width: f ? Math.abs(a.size) : t.size
						};
					m && (i.options = g || this.resolveDataElementOptions(s, o[s].active ? "active" : l));
					const n = i.options || o[s].options;
					Bs(i, n, e, c), Vs(i, n, p.ratio), this.updateElement(o[s], s, i, l)
				}
			}
			_getStacks(t, n) {
				const {
					iScale: e
				} = this._cachedMeta, i = e.getMatchingVisibleMetas(this._type).filter(t => t.controller.options.grouped), s = e.options.stacked, o = [], r = t => {
					const e = t.controller.getParsed(n),
						i = e && e[t.vScale.axis];
					if (T(i) || isNaN(i)) return !0
				};
				for (const e of i)
					if ((void 0 === n || !r(e)) && ((!1 === s || -1 === o.indexOf(e.stack) || void 0 === s && void 0 === e.stack) && o.push(e.stack), e.index === t)) break;
				return o.length || o.push(void 0), o
			}
			_getStackCount(t) {
				return this._getStacks(void 0, t).length
			}
			_getStackIndex(t, e, i) {
				const n = this._getStacks(t, i),
					s = void 0 !== e ? n.indexOf(e) : -1;
				return -1 === s ? n.length - 1 : s
			}
			_getRuler() {
				const t = this.options,
					e = this._cachedMeta,
					i = e.iScale,
					n = [];
				let s, o;
				for (s = 0, o = e.data.length; s < o; ++s) n.push(i.getPixelForValue(this.getParsed(s)[i.axis], s));
				const r = t.barThickness;
				return {
					min: r || Fs(e),
					pixels: n,
					start: i._startPixel,
					end: i._endPixel,
					stackCount: this._getStackCount(),
					scale: i,
					grouped: t.grouped,
					ratio: r ? 1 : t.categoryPercentage * t.barPercentage
				}
			}
			_calculateBarValuePixels(t) {
				const {
					_cachedMeta: {
						vScale: e,
						_stacked: i,
						index: n
					},
					options: {
						base: s,
						minBarLength: o
					}
				} = this, r = s || 0, a = this.getParsed(t), l = a._custom, h = Ws(l);
				let c, u, d = a[e.axis],
					f = 0,
					p = i ? this.applyStack(e, a, i) : d;
				p !== d && (f = p - d, p = d), h && (d = l.barStart, p = l.barEnd - l.barStart, 0 !== d && v(d) !== v(l.barEnd) && (f = 0), f += d);
				const g = T(s) || h ? f : s;
				let m = e.getPixelForValue(g);
				if (c = this.chart.getDataVisibility(t) ? e.getPixelForValue(f + p) : m, u = c - m, Math.abs(u) < o) {
					u = function (t, e, i) {
						return 0 !== t ? v(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1)
					}(u, e, r) * o, d === r && (m -= u / 2);
					const t = e.getPixelForDecimal(0),
						T = e.getPixelForDecimal(1),
						s = Math.min(t, T),
						l = Math.max(t, T);
					m = Math.max(Math.min(m, l), s), c = m + u, i && !h && (a._stacks[e.axis]._visualValues[n] = e.getValueForPixel(c) - e.getValueForPixel(m))
				}
				if (m === e.getPixelForValue(r)) {
					const t = v(u) * e.getLineWidthForValue(r) / 2;
					m += t, u -= t
				}
				return {
					size: u,
					base: m,
					head: c,
					center: c + u / 2
				}
			}
			_calculateBarIndexPixels(e, i) {
				const n = i.scale,
					s = this.options,
					o = s.skipNull,
					r = O(s.maxBarThickness, 1 / 0);
				let a, l;
				if (i.grouped) {
					const n = o ? this._getStackCount(e) : i.stackCount,
						O = "flex" === s.barThickness ? function (t, e, i, n) {
							const s = e.pixels,
								o = s[t];
							let r = t > 0 ? s[t - 1] : null,
								a = t < s.length - 1 ? s[t + 1] : null;
							const l = i.categoryPercentage;
							null === r && (r = o - (null === a ? e.end - e.start : a - o)), null === a && (a = o + o - r);
							const h = o - (o - Math.min(r, a)) / 2 * l;
							return {
								chunk: Math.abs(a - r) / 2 * l / n,
								ratio: i.barPercentage,
								start: h
							}
						}(e, i, s, n) : function (t, e, i, n) {
							const s = i.barThickness;
							let o, r;
							return T(s) ? (o = e.min * i.categoryPercentage, r = i.barPercentage) : (o = s * n, r = 1), {
								chunk: o / n,
								ratio: r,
								start: e.pixels[t] - o / 2
							}
						}(e, i, s, n),
						t = this._getStackIndex(this.index, this._cachedMeta.stack, o ? e : void 0);
					a = O.start + O.chunk * t + O.chunk / 2, l = Math.min(r, O.chunk * O.ratio)
				} else a = n.getPixelForValue(this.getParsed(e)[n.axis], e), l = Math.min(r, i.min * i.ratio);
				return {
					base: a - l / 2,
					head: a + l / 2,
					center: a,
					size: l
				}
			}
			draw() {
				const t = this._cachedMeta,
					e = t.vScale,
					i = t.data,
					n = i.length;
				let s = 0;
				for (; s < n; ++s) null !== this.getParsed(s)[e.axis] && i[s].draw(this._ctx)
			}
		},
		BubbleController: class extends Gn {
			static id = "bubble";
			static defaults = {
				datasetElementType: !1,
				dataElementType: "point",
				animations: {
					numbers: {
						type: "number",
						properties: ["x", "y", "borderWidth", "radius"]
					}
				}
			};
			static overrides = {
				scales: {
					x: {
						type: "linear"
					},
					y: {
						type: "linear"
					}
				}
			};
			initialize() {
				this.enableOptionSharing = !0, super.initialize()
			}
			parsePrimitiveData(t, e, i, n) {
				const s = super.parsePrimitiveData(t, e, i, n);
				for (let t = 0; t < s.length; t++) s[t]._custom = this.resolveDataElementOptions(t + i).radius;
				return s
			}
			parseArrayData(t, e, i, n) {
				const s = super.parseArrayData(t, e, i, n);
				for (let t = 0; t < s.length; t++) {
					const n = e[i + t];
					s[t]._custom = O(n[2], this.resolveDataElementOptions(t + i).radius)
				}
				return s
			}
			parseObjectData(t, e, i, n) {
				const s = super.parseObjectData(t, e, i, n);
				for (let t = 0; t < s.length; t++) {
					const n = e[i + t];
					s[t]._custom = O(n && n.r && +n.r, this.resolveDataElementOptions(t + i).radius)
				}
				return s
			}
			getMaxOverflow() {
				const e = this._cachedMeta.data;
				let i = 0;
				for (let t = e.length - 1; t >= 0; --t) i = Math.max(i, e[t].size(this.resolveDataElementOptions(t)) / 2);
				return i > 0 && i
			}
			getLabelAndValue(t) {
				const e = this._cachedMeta,
					i = this.chart.data.labels || [],
					{
						xScale: n,
						yScale: s
					} = e,
					o = this.getParsed(t),
					r = n.getLabelForValue(o.x),
					a = s.getLabelForValue(o.y),
					l = o._custom;
				return {
					label: i[t] || "",
					value: "(" + r + ", " + a + (l ? ", " + l : "") + ")"
				}
			}
			update(t) {
				const e = this._cachedMeta.data;
				this.updateElements(e, 0, e.length, t)
			}
			updateElements(s, o, r, a) {
				const l = "reset" === a,
					{
						iScale: h,
						vScale: c
					} = this._cachedMeta,
					{
						sharedOptions: u,
						includeOptions: d
					} = this._getSharedOptions(o, a),
					f = h.axis,
					p = c.axis;
				for (let n = o; n < o + r; n++) {
					const o = s[n],
						r = !l && this.getParsed(n),
						t = {},
						e = t[f] = l ? h.getPixelForDecimal(.5) : h.getPixelForValue(r[f]),
						i = t[p] = l ? c.getBasePixel() : c.getPixelForValue(r[p]);
					t.skip = isNaN(e) || isNaN(i), d && (t.options = u || this.resolveDataElementOptions(n, o.active ? "active" : a), l && (t.options.radius = 0)), this.updateElement(o, n, t, a)
				}
			}
			resolveDataElementOptions(t, e) {
				const i = this.getParsed(t);
				let n = super.resolveDataElementOptions(t, e);
				n.$shared && (n = Object.assign({}, n, {
					$shared: !1
				}));
				const s = n.radius;
				return "active" !== e && (n.radius = 0), n.radius += O(i && i._custom, s), n
			}
		},
		DoughnutController: $s,
		LineController: class extends Gn {
			static id = "line";
			static defaults = {
				datasetElementType: "line",
				dataElementType: "point",
				showLine: !0,
				spanGaps: !1
			};
			static overrides = {
				scales: {
					_index_: {
						type: "category"
					},
					_value_: {
						type: "linear"
					}
				}
			};
			initialize() {
				this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize()
			}
			update(t) {
				const e = this._cachedMeta,
					{
						dataset: i,
						data: n = [],
						_dataset: s
					} = e,
					o = this.chart._animationsDisabled;
				let {
					start: r,
					count: a
				} = Pt(e, n, o);
				this._drawStart = r, this._drawCount = a, It(e) && (r = 0, a = n.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!s._decimated, i.points = n;
				const l = this.resolveDatasetElementOptions(t);
				this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {
					animated: !o,
					options: l
				}, t), this.updateElements(n, r, a, t)
			}
			updateElements(o, r, t, a) {
				const l = "reset" === a,
					{
						iScale: h,
						vScale: c,
						_stacked: u,
						_dataset: d
					} = this._cachedMeta,
					{
						sharedOptions: f,
						includeOptions: p
					} = this._getSharedOptions(r, a),
					g = h.axis,
					m = c.axis,
					{
						spanGaps: v,
						segment: b
					} = this.options,
					_ = at(v) ? v : Number.POSITIVE_INFINITY,
					y = this.chart._animationsDisabled || l || "none" === a,
					x = r + t,
					w = o.length;
				let k = r > 0 && this.getParsed(r - 1);
				for (let s = 0; s < w; ++s) {
					const v = o[s],
						w = y ? v : {};
					if (s < r || s >= x) {
						w.skip = !0;
						continue
					}
					const t = this.getParsed(s),
						e = T(t[m]),
						i = w[g] = h.getPixelForValue(t[g], s),
						n = w[m] = l || e ? c.getBasePixel() : c.getPixelForValue(u ? this.applyStack(c, t, u) : t[m], s);
					w.skip = isNaN(i) || isNaN(n) || e, w.stop = s > 0 && Math.abs(t[g] - k[g]) > _, b && (w.parsed = t, w.raw = d.data[s]), p && (w.options = f || this.resolveDataElementOptions(s, v.active ? "active" : a)), y || this.updateElement(v, s, w, a), k = t
				}
			}
			getMaxOverflow() {
				const t = this._cachedMeta,
					e = t.dataset,
					i = e.options && e.options.borderWidth || 0,
					n = t.data || [];
				if (!n.length) return i;
				const s = n[0].size(this.resolveDataElementOptions(0)),
					o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));
				return Math.max(i, s, o) / 2
			}
			draw() {
				const t = this._cachedMeta;
				t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw()
			}
		},
		PieController: class extends $s {
			static id = "pie";
			static defaults = {
				cutout: 0,
				rotation: 0,
				circumference: 360,
				radius: "100%"
			}
		},
		PolarAreaController: Us,
		RadarController: class extends Gn {
			static id = "radar";
			static defaults = {
				datasetElementType: "line",
				dataElementType: "point",
				indexAxis: "r",
				showLine: !0,
				elements: {
					line: {
						fill: "start"
					}
				}
			};
			static overrides = {
				aspectRatio: 1,
				scales: {
					r: {
						type: "radialLinear"
					}
				}
			};
			getLabelAndValue(t) {
				const e = this._cachedMeta.vScale,
					i = this.getParsed(t);
				return {
					label: e.getLabels()[t],
					value: "" + e.getLabelForValue(i[e.axis])
				}
			}
			parseObjectData(t, e, i, n) {
				return ui.bind(this)(t, e, i, n)
			}
			update(e) {
				const i = this._cachedMeta,
					n = i.dataset,
					s = i.data || [],
					o = i.iScale.getLabels();
				if (n.points = s, "resize" !== e) {
					const i = this.resolveDatasetElementOptions(e);
					this.options.showLine || (i.borderWidth = 0);
					const t = {
						_loop: !0,
						_fullLoop: o.length === s.length,
						options: i
					};
					this.updateElement(n, void 0, t, e)
				}
				this.updateElements(s, 0, s.length, e)
			}
			updateElements(o, r, a, l) {
				const h = this._cachedMeta.rScale,
					c = "reset" === l;
				for (let s = r; s < r + a; s++) {
					const r = o[s],
						a = this.resolveDataElementOptions(s, r.active ? "active" : l),
						t = h.getPointPositionForValue(s, this.getParsed(s).r),
						e = c ? h.xCenter : t.x,
						i = c ? h.yCenter : t.y,
						n = {
							x: e,
							y: i,
							angle: t.angle,
							skip: isNaN(e) || isNaN(i),
							options: a
						};
					this.updateElement(r, s, n, l)
				}
			}
		},
		ScatterController: class extends Gn {
			static id = "scatter";
			static defaults = {
				datasetElementType: !1,
				dataElementType: "point",
				showLine: !1,
				fill: !1
			};
			static overrides = {
				interaction: {
					mode: "point"
				},
				scales: {
					x: {
						type: "linear"
					},
					y: {
						type: "linear"
					}
				}
			};
			getLabelAndValue(t) {
				const e = this._cachedMeta,
					i = this.chart.data.labels || [],
					{
						xScale: n,
						yScale: s
					} = e,
					o = this.getParsed(t),
					r = n.getLabelForValue(o.x),
					a = s.getLabelForValue(o.y);
				return {
					label: i[t] || "",
					value: "(" + r + ", " + a + ")"
				}
			}
			update(e) {
				const i = this._cachedMeta,
					{
						data: n = []
					} = i,
					s = this.chart._animationsDisabled;
				let {
					start: o,
					count: r
				} = Pt(i, n, s);
				if (this._drawStart = o, this._drawCount = r, It(i) && (o = 0, r = n.length), this.options.showLine) {
					const {
						dataset: o,
						_dataset: r
					} = i;
					o._chart = this.chart, o._datasetIndex = this.index, o._decimated = !!r._decimated, o.points = n;
					const t = this.resolveDatasetElementOptions(e);
					t.segment = this.options.segment, this.updateElement(o, void 0, {
						animated: !s,
						options: t
					}, e)
				}
				this.updateElements(n, o, r, e)
			}
			addElements() {
				const {
					showLine: t
				} = this.options;
				!this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements()
			}
			updateElements(s, o, r, a) {
				const l = "reset" === a,
					{
						iScale: h,
						vScale: c,
						_stacked: u,
						_dataset: d
					} = this._cachedMeta,
					t = this.resolveDataElementOptions(o, a),
					f = this.getSharedOptions(t),
					p = this.includeOptions(a, f),
					g = h.axis,
					m = c.axis,
					{
						spanGaps: v,
						segment: b
					} = this.options,
					_ = at(v) ? v : Number.POSITIVE_INFINITY,
					y = this.chart._animationsDisabled || l || "none" === a;
				let x = o > 0 && this.getParsed(o - 1);
				for (let n = o; n < o + r; ++n) {
					const o = s[n],
						r = this.getParsed(n),
						v = y ? o : {},
						t = T(r[m]),
						e = v[g] = h.getPixelForValue(r[g], n),
						i = v[m] = l || t ? c.getBasePixel() : c.getPixelForValue(u ? this.applyStack(c, r, u) : r[m], n);
					v.skip = isNaN(e) || isNaN(i) || t, v.stop = n > 0 && Math.abs(r[g] - x[g]) > _, b && (v.parsed = r, v.raw = d.data[n]), p && (v.options = f || this.resolveDataElementOptions(n, o.active ? "active" : a)), y || this.updateElement(o, n, v, a), x = r
				}
				this.updateSharedOptions(f, a, t)
			}
			getMaxOverflow() {
				const t = this._cachedMeta,
					i = t.data || [];
				if (!this.options.showLine) {
					let e = 0;
					for (let t = i.length - 1; t >= 0; --t) e = Math.max(e, i[t].size(this.resolveDataElementOptions(t)) / 2);
					return e > 0 && e
				}
				const e = t.dataset,
					n = e.options && e.options.borderWidth || 0;
				if (!i.length) return n;
				const s = i[0].size(this.resolveDataElementOptions(0)),
					o = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
				return Math.max(n, s, o) / 2
			}
		}
	});

	function Gs(t, e, i, n) {
		const s = Ii(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
		const o = (i - e) / 2,
			r = Math.min(o, n * e / 2),
			a = t => {
				const e = (i - Math.min(o, t)) * n / 2;
				return _(t, 0, Math.min(o, e))
			};
		return {
			outerStart: a(s.outerStart),
			outerEnd: a(s.outerEnd),
			innerStart: _(s.innerStart, 0, r),
			innerEnd: _(s.innerEnd, 0, r)
		}
	}

	function Ks(t, e, i, n) {
		return {
			x: i + t * Math.cos(e),
			y: n + t * Math.sin(e)
		}
	}

	function Xs(t, e, i, n, s, o) {
		const {
			x: r,
			y: a,
			startAngle: l,
			pixelMargin: h,
			innerRadius: c
		} = e, u = Math.max(e.outerRadius + n + i - h, 0), d = c > 0 ? c + n + i + h : 0;
		let f = 0;
		const p = s - l;
		if (n) {
			const t = ((c > 0 ? c - n : 0) + (u > 0 ? u - n : 0)) / 2;
			f = (p - (0 !== t ? p * t / (t + n) : p)) / 2
		}
		const g = (p - Math.max(.001, p * u - i / A) / u) / 2,
			m = l + g + f,
			v = s - g - f,
			{
				outerStart: b,
				outerEnd: _,
				innerStart: y,
				innerEnd: x
			} = Gs(e, d, u, v - m),
			w = u - b,
			k = u - _,
			C = m + b / w,
			D = v - _ / k,
			M = d + y,
			T = d + x,
			S = m + y / M,
			P = v - x / T;
		if (t.beginPath(), o) {
			const e = (C + D) / 2;
			if (t.arc(r, a, u, C, e), t.arc(r, a, u, e, D), _ > 0) {
				const e = Ks(k, D, r, a);
				t.arc(e.x, e.y, _, D, v + L)
			}
			const i = Ks(T, v, r, a);
			if (t.lineTo(i.x, i.y), x > 0) {
				const e = Ks(T, P, r, a);
				t.arc(e.x, e.y, x, v + L, P + Math.PI)
			}
			const n = (v - x / d + (m + y / d)) / 2;
			if (t.arc(r, a, d, v - x / d, n, !0), t.arc(r, a, d, n, m + y / d, !0), y > 0) {
				const e = Ks(M, S, r, a);
				t.arc(e.x, e.y, y, S + Math.PI, m - L)
			}
			const s = Ks(w, m, r, a);
			if (t.lineTo(s.x, s.y), b > 0) {
				const e = Ks(w, C, r, a);
				t.arc(e.x, e.y, b, m - L, C)
			}
		} else {
			t.moveTo(r, a);
			const e = Math.cos(C) * u + r,
				i = Math.sin(C) * u + a;
			t.lineTo(e, i);
			const n = Math.cos(D) * u + r,
				s = Math.sin(D) * u + a;
			t.lineTo(n, s)
		}
		t.closePath()
	}

	function Zs(e, t, i, n, s) {
		const {
			fullCircles: o,
			startAngle: r,
			circumference: a,
			options: l
		} = t, {
			borderWidth: h,
			borderJoinStyle: c,
			borderDash: u,
			borderDashOffset: d
		} = l, f = "inner" === l.borderAlign;
		if (!h) return;
		e.setLineDash(u || []), e.lineDashOffset = d, f ? (e.lineWidth = 2 * h, e.lineJoin = c || "round") : (e.lineWidth = h, e.lineJoin = c || "bevel");
		let p = t.endAngle;
		if (o) {
			Xs(e, t, i, n, p, s);
			for (let t = 0; t < o; ++t) e.stroke();
			isNaN(a) || (p = r + (a % y || y))
		}
		f && function (t, e, i) {
			const {
				startAngle: n,
				pixelMargin: s,
				x: o,
				y: r,
				outerRadius: a,
				innerRadius: l
			} = e;
			let h = s / a;
			t.beginPath(), t.arc(o, r, a, n - h, i + h), l > s ? (h = s / l, t.arc(o, r, l, i + h, n - h, !0)) : t.arc(o, r, s, i + L, n - L), t.closePath(), t.clip()
		}(e, t, p), o || (Xs(e, t, i, n, p, s), e.stroke())
	}

	function Qs(t, e, i = e) {
		t.lineCap = O(i.borderCapStyle, e.borderCapStyle), t.setLineDash(O(i.borderDash, e.borderDash)), t.lineDashOffset = O(i.borderDashOffset, e.borderDashOffset), t.lineJoin = O(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = O(i.borderWidth, e.borderWidth), t.strokeStyle = O(i.borderColor, e.borderColor)
	}

	function Js(t, e, i) {
		t.lineTo(i.x, i.y)
	}

	function to(t, e, i = {}) {
		const n = t.length,
			{
				start: s = 0,
				end: o = n - 1
			} = i,
			{
				start: r,
				end: a
			} = e,
			l = Math.max(s, r),
			h = Math.min(o, a),
			c = s < r && o < r || s > a && o > a;
		return {
			count: n,
			start: l,
			loop: e.loop,
			ilen: h < l && !c ? n + h - l : h - l
		}
	}

	function eo(t, e, i, n) {
		const {
			points: s,
			options: o
		} = e, {
			count: r,
			start: a,
			loop: l,
			ilen: h
		} = to(s, i, n), c = function (t) {
			return t.stepped ? Ue : t.tension || "monotone" === t.cubicInterpolationMode ? qe : Js
		}(o);
		let u, d, f, {
			move: p = !0,
			reverse: g
		} = n || {};
		for (u = 0; u <= h; ++u) d = s[(a + (g ? h - u : u)) % r], d.skip || (p ? (t.moveTo(d.x, d.y), p = !1) : c(t, f, d, g, o.stepped), f = d);
		return l && (d = s[(a + (g ? h : 0)) % r], c(t, f, d, g, o.stepped)), !!l
	}

	function io(t, e, i, n) {
		const s = e.points,
			{
				count: o,
				start: r,
				ilen: a
			} = to(s, i, n),
			{
				move: l = !0,
				reverse: h
			} = n || {};
		let c, u, d, f, p, g, m = 0,
			v = 0;
		const b = t => (r + (h ? a - t : t)) % o,
			_ = () => {
				f !== p && (t.lineTo(m, p), t.lineTo(m, f), t.lineTo(m, g))
			};
		for (l && (u = s[b(0)], t.moveTo(u.x, u.y)), c = 0; c <= a; ++c) {
			if (u = s[b(c)], u.skip) continue;
			const e = u.x,
				i = u.y,
				n = 0 | e;
			n === d ? (i < f ? f = i : i > p && (p = i), m = (v * m + e) / ++v) : (_(), t.lineTo(e, i), d = n, v = 0, f = p = i), g = i
		}
		_()
	}

	function no(t) {
		const e = t.options,
			i = e.borderDash && e.borderDash.length;
		return !(t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || i) ? io : eo
	}
	const so = "function" == typeof Path2D;

	function oo(t, e, i, n) {
		so && !e.options.segment ? function (t, e, i, n) {
			let s = e._path;
			s || (s = e._path = new Path2D, e.path(s, i, n) && s.closePath()), Qs(t, e.options), t.stroke(s)
		}(t, e, i, n) : function (e, i, n, s) {
			const {
				segments: o,
				options: r
			} = i, a = no(i);
			for (const t of o) Qs(e, r, t.style), e.beginPath(), a(e, i, t, {
				start: n,
				end: n + s - 1
			}) && e.closePath(), e.stroke()
		}(t, e, i, n)
	}
	class ro extends e {
		static id = "line";
		static defaults = {
			borderCapStyle: "butt",
			borderDash: [],
			borderDashOffset: 0,
			borderJoinStyle: "miter",
			borderWidth: 3,
			capBezierPoints: !0,
			cubicInterpolationMode: "default",
			fill: !1,
			spanGaps: !1,
			stepped: !1,
			tension: 0
		};
		static defaultRoutes = {
			backgroundColor: "backgroundColor",
			borderColor: "borderColor"
		};
		static descriptors = {
			_scriptable: !0,
			_indexable: t => "borderDash" !== t && "fill" !== t
		};
		constructor(t) {
			super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t)
		}
		updateControlPoints(e, i) {
			const n = this.options;
			if ((n.tension || "monotone" === n.cubicInterpolationMode) && !n.stepped && !this._pointsUpdated) {
				const t = n.spanGaps ? this._loop : this._fullLoop;
				bi(this._points, n, e, t, i), this._pointsUpdated = !0
			}
		}
		set points(t) {
			this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1
		}
		get points() {
			return this._points
		}
		get segments() {
			return this._segments || (this._segments = Yi(this, this.options.segment))
		}
		first() {
			const t = this.segments,
				e = this.points;
			return t.length && e[t[0].start]
		}
		last() {
			const t = this.segments,
				e = this.points,
				i = t.length;
			return i && e[t[i - 1].end]
		}
		interpolate(s, o) {
			const r = this.options,
				a = s[o],
				l = this.points,
				h = ji(this, {
					property: o,
					start: a,
					end: a
				});
			if (!h.length) return;
			const c = [],
				u = function (t) {
					return t.stepped ? Ci : t.tension || "monotone" === t.cubicInterpolationMode ? Di : ki
				}(r);
			let d, f;
			for (d = 0, f = h.length; d < f; ++d) {
				const {
					start: f,
					end: t
				} = h[d], e = l[f], i = l[t];
				if (e === i) {
					c.push(e);
					continue
				}
				const n = u(e, i, Math.abs((a - e[o]) / (i[o] - e[o])), r.stepped);
				n[o] = s[o], c.push(n)
			}
			return 1 === c.length ? c[0] : c
		}
		pathSegment(t, e, i) {
			return no(this)(t, this, e, i)
		}
		path(e, i, n) {
			const s = this.segments,
				o = no(this);
			let r = this._loop;
			i = i || 0, n = n || this.points.length - i;
			for (const t of s) r &= o(e, this, t, {
				start: i,
				end: i + n - 1
			});
			return !!r
		}
		draw(t, e, i, n) {
			const s = this.options || {};
			(this.points || []).length && s.borderWidth && (t.save(), oo(t, this, i, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0)
		}
	}

	function ao(t, e, i, n) {
		const s = t.options,
			{
				[i]: o
			} = t.getProps([i], n);
		return Math.abs(e - o) < s.radius + s.hitRadius
	}

	function lo(t, e) {
		const {
			x: i,
			y: n,
			base: s,
			width: o,
			height: r
		} = t.getProps(["x", "y", "base", "width", "height"], e);
		let a, l, h, c, u;
		return t.horizontal ? (u = r / 2, a = Math.min(i, s), l = Math.max(i, s), h = n - u, c = n + u) : (u = o / 2, a = i - u, l = i + u, h = Math.min(n, s), c = Math.max(n, s)), {
			left: a,
			top: h,
			right: l,
			bottom: c
		}
	}

	function ho(t, e, i, n) {
		return t ? 0 : _(e, i, n)
	}

	function co(t) {
		const e = lo(t),
			i = e.right - e.left,
			n = e.bottom - e.top,
			s = function (t, e, i) {
				const n = t.options.borderWidth,
					s = t.borderSkipped,
					o = Ei(n);
				return {
					t: ho(s.top, o.top, 0, i),
					r: ho(s.right, o.right, 0, e),
					b: ho(s.bottom, o.bottom, 0, i),
					l: ho(s.left, o.left, 0, e)
				}
			}(t, i / 2, n / 2),
			o = function (t, e, i) {
				const {
					enableBorderRadius: n
				} = t.getProps(["enableBorderRadius"]), s = t.options.borderRadius, o = Oi(s), r = Math.min(e, i), a = t.borderSkipped, l = n || E(s);
				return {
					topLeft: ho(!l || a.top || a.left, o.topLeft, 0, r),
					topRight: ho(!l || a.top || a.right, o.topRight, 0, r),
					bottomLeft: ho(!l || a.bottom || a.left, o.bottomLeft, 0, r),
					bottomRight: ho(!l || a.bottom || a.right, o.bottomRight, 0, r)
				}
			}(t, i / 2, n / 2);
		return {
			outer: {
				x: e.left,
				y: e.top,
				w: i,
				h: n,
				radius: o
			},
			inner: {
				x: e.left + s.l,
				y: e.top + s.t,
				w: i - s.l - s.r,
				h: n - s.t - s.b,
				radius: {
					topLeft: Math.max(0, o.topLeft - Math.max(s.t, s.l)),
					topRight: Math.max(0, o.topRight - Math.max(s.t, s.r)),
					bottomLeft: Math.max(0, o.bottomLeft - Math.max(s.b, s.l)),
					bottomRight: Math.max(0, o.bottomRight - Math.max(s.b, s.r))
				}
			}
		}
	}

	function uo(t, e, i, n) {
		const s = null === e,
			o = null === i,
			r = t && !(s && o) && lo(t, n);
		return r && (s || x(e, r.left, r.right)) && (o || x(i, r.top, r.bottom))
	}

	function fo(t, e) {
		t.rect(e.x, e.y, e.w, e.h)
	}

	function po(t, e, i = {}) {
		const n = t.x !== i.x ? -e : 0,
			s = t.y !== i.y ? -e : 0,
			o = (t.x + t.w !== i.x + i.w ? e : 0) - n,
			r = (t.y + t.h !== i.y + i.h ? e : 0) - s;
		return {
			x: t.x + n,
			y: t.y + s,
			w: t.w + o,
			h: t.h + r,
			radius: t.radius
		}
	}
	var go = Object.freeze({
		__proto__: null,
		ArcElement: class extends e {
			static id = "arc";
			static defaults = {
				borderAlign: "center",
				borderColor: "#fff",
				borderDash: [],
				borderDashOffset: 0,
				borderJoinStyle: void 0,
				borderRadius: 0,
				borderWidth: 2,
				offset: 0,
				spacing: 0,
				angle: void 0,
				circular: !0
			};
			static defaultRoutes = {
				backgroundColor: "backgroundColor"
			};
			static descriptors = {
				_scriptable: !0,
				_indexable: t => "borderDash" !== t
			};
			circumference;
			endAngle;
			fullCircles;
			innerRadius;
			outerRadius;
			pixelMargin;
			startAngle;
			constructor(t) {
				super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t)
			}
			inRange(t, e, i) {
				const n = this.getProps(["x", "y"], i),
					{
						angle: s,
						distance: o
					} = dt(n, {
						x: t,
						y: e
					}),
					{
						startAngle: r,
						endAngle: a,
						innerRadius: l,
						outerRadius: h,
						circumference: c
					} = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i),
					u = (this.options.spacing + this.options.borderWidth) / 2,
					d = O(c, a - r) >= y || gt(s, r, a),
					f = x(o, l + u, h + u);
				return d && f
			}
			getCenterPoint(t) {
				const {
					x: e,
					y: i,
					startAngle: n,
					endAngle: s,
					innerRadius: o,
					outerRadius: r
				} = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], t), {
					offset: a,
					spacing: l
				} = this.options, h = (n + s) / 2, c = (o + r + l + a) / 2;
				return {
					x: e + Math.cos(h) * c,
					y: i + Math.sin(h) * c
				}
			}
			tooltipPosition(t) {
				return this.getCenterPoint(t)
			}
			draw(t) {
				const {
					options: e,
					circumference: i
				} = this, n = (e.offset || 0) / 4, s = (e.spacing || 0) / 2, o = e.circular;
				if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0, this.fullCircles = i > y ? Math.floor(i / y) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;
				t.save();
				const r = (this.startAngle + this.endAngle) / 2;
				t.translate(Math.cos(r) * n, Math.sin(r) * n);
				const a = n * (1 - Math.sin(Math.min(A, i || 0)));
				t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor,
					function (e, t, i, n, s) {
						const {
							fullCircles: o,
							startAngle: r,
							circumference: a
						} = t;
						let l = t.endAngle;
						if (o) {
							Xs(e, t, i, n, l, s);
							for (let t = 0; t < o; ++t) e.fill();
							isNaN(a) || (l = r + (a % y || y))
						}
						Xs(e, t, i, n, l, s), e.fill()
					}(t, this, a, s, o), Zs(t, this, a, s, o), t.restore()
			}
		},
		BarElement: class extends e {
			static id = "bar";
			static defaults = {
				borderSkipped: "start",
				borderWidth: 0,
				borderRadius: 0,
				inflateAmount: "auto",
				pointStyle: void 0
			};
			static defaultRoutes = {
				backgroundColor: "backgroundColor",
				borderColor: "borderColor"
			};
			constructor(t) {
				super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t)
			}
			draw(t) {
				const {
					inflateAmount: e,
					options: {
						borderColor: i,
						backgroundColor: n
					}
				} = this, {
					inner: s,
					outer: o
				} = co(this), r = (a = o.radius).topLeft || a.topRight || a.bottomLeft || a.bottomRight ? Ze : fo;
				var a;
				t.save(), o.w === s.w && o.h === s.h || (t.beginPath(), r(t, po(o, e, s)), t.clip(), r(t, po(s, -e, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), r(t, po(s, e)), t.fillStyle = n, t.fill(), t.restore()
			}
			inRange(t, e, i) {
				return uo(this, t, e, i)
			}
			inXRange(t, e) {
				return uo(this, t, null, e)
			}
			inYRange(t, e) {
				return uo(this, null, t, e)
			}
			getCenterPoint(t) {
				const {
					x: e,
					y: i,
					base: n,
					horizontal: s
				} = this.getProps(["x", "y", "base", "horizontal"], t);
				return {
					x: s ? (e + n) / 2 : e,
					y: s ? i : (i + n) / 2
				}
			}
			getRange(t) {
				return "x" === t ? this.width / 2 : this.height / 2
			}
		},
		LineElement: ro,
		PointElement: class extends e {
			static id = "point";
			parsed;
			skip;
			stop;
			static defaults = {
				borderWidth: 1,
				hitRadius: 1,
				hoverBorderWidth: 1,
				hoverRadius: 4,
				pointStyle: "circle",
				radius: 3,
				rotation: 0
			};
			static defaultRoutes = {
				backgroundColor: "backgroundColor",
				borderColor: "borderColor"
			};
			constructor(t) {
				super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t)
			}
			inRange(t, e, i) {
				const n = this.options,
					{
						x: s,
						y: o
					} = this.getProps(["x", "y"], i);
				return Math.pow(t - s, 2) + Math.pow(e - o, 2) < Math.pow(n.hitRadius + n.radius, 2)
			}
			inXRange(t, e) {
				return ao(this, t, "x", e)
			}
			inYRange(t, e) {
				return ao(this, t, "y", e)
			}
			getCenterPoint(t) {
				const {
					x: e,
					y: i
				} = this.getProps(["x", "y"], t);
				return {
					x: e,
					y: i
				}
			}
			size(t) {
				let e = (t = t || this.options || {}).radius || 0;
				e = Math.max(e, e && t.hoverRadius || 0);
				return 2 * (e + (e && t.borderWidth || 0))
			}
			draw(t, e) {
				const i = this.options;
				this.skip || i.radius < .1 || !u(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, je(t, i, this.x, this.y))
			}
			getRange() {
				const t = this.options || {};
				return t.radius + t.hitRadius
			}
		}
	});

	function mo(t, e, i, n) {
		const s = t.indexOf(e);
		if (-1 === s) return ((t, e, i, n) => ("string" == typeof e ? (i = t.push(e) - 1, n.unshift({
			index: i,
			label: e
		})) : isNaN(e) && (i = null), i))(t, e, i, n);
		return s !== t.lastIndexOf(e) ? i : s
	}

	function vo(t) {
		const e = this.getLabels();
		return t >= 0 && t < e.length ? e[t] : t
	}

	function bo(t, e, {
		horizontal: i,
		minRotation: n
	}) {
		const s = N(n),
			o = (i ? Math.sin(s) : Math.cos(s)) || .001,
			r = .75 * e * ("" + t).length;
		return Math.min(e / o, r)
	}
	class _o extends ss {
		constructor(t) {
			super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
		}
		parse(t, e) {
			return T(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t
		}
		handleTickRangeOptions() {
			const {
				beginAtZero: e
			} = this.options, {
				minDefined: i,
				maxDefined: n
			} = this.getUserBounds();
			let {
				min: s,
				max: o
			} = this;
			const r = t => s = i ? s : t,
				a = t => o = n ? o : t;
			if (e) {
				const e = v(s),
					i = v(o);
				e < 0 && i < 0 ? a(0) : e > 0 && i > 0 && r(0)
			}
			if (s === o) {
				let t = 0 === o ? 1 : Math.abs(.05 * o);
				a(o + t), e || r(s - t)
			}
			this.min = s, this.max = o
		}
		getTickLimit() {
			const t = this.options.ticks;
			let e, {
				maxTicksLimit: i,
				stepSize: n
			} = t;
			return n ? (e = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize:${n}would result generating up to ${e}ticks.Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e
		}
		computeTickLimit() {
			return Number.POSITIVE_INFINITY
		}
		buildTicks() {
			const t = this.options,
				e = t.ticks;
			let i = this.getTickLimit();
			i = Math.max(2, i);
			const n = function (t, e) {
				const i = [],
					{
						bounds: n,
						step: s,
						min: o,
						max: r,
						precision: a,
						count: l,
						maxTicks: h,
						maxDigits: c,
						includeBounds: u
					} = t,
					d = s || 1,
					f = h - 1,
					{
						min: p,
						max: g
					} = e,
					m = !T(o),
					v = !T(r),
					b = !T(l),
					_ = (g - p) / (c + 1);
				let y, x, w, k, C = ot((g - p) / f / d) * d;
				if (C < 1e-14 && !m && !v) return [{
					value: p
				}, {
					value: g
				}];
				k = Math.ceil(g / C) - Math.floor(p / C), k > f && (C = ot(k * C / f / d) * d), T(a) || (y = Math.pow(10, a), C = Math.ceil(C * y) / y), "ticks" === n ? (x = Math.floor(p / C) * C, w = Math.ceil(g / C) * C) : (x = p, w = g), m && v && s && lt((r - o) / s, C / 1e3) ? (k = Math.round(Math.min((r - o) / C, h)), C = (r - o) / k, x = o, w = r) : b ? (x = m ? o : x, w = v ? r : w, k = l - 1, C = (w - x) / k) : (k = (w - x) / C, k = st(k, Math.round(k), C / 1e3) ? Math.round(k) : Math.ceil(k));
				const D = Math.max(ut(C), ut(x));
				y = Math.pow(10, T(a) ? D : a), x = Math.round(x * y) / y, w = Math.round(w * y) / y;
				let M = 0;
				for (m && (u && x !== o ? (i.push({
					value: o
				}), x < o && M++, st(Math.round((x + M * C) * y) / y, o, bo(o, _, t)) && M++) : x < o && M++); M < k; ++M) {
					const t = Math.round((x + M * C) * y) / y;
					if (v && t > r) break;
					i.push({
						value: t
					})
				}
				return v && u && w !== r ? i.length && st(i[i.length - 1].value, r, bo(r, _, t)) ? i[i.length - 1].value = r : i.push({
					value: r
				}) : v && w !== r || i.push({
					value: w
				}), i
			}({
				maxTicks: i,
				bounds: t.bounds,
				min: t.min,
				max: t.max,
				precision: e.precision,
				step: e.stepSize,
				count: e.count,
				maxDigits: this._maxDigits(),
				horizontal: this.isHorizontal(),
				minRotation: e.minRotation || 0,
				includeBounds: !1 !== e.includeBounds
			}, this._range || this);
			return "ticks" === t.bounds && ht(n, this, "value"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n
		}
		configure() {
			const e = this.ticks;
			let i = this.min,
				n = this.max;
			if (super.configure(), this.options.offset && e.length) {
				const t = (n - i) / Math.max(e.length - 1, 1) / 2;
				i -= t, n += t
			}
			this._startValue = i, this._endValue = n, this._valueRange = n - i
		}
		getLabelForValue(t) {
			return ge(t, this.chart.options.locale, this.options.ticks.format)
		}
	}
	class yo extends _o {
		static id = "linear";
		static defaults = {
			ticks: {
				callback: ve.formatters.numeric
			}
		};
		determineDataLimits() {
			const {
				min: t,
				max: e
			} = this.getMinMax(!0);
			this.min = p(t) ? t : 0, this.max = p(e) ? e : 1, this.handleTickRangeOptions()
		}
		computeTickLimit() {
			const t = this.isHorizontal(),
				e = t ? this.width : this.height,
				i = N(this.options.ticks.minRotation),
				n = (t ? Math.sin(i) : Math.cos(i)) || .001,
				s = this._resolveTickFontOptions(0);
			return Math.ceil(e / Math.min(40, s.lineHeight / n))
		}
		getPixelForValue(t) {
			return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
		}
		getValueForPixel(t) {
			return this._startValue + this.getDecimalForPixel(t) * this._valueRange
		}
	}
	const xo = t => Math.floor(h(t)),
		wo = (t, e) => Math.pow(10, xo(t) + e);

	function ko(t) {
		return 1 === t / Math.pow(10, xo(t))
	}

	function Co(t, e, i) {
		const n = Math.pow(10, i),
			s = Math.floor(t / n);
		return Math.ceil(e / n) - s
	}

	function Do(t, {
		min: e,
		max: i
	}) {
		e = g(t.min, e);
		const n = [],
			s = xo(e);
		let o = function (t, e) {
			let i = xo(e - t);
			for (; Co(t, e, i) > 10;) i++;
			for (; Co(t, e, i) < 10;) i--;
			return Math.min(i, xo(t))
		}(e, i),
			r = o < 0 ? Math.pow(10, Math.abs(o)) : 1;
		const a = Math.pow(10, o),
			l = s > o ? Math.pow(10, s) : 0,
			h = Math.round((e - l) * r) / r,
			c = Math.floor((e - l) / a / 10) * a * 10;
		let u = Math.floor((h - c) / Math.pow(10, o)),
			d = g(t.min, Math.round((l + c + u * Math.pow(10, o)) * r) / r);
		for (; d < i;) n.push({
			value: d,
			major: ko(d),
			significand: u
		}), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, r = o >= 0 ? 1 : r), d = Math.round((l + c + u * Math.pow(10, o)) * r) / r;
		const f = g(t.max, d);
		return n.push({
			value: f,
			major: ko(f),
			significand: u
		}), n
	}
	class Mo extends ss {
		static id = "logarithmic";
		static defaults = {
			ticks: {
				callback: ve.formatters.logarithmic,
				major: {
					enabled: !0
				}
			}
		};
		constructor(t) {
			super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
		}
		parse(t, e) {
			const i = _o.prototype.parse.apply(this, [t, e]);
			if (0 !== i) return p(i) && i > 0 ? i : null;
			this._zero = !0
		}
		determineDataLimits() {
			const {
				min: t,
				max: e
			} = this.getMinMax(!0);
			this.min = p(t) ? Math.max(0, t) : null, this.max = p(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !p(this._userMin) && (this.min = t === wo(this.min, 0) ? wo(this.min, -1) : wo(this.min, 0)), this.handleTickRangeOptions()
		}
		handleTickRangeOptions() {
			const {
				minDefined: e,
				maxDefined: i
			} = this.getUserBounds();
			let n = this.min,
				s = this.max;
			const t = t => n = e ? n : t,
				o = t => s = i ? s : t;
			n === s && (n <= 0 ? (t(1), o(10)) : (t(wo(n, -1)), o(wo(s, 1)))), n <= 0 && t(wo(s, -1)), s <= 0 && o(wo(n, 1)), this.min = n, this.max = s
		}
		buildTicks() {
			const t = this.options,
				e = Do({
					min: this._userMin,
					max: this._userMax
				}, this);
			return "ticks" === t.bounds && ht(e, this, "value"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e
		}
		getLabelForValue(t) {
			return void 0 === t ? "0" : ge(t, this.chart.options.locale, this.options.ticks.format)
		}
		configure() {
			const t = this.min;
			super.configure(), this._startValue = h(t), this._valueRange = h(this.max) - h(t)
		}
		getPixelForValue(t) {
			return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (h(t) - this._startValue) / this._valueRange)
		}
		getValueForPixel(t) {
			const e = this.getDecimalForPixel(t);
			return Math.pow(10, this._startValue + e * this._valueRange)
		}
	}

	function To(t) {
		const e = t.ticks;
		if (e.display && t.display) {
			const t = R(e.backdropPadding);
			return O(e.font && e.font.size, S.font.size) + t.height
		}
		return 0
	}

	function So(t, e, i, n, s) {
		return t === n || t === s ? {
			start: e - i / 2,
			end: e + i / 2
		} : t < n || t > s ? {
			start: e - i,
			end: e
		} : {
			start: e,
			end: e + i
		}
	}

	function Po(r) {
		const a = {
			l: r.left + r._padding.left,
			r: r.right - r._padding.right,
			t: r.top + r._padding.top,
			b: r.bottom - r._padding.bottom
		},
			l = Object.assign({}, a),
			h = [],
			c = [],
			u = r._pointLabels.length,
			d = r.options.pointLabels,
			f = d.centerPointLabels ? A / u : 0;
		for (let o = 0; o < u; o++) {
			const u = d.setContext(r.getPointLabelContext(o));
			c[o] = u.padding;
			const t = r.getPointPosition(o, r.drawingArea + c[o], f),
				e = P(u.font),
				i = (p = r.ctx, g = e, m = I(m = r._pointLabels[o]) ? m : [m], {
					w: ze(p, g.string, m),
					h: m.length * g.lineHeight
				});
			h[o] = i;
			const n = b(r.getIndexAngle(o) + f),
				s = Math.round(ct(n));
			Io(l, a, n, So(s, t.x, i.w, 0, 180), So(s, t.y, i.h, 90, 270))
		}
		var p, g, m;
		r.setCenterPoint(a.l - l.l, l.r - a.r, a.t - l.t, l.b - a.b), r._pointLabelItems = function (e, i, n) {
			const s = [],
				o = e._pointLabels.length,
				t = e.options,
				{
					centerPointLabels: r,
					display: a
				} = t.pointLabels,
				l = {
					extra: To(t) / 2,
					additionalAngle: r ? A / o : 0
				};
			let h;
			for (let t = 0; t < o; t++) {
				l.padding = n[t], l.size = i[t];
				const o = Eo(e, t, l);
				s.push(o), "auto" === a && (o.visible = Oo(o, h), o.visible && (h = o))
			}
			return s
		}(r, h, c)
	}

	function Io(t, e, i, n, s) {
		const o = Math.abs(Math.sin(i)),
			r = Math.abs(Math.cos(i));
		let a = 0,
			l = 0;
		n.start < e.l ? (a = (e.l - n.start) / o, t.l = Math.min(t.l, e.l - a)) : n.end > e.r && (a = (n.end - e.r) / o, t.r = Math.max(t.r, e.r + a)), s.start < e.t ? (l = (e.t - s.start) / r, t.t = Math.min(t.t, e.t - l)) : s.end > e.b && (l = (s.end - e.b) / r, t.b = Math.max(t.b, e.b + l))
	}

	function Eo(t, e, i) {
		const n = t.drawingArea,
			{
				extra: s,
				additionalAngle: o,
				padding: r,
				size: a
			} = i,
			l = t.getPointPosition(e, n + s + r, o),
			h = Math.round(ct(b(l.angle + L))),
			c = function (t, e, i) {
				90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e);
				return t
			}(l.y, a.h, h),
			u = function (t) {
				if (0 === t || 180 === t) return "center";
				if (t < 180) return "left";
				return "right"
			}(h),
			d = function (t, e, i) {
				"right" === i ? t -= e : "center" === i && (t -= e / 2);
				return t
			}(l.x, a.w, u);
		return {
			visible: !0,
			x: l.x,
			y: c,
			textAlign: u,
			left: d,
			top: c,
			right: d + a.w,
			bottom: c + a.h
		}
	}

	function Oo(t, e) {
		if (!e) return !0;
		const {
			left: i,
			top: n,
			right: s,
			bottom: o
		} = t;
		return !(u({
			x: i,
			y: n
		}, e) || u({
			x: i,
			y: o
		}, e) || u({
			x: s,
			y: n
		}, e) || u({
			x: s,
			y: o
		}, e))
	}

	function Ao(s, o, r) {
		const {
			left: a,
			top: l,
			right: h,
			bottom: c
		} = r, {
			backdropColor: u
		} = o;
		if (!T(u)) {
			const r = Oi(o.borderRadius),
				T = R(o.backdropPadding);
			s.fillStyle = u;
			const t = a - T.left,
				e = l - T.top,
				i = h - a + T.width,
				n = c - l + T.height;
			Object.values(r).some(t => 0 !== t) ? (s.beginPath(), Ze(s, {
				x: t,
				y: e,
				w: i,
				h: n,
				radius: r
			}), s.fill()) : s.fillRect(t, e, i, n)
		}
	}

	function Lo(i, n, t, s) {
		const {
			ctx: o
		} = i;
		if (t) o.arc(i.xCenter, i.yCenter, n, 0, y);
		else {
			let e = i.getPointPosition(0, n);
			o.moveTo(e.x, e.y);
			for (let t = 1; t < s; t++) e = i.getPointPosition(t, n), o.lineTo(e.x, e.y)
		}
	}
	class No extends _o {
		static id = "radialLinear";
		static defaults = {
			display: !0,
			animate: !0,
			position: "chartArea",
			angleLines: {
				display: !0,
				lineWidth: 1,
				borderDash: [],
				borderDashOffset: 0
			},
			grid: {
				circular: !1
			},
			startAngle: 0,
			ticks: {
				showLabelBackdrop: !0,
				callback: ve.formatters.numeric
			},
			pointLabels: {
				backdropColor: void 0,
				backdropPadding: 2,
				display: !0,
				font: {
					size: 10
				},
				callback: t => t,
				padding: 5,
				centerPointLabels: !1
			}
		};
		static defaultRoutes = {
			"angleLines.color": "borderColor",
			"pointLabels.color": "color",
			"ticks.color": "color"
		};
		static descriptors = {
			angleLines: {
				_fallback: "grid"
			}
		};
		constructor(t) {
			super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
		}
		setDimensions() {
			const t = this._padding = R(To(this.options) / 2),
				e = this.width = this.maxWidth - t.width,
				i = this.height = this.maxHeight - t.height;
			this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2)
		}
		determineDataLimits() {
			const {
				min: t,
				max: e
			} = this.getMinMax(!1);
			this.min = p(t) && !isNaN(t) ? t : 0, this.max = p(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions()
		}
		computeTickLimit() {
			return Math.ceil(this.drawingArea / To(this.options))
		}
		generateTickLabels(t) {
			_o.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e) => {
				const i = f(this.options.pointLabels.callback, [t, e], this);
				return i || 0 === i ? i : ""
			}).filter((t, e) => this.chart.getDataVisibility(e))
		}
		fit() {
			const t = this.options;
			t.display && t.pointLabels.display ? Po(this) : this.setCenterPoint(0, 0, 0, 0)
		}
		setCenterPoint(t, e, i, n) {
			this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, n))
		}
		getIndexAngle(t) {
			return b(t * (y / (this._pointLabels.length || 1)) + N(this.options.startAngle || 0))
		}
		getDistanceFromCenterForValue(t) {
			if (T(t)) return NaN;
			const e = this.drawingArea / (this.max - this.min);
			return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
		}
		getValueForDistanceFromCenter(t) {
			if (T(t)) return NaN;
			const e = t / (this.drawingArea / (this.max - this.min));
			return this.options.reverse ? this.max - e : this.min + e
		}
		getPointLabelContext(e) {
			const i = this._pointLabels || [];
			if (e >= 0 && e < i.length) {
				const t = i[e];
				return function (t, e, i) {
					return Ni(t, {
						label: i,
						index: e,
						type: "pointLabel"
					})
				}(this.getContext(), e, t)
			}
		}
		getPointPosition(t, e, i = 0) {
			const n = this.getIndexAngle(t) - L + i;
			return {
				x: Math.cos(n) * e + this.xCenter,
				y: Math.sin(n) * e + this.yCenter,
				angle: n
			}
		}
		getPointPositionForValue(t, e) {
			return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
		}
		getBasePosition(t) {
			return this.getPointPositionForValue(t || 0, this.getBaseValue())
		}
		getPointLabelPosition(t) {
			const {
				left: e,
				top: i,
				right: n,
				bottom: s
			} = this._pointLabelItems[t];
			return {
				left: e,
				top: i,
				right: n,
				bottom: s
			}
		}
		drawBackground() {
			const {
				backgroundColor: e,
				grid: {
					circular: i
				}
			} = this.options;
			if (e) {
				const t = this.ctx;
				t.save(), t.beginPath(), Lo(this, this.getDistanceFromCenterForValue(this._endValue), i, this._pointLabels.length), t.closePath(), t.fillStyle = e, t.fill(), t.restore()
			}
		}
		drawGrid() {
			const t = this.ctx,
				e = this.options,
				{
					angleLines: i,
					grid: o,
					border: r
				} = e,
				a = this._pointLabels.length;
			let n, l, s;
			if (e.pointLabels.display && function (r, a) {
				const {
					ctx: l,
					options: {
						pointLabels: h
					}
				} = r;
				for (let o = a - 1; o >= 0; o--) {
					const a = r._pointLabelItems[o];
					if (!a.visible) continue;
					const t = h.setContext(r.getPointLabelContext(o));
					Ao(l, t, a);
					const e = P(t.font),
						{
							x: i,
							y: n,
							textAlign: s
						} = a;
					Xe(l, r._pointLabels[o], i, n + e.lineHeight / 2, e, {
						color: t.color,
						textAlign: s,
						textBaseline: "middle"
					})
				}
			}(this, a), o.display && this.ticks.forEach((n, s) => {
				if (0 !== s) {
					l = this.getDistanceFromCenterForValue(n.value);
					const t = this.getContext(s),
						e = o.setContext(t),
						i = r.setContext(t);
					! function (t, e, i, n, s) {
						const o = t.ctx,
							r = e.circular,
							{
								color: a,
								lineWidth: l
							} = e;
						!r && !n || !a || !l || i < 0 || (o.save(), o.strokeStyle = a, o.lineWidth = l, o.setLineDash(s.dash), o.lineDashOffset = s.dashOffset, o.beginPath(), Lo(t, i, r, n), o.closePath(), o.stroke(), o.restore())
					}(this, e, l, a, i)
				}
			}), i.display) {
				for (t.save(), n = a - 1; n >= 0; n--) {
					const o = i.setContext(this.getPointLabelContext(n)),
						{
							color: r,
							lineWidth: a
						} = o;
					a && r && (t.lineWidth = a, t.strokeStyle = r, t.setLineDash(o.borderDash), t.lineDashOffset = o.borderDashOffset, l = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), s = this.getPointPosition(n, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(s.x, s.y), t.stroke())
				}
				t.restore()
			}
		}
		drawBorder() { }
		drawLabels() {
			const s = this.ctx,
				o = this.options,
				r = o.ticks;
			if (!r.display) return;
			const t = this.getIndexAngle(0);
			let a, l;
			s.save(), s.translate(this.xCenter, this.yCenter), s.rotate(t), s.textAlign = "center", s.textBaseline = "middle", this.ticks.forEach((t, e) => {
				if (0 === e && !o.reverse) return;
				const i = r.setContext(this.getContext(e)),
					n = P(i.font);
				if (a = this.getDistanceFromCenterForValue(this.ticks[e].value), i.showLabelBackdrop) {
					s.font = n.string, l = s.measureText(t.label).width, s.fillStyle = i.backdropColor;
					const o = R(i.backdropPadding);
					s.fillRect(-l / 2 - o.left, -a - n.size / 2 - o.top, l + o.width, n.size + o.height)
				}
				Xe(s, t.label, 0, -a, n, {
					color: i.color
				})
			}), s.restore()
		}
		drawTitle() { }
	}
	const Ro = {
		millisecond: {
			common: !0,
			size: 1,
			steps: 1e3
		},
		second: {
			common: !0,
			size: 1e3,
			steps: 60
		},
		minute: {
			common: !0,
			size: 6e4,
			steps: 60
		},
		hour: {
			common: !0,
			size: 36e5,
			steps: 24
		},
		day: {
			common: !0,
			size: 864e5,
			steps: 30
		},
		week: {
			common: !1,
			size: 6048e5,
			steps: 4
		},
		month: {
			common: !0,
			size: 2628e6,
			steps: 12
		},
		quarter: {
			common: !1,
			size: 7884e6,
			steps: 4
		},
		year: {
			common: !0,
			size: 3154e7
		}
	},
		k = Object.keys(Ro);

	function Fo(t, e) {
		return t - e
	}

	function Ho(t, e) {
		if (T(e)) return null;
		const i = t._adapter,
			{
				parser: n,
				round: s,
				isoWeekday: o
			} = t._parseOpts;
		let r = e;
		return "function" == typeof n && (r = n(r)), p(r) || (r = "string" == typeof n ? i.parse(r, n) : i.parse(r)), null === r ? null : (s && (r = "week" !== s || !at(o) && !0 !== o ? i.startOf(r, s) : i.startOf(r, "isoWeek", o)), +r)
	}

	function zo(e, i, n, s) {
		const o = k.length;
		for (let t = k.indexOf(e); t < o - 1; ++t) {
			const e = Ro[k[t]],
				o = e.steps ? e.steps : Number.MAX_SAFE_INTEGER;
			if (e.common && Math.ceil((n - i) / (o * e.size)) <= s) return k[t]
		}
		return k[o - 1]
	}

	function Wo(i, n, s) {
		if (s) {
			if (s.length) {
				const {
					lo: t,
					hi: e
				} = vt(s, n);
				i[s[t] >= n ? s[t] : s[e]] = !0
			}
		} else i[n] = !0
	}

	function Bo(t, e, i) {
		const n = [],
			s = {},
			o = e.length;
		let r, a;
		for (r = 0; r < o; ++r) a = e[r], s[a] = r, n.push({
			value: a,
			major: !1
		});
		return 0 !== o && i ? function (t, e, i, n) {
			const s = t._adapter,
				o = +s.startOf(e[0].value, n),
				r = e[e.length - 1].value;
			let a, l;
			for (a = o; a <= r; a = +s.add(a, 1, n)) l = i[a], l >= 0 && (e[l].major = !0);
			return e
		}(t, n, s, i) : n
	}
	class jo extends ss {
		static id = "time";
		static defaults = {
			bounds: "data",
			adapters: {},
			time: {
				parser: !1,
				unit: !1,
				round: !1,
				isoWeekday: !1,
				minUnit: "millisecond",
				displayFormats: {}
			},
			ticks: {
				source: "auto",
				callback: !1,
				major: {
					enabled: !1
				}
			}
		};
		constructor(t) {
			super(t), this._cache = {
				data: [],
				labels: [],
				all: []
			}, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
		}
		init(t, e = {}) {
			const i = t.time || (t.time = {}),
				n = this._adapter = new Rs._date(t.adapters.date);
			n.init(e), U(i.displayFormats, n.formats()), this._parseOpts = {
				parser: i.parser,
				round: i.round,
				isoWeekday: i.isoWeekday
			}, super.init(t), this._normalized = e.normalized
		}
		parse(t, e) {
			return void 0 === t ? null : Ho(this, t)
		}
		beforeLayout() {
			super.beforeLayout(), this._cache = {
				data: [],
				labels: [],
				all: []
			}
		}
		determineDataLimits() {
			const t = this.options,
				e = this._adapter,
				i = t.time.unit || "day";
			let {
				min: n,
				max: s,
				minDefined: o,
				maxDefined: r
			} = this.getUserBounds();

			function a(t) {
				o || isNaN(t.min) || (n = Math.min(n, t.min)), r || isNaN(t.max) || (s = Math.max(s, t.max))
			}
			o && r || (a(this._getLabelBounds()), "ticks" === t.bounds && "labels" === t.ticks.source || a(this.getMinMax(!1))), n = p(n) && !isNaN(n) ? n : +e.startOf(Date.now(), i), s = p(s) && !isNaN(s) ? s : +e.endOf(Date.now(), i) + 1, this.min = Math.min(n, s - 1), this.max = Math.max(n + 1, s)
		}
		_getLabelBounds() {
			const t = this.getLabelTimestamps();
			let e = Number.POSITIVE_INFINITY,
				i = Number.NEGATIVE_INFINITY;
			return t.length && (e = t[0], i = t[t.length - 1]), {
				min: e,
				max: i
			}
		}
		buildTicks() {
			const t = this.options,
				e = t.time,
				i = t.ticks,
				n = "labels" === i.source ? this.getLabelTimestamps() : this._generate();
			"ticks" === t.bounds && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);
			const s = this.min,
				o = _t(n, s, this.max);
			return this._unit = e.unit || (i.autoSkip ? zo(e.minUnit, this.min, this.max, this._getLabelCapacity(s)) : function (e, i, n, s, o) {
				for (let t = k.length - 1; t >= k.indexOf(n); t--) {
					const n = k[t];
					if (Ro[n].common && e._adapter.diff(o, s, n) >= i - 1) return n
				}
				return k[n ? k.indexOf(n) : 0]
			}(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && "year" !== this._unit ? function (i) {
				for (let t = k.indexOf(i) + 1, e = k.length; t < e; ++t)
					if (Ro[k[t]].common) return k[t]
			}(this._unit) : void 0, this.initOffsets(n), t.reverse && o.reverse(), Bo(this, o, this._majorUnit)
		}
		afterAutoSkip() {
			this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value))
		}
		initOffsets(t = []) {
			let e, i, n = 0,
				s = 0;
			this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), n = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), s = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);
			const o = t.length < 3 ? .5 : .25;
			n = _(n, 0, o), s = _(s, 0, o), this._offsets = {
				start: n,
				end: s,
				factor: 1 / (n + 1 + s)
			}
		}
		_generate() {
			const t = this._adapter,
				e = this.min,
				i = this.max,
				n = this.options,
				s = n.time,
				o = s.unit || zo(s.minUnit, e, i, this._getLabelCapacity(e)),
				r = O(n.ticks.stepSize, 1),
				a = "week" === o && s.isoWeekday,
				l = at(a) || !0 === a,
				h = {};
			let c, u, d = e;
			if (l && (d = +t.startOf(d, "isoWeek", a)), d = +t.startOf(d, l ? "day" : o), t.diff(i, e, o) > 1e5 * r) throw new Error(e + " and " + i + " are too far apart with stepSize of " + r + " " + o);
			const f = "data" === n.ticks.source && this.getDataTimestamps();
			for (c = d, u = 0; c < i; c = +t.add(c, r, o), u++) Wo(h, c, f);
			return c !== i && "ticks" !== n.bounds && 1 !== u || Wo(h, c, f), Object.keys(h).sort((t, e) => t - e).map(t => +t)
		}
		getLabelForValue(t) {
			const e = this._adapter,
				i = this.options.time;
			return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime)
		}
		format(t, e) {
			const i = this.options.time.displayFormats,
				n = this._unit,
				s = e || i[n];
			return this._adapter.format(t, s)
		}
		_tickFormatFunction(t, e, i, n) {
			const s = this.options,
				o = s.ticks.callback;
			if (o) return f(o, [t, e, i], this);
			const r = s.time.displayFormats,
				a = this._unit,
				l = this._majorUnit,
				h = a && r[a],
				c = l && r[l],
				u = i[e],
				d = l && c && u && u.major;
			return this._adapter.format(t, n || (d ? c : h))
		}
		generateTickLabels(t) {
			let e, i, n;
			for (e = 0, i = t.length; e < i; ++e) n = t[e], n.label = this._tickFormatFunction(n.value, e, t)
		}
		getDecimalForValue(t) {
			return null === t ? NaN : (t - this.min) / (this.max - this.min)
		}
		getPixelForValue(t) {
			const e = this._offsets,
				i = this.getDecimalForValue(t);
			return this.getPixelForDecimal((e.start + i) * e.factor)
		}
		getValueForPixel(t) {
			const e = this._offsets,
				i = this.getDecimalForPixel(t) / e.factor - e.end;
			return this.min + i * (this.max - this.min)
		}
		_getLabelSize(t) {
			const e = this.options.ticks,
				i = this.ctx.measureText(t).width,
				n = N(this.isHorizontal() ? e.maxRotation : e.minRotation),
				s = Math.cos(n),
				o = Math.sin(n),
				r = this._resolveTickFontOptions(0).size;
			return {
				w: i * s + r * o,
				h: i * o + r * s
			}
		}
		_getLabelCapacity(t) {
			const e = this.options.time,
				i = e.displayFormats,
				n = i[e.unit] || i.millisecond,
				s = this._tickFormatFunction(t, 0, Bo(this, [t], this._majorUnit), n),
				o = this._getLabelSize(s),
				r = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
			return r > 0 ? r : 1
		}
		getDataTimestamps() {
			let t, e, i = this._cache.data || [];
			if (i.length) return i;
			const n = this.getMatchingVisibleMetas();
			if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this);
			for (t = 0, e = n.length; t < e; ++t) i = i.concat(n[t].controller.getAllParsedValues(this));
			return this._cache.data = this.normalize(i)
		}
		getLabelTimestamps() {
			const t = this._cache.labels || [];
			let e, i;
			if (t.length) return t;
			const n = this.getLabels();
			for (e = 0, i = n.length; e < i; ++e) t.push(Ho(this, n[e]));
			return this._cache.labels = this._normalized ? t : this.normalize(t)
		}
		normalize(t) {
			return kt(t.sort(Fo))
		}
	}

	function Yo(t, e, i) {
		let n, s, o, r, a = 0,
			l = t.length - 1;
		i ? (e >= t[a].pos && e <= t[l].pos && ({
			lo: a,
			hi: l
		} = w(t, "pos", e)), {
			pos: n,
			time: o
		} = t[a], {
			pos: s,
			time: r
		} = t[l]) : (e >= t[a].time && e <= t[l].time && ({
			lo: a,
			hi: l
		} = w(t, "time", e)), {
			time: n,
			pos: o
		} = t[a], {
			time: s,
			pos: r
		} = t[l]);
		const h = s - n;
		return h ? o + (r - o) * (e - n) / h : o
	}
	var Vo = Object.freeze({
		__proto__: null,
		CategoryScale: class extends ss {
			static id = "category";
			static defaults = {
				ticks: {
					callback: vo
				}
			};
			constructor(t) {
				super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = []
			}
			init(i) {
				const n = this._addedLabels;
				if (n.length) {
					const i = this.getLabels();
					for (const {
						index: t,
						label: e
					}
						of n) i[t] === e && i.splice(t, 1);
					this._addedLabels = []
				}
				super.init(i)
			}
			parse(t, e) {
				if (T(t)) return null;
				const i = this.getLabels();
				return ((t, e) => null === t ? null : _(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : mo(i, t, O(e, t), this._addedLabels), i.length - 1)
			}
			determineDataLimits() {
				const {
					minDefined: t,
					maxDefined: e
				} = this.getUserBounds();
				let {
					min: i,
					max: n
				} = this.getMinMax(!0);
				"ticks" === this.options.bounds && (t || (i = 0), e || (n = this.getLabels().length - 1)), this.min = i, this.max = n
			}
			buildTicks() {
				const e = this.min,
					i = this.max,
					t = this.options.offset,
					n = [];
				let s = this.getLabels();
				s = 0 === e && i === s.length - 1 ? s : s.slice(e, i + 1), this._valueRange = Math.max(s.length - (t ? 0 : 1), 1), this._startValue = this.min - (t ? .5 : 0);
				for (let t = e; t <= i; t++) n.push({
					value: t
				});
				return n
			}
			getLabelForValue(t) {
				return vo.call(this, t)
			}
			configure() {
				super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
			}
			getPixelForValue(t) {
				return "number" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
			}
			getPixelForTick(t) {
				const e = this.ticks;
				return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
			}
			getValueForPixel(t) {
				return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
			}
			getBasePixel() {
				return this.bottom
			}
		},
		LinearScale: yo,
		LogarithmicScale: Mo,
		RadialLinearScale: No,
		TimeScale: jo,
		TimeSeriesScale: class extends jo {
			static id = "timeseries";
			static defaults = jo.defaults;
			constructor(t) {
				super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0
			}
			initOffsets() {
				const t = this._getTimestampsForTable(),
					e = this._table = this.buildLookupTable(t);
				this._minPos = Yo(e, this.min), this._tableRange = Yo(e, this.max) - this._minPos, super.initOffsets(t)
			}
			buildLookupTable(t) {
				const {
					min: e,
					max: i
				} = this, n = [], s = [];
				let o, r, a, l, h;
				for (o = 0, r = t.length; o < r; ++o) l = t[o], l >= e && l <= i && n.push(l);
				if (n.length < 2) return [{
					time: e,
					pos: 0
				}, {
					time: i,
					pos: 1
				}];
				for (o = 0, r = n.length; o < r; ++o) h = n[o + 1], a = n[o - 1], l = n[o], Math.round((h + a) / 2) !== l && s.push({
					time: l,
					pos: o / (r - 1)
				});
				return s
			}
			_getTimestampsForTable() {
				let t = this._cache.all || [];
				if (t.length) return t;
				const e = this.getDataTimestamps(),
					i = this.getLabelTimestamps();
				return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t
			}
			getDecimalForValue(t) {
				return (Yo(this._table, t) - this._minPos) / this._tableRange
			}
			getValueForPixel(t) {
				const e = this._offsets,
					i = this.getDecimalForPixel(t) / e.factor - e.end;
				return Yo(this._table, i * this._tableRange + this._minPos, !0)
			}
		}
	});
	const $o = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"],
		Uo = $o.map(t => t.replace("rgb(", "rgba(").replace(")", ", 0.5)"));

	function qo(t) {
		return $o[t % $o.length]
	}

	function Go(t) {
		return Uo[t % Uo.length]
	}

	function Ko(n) {
		let s = 0;
		return (t, e) => {
			const i = n.getDatasetMeta(e).controller;
			i instanceof $s ? s = function (t, e) {
				return t.backgroundColor = t.data.map(() => qo(e++)), e
			}(t, s) : i instanceof Us ? s = function (t, e) {
				return t.backgroundColor = t.data.map(() => Go(e++)), e
			}(t, s) : i && (s = function (t, e) {
				return t.borderColor = qo(e), t.backgroundColor = Go(e), ++e
			}(t, s))
		}
	}

	function Xo(t) {
		let e;
		for (e in t)
			if (t[e].borderColor || t[e].backgroundColor) return !0;
		return !1
	}
	var Zo = {
		id: "colors",
		defaults: {
			enabled: !0,
			forceOverride: !1
		},
		beforeLayout(t, e, i) {
			if (!i.enabled) return;
			const {
				data: {
					datasets: n
				},
				options: s
			} = t.config, {
				elements: o
			} = s;
			if (!i.forceOverride && (Xo(n) || (r = s) && (r.borderColor || r.backgroundColor) || o && Xo(o))) return;
			var r;
			const a = Ko(t);
			n.forEach(a)
		}
	};

	function Qo(e) {
		if (e._decimated) {
			const t = e._data;
			delete e._decimated, delete e._data, Object.defineProperty(e, "data", {
				configurable: !0,
				enumerable: !0,
				writable: !0,
				value: t
			})
		}
	}

	function Jo(t) {
		t.data.datasets.forEach(t => {
			Qo(t)
		})
	}
	var tr = {
		id: "decimation",
		defaults: {
			algorithm: "min-max",
			enabled: !1
		},
		beforeElementsUpdate: (c, t, u) => {
			if (!u.enabled) return void Jo(c);
			const d = c.width;
			c.data.datasets.forEach((t, e) => {
				const {
					_data: i,
					indexAxis: n
				} = t, s = c.getDatasetMeta(e), o = i || t.data;
				if ("y" === Ai([n, c.options.indexAxis])) return;
				if (!s.controller.supportsDecimation) return;
				const r = c.scales[s.xAxisID];
				if ("linear" !== r.type && "time" !== r.type) return;
				if (c.options.parsing) return;
				let {
					start: a,
					count: l
				} = function (t, e) {
					const i = e.length;
					let n, s = 0;
					const {
						iScale: o
					} = t, {
						min: r,
						max: a,
						minDefined: l,
						maxDefined: h
					} = o.getUserBounds();
					return l && (s = _(w(e, o.axis, r).lo, 0, i - 1)), n = h ? _(w(e, o.axis, a).hi + 1, s, i) - s : i - s, {
						start: s,
						count: n
					}
				}(s, o);
				if (l <= (u.threshold || 4 * d)) return void Qo(t);
				let h;
				switch (T(i) && (t._data = o, delete t.data, Object.defineProperty(t, "data", {
					configurable: !0,
					enumerable: !0,
					get: function () {
						return this._decimated
					},
					set: function (t) {
						this._data = t
					}
				})), u.algorithm) {
					case "lttb":
						h = function (h, c, u, t, e) {
							const i = e.samples || t;
							if (i >= u) return h.slice(c, c + u);
							const d = [],
								f = (u - 2) / (i - 2);
							let p = 0;
							const g = c + u - 1;
							let m, v, b, _, y, x = c;
							for (d[p++] = h[x], m = 0; m < i - 2; m++) {
								let t, e = 0,
									i = 0;
								const g = Math.floor((m + 1) * f) + 1 + c,
									n = Math.min(Math.floor((m + 2) * f) + 1, u) + c,
									s = n - g;
								for (t = g; t < n; t++) e += h[t].x, i += h[t].y;
								e /= s, i /= s;
								const o = Math.floor(m * f) + 1 + c,
									r = Math.min(Math.floor((m + 1) * f) + 1, u) + c,
									{
										x: a,
										y: l
									} = h[x];
								for (b = _ = -1, t = o; t < r; t++) _ = .5 * Math.abs((a - e) * (h[t].y - l) - (a - h[t].x) * (i - l)), _ > b && (b = _, v = h[t], y = t);
								d[p++] = v, x = y
							}
							return d[p++] = h[g], d
						}(o, a, l, d, u);
						break;
					case "min-max":
						h = function (t, e, i, n) {
							let s, o, r, a, l, h, c, u, d, f, p = 0,
								g = 0;
							const m = [],
								v = e + i - 1,
								b = t[e].x,
								_ = t[v].x - b;
							for (s = e; s < e + i; ++s) {
								o = t[s], r = (o.x - b) / _ * n, a = o.y;
								const e = 0 | r;
								if (e === l) a < d ? (d = a, h = s) : a > f && (f = a, c = s), p = (g * p + o.x) / ++g;
								else {
									const i = s - 1;
									if (!T(h) && !T(c)) {
										const e = Math.min(h, c),
											T = Math.max(h, c);
										e !== u && e !== i && m.push({
											...t[e], x: p
										}), T !== u && T !== i && m.push({
											...t[T], x: p
										})
									}
									s > 0 && i !== u && m.push(t[i]), m.push(o), l = e, g = 0, d = f = a, h = c = u = s
								}
							}
							return m
						}(o, a, l, d);
						break;
					default:
						throw new Error(`Unsupported decimation algorithm'${u.algorithm}'`)
				}
				t._decimated = h
			})
		},
		destroy(t) {
			Jo(t)
		}
	};

	function er(t, e, i, n) {
		if (n) return;
		let s = e[t],
			o = i[t];
		return "angle" === t && (s = b(s), o = b(o)), {
			property: t,
			start: s,
			end: o
		}
	}

	function ir(t, e, i) {
		for (; e > t; e--) {
			const t = i[e];
			if (!isNaN(t.x) && !isNaN(t.y)) break
		}
		return e
	}

	function nr(t, e, i, n) {
		return t && e ? n(t[i], e[i]) : t ? t[i] : e ? e[i] : 0
	}

	function sr(t, e) {
		let i = [],
			n = !1;
		return I(t) ? (n = !0, i = t) : i = function (t, e) {
			const {
				x: s = null,
				y: o = null
			} = t || {}, r = e.points, a = [];
			return e.segments.forEach(({
				start: t,
				end: e
			}) => {
				e = ir(t, e, r);
				const i = r[t],
					n = r[e];
				null !== o ? (a.push({
					x: i.x,
					y: o
				}), a.push({
					x: n.x,
					y: o
				})) : null !== s && (a.push({
					x: s,
					y: i.y
				}), a.push({
					x: s,
					y: n.y
				}))
			}), a
		}(t, e), i.length ? new ro({
			points: i,
			options: {
				tension: 0
			},
			_loop: n,
			_fullLoop: n
		}) : null
	}

	function or(t) {
		return t && !1 !== t.fill
	}

	function rr(t, e, i) {
		let n = t[e].fill;
		const s = [e];
		let o;
		if (!i) return n;
		for (; !1 !== n && -1 === s.indexOf(n);) {
			if (!p(n)) return n;
			if (o = t[n], !o) return !1;
			if (o.visible) return n;
			s.push(n), n = o.fill
		}
		return !1
	}

	function ar(t, e, i) {
		const n = function (t) {
			const e = t.options,
				i = e.fill;
			let n = O(i && i.target, i);
			void 0 === n && (n = !!e.backgroundColor);
			if (!1 === n || null === n) return !1;
			if (!0 === n) return "origin";
			return n
		}(t);
		if (E(n)) return !isNaN(n.value) && n;
		let s = parseFloat(n);
		return p(s) && Math.floor(s) === s ? function (t, e, i, n) {
			"-" !== t && "+" !== t || (i = e + i);
			if (i === e || i < 0 || i >= n) return !1;
			return i
		}(n[0], e, s, i) : ["origin", "start", "end", "stack", "shape"].indexOf(n) >= 0 && n
	}

	function lr(o, r, a) {
		const l = [];
		for (let s = 0; s < a.length; s++) {
			const t = a[s],
				{
					first: e,
					last: i,
					point: n
				} = hr(t, r, "x");
			if (!(!n || e && i))
				if (e) l.unshift(n);
				else if (o.push(n), !i) break
		}
		o.push(...l)
	}

	function hr(t, i, n) {
		const s = t.interpolate(i, n);
		if (!s) return {};
		const o = s[n],
			r = t.segments,
			a = t.points;
		let l = !1,
			h = !1;
		for (let e = 0; e < r.length; e++) {
			const i = r[e],
				s = a[i.start][n],
				t = a[i.end][n];
			if (x(o, s, t)) {
				l = o === s, h = o === t;
				break
			}
		}
		return {
			first: l,
			last: h,
			point: s
		}
	}
	class cr {
		constructor(t) {
			this.x = t.x, this.y = t.y, this.radius = t.radius
		}
		pathSegment(t, e, i) {
			const {
				x: n,
				y: s,
				radius: o
			} = this;
			return e = e || {
				start: 0,
				end: y
			}, t.arc(n, s, o, e.end, e.start, !0), !i.bounds
		}
		interpolate(t) {
			const {
				x: e,
				y: i,
				radius: n
			} = this, s = t.angle;
			return {
				x: e + Math.cos(s) * n,
				y: i + Math.sin(s) * n,
				angle: s
			}
		}
	}

	function ur(t) {
		const {
			chart: e,
			fill: i,
			line: n
		} = t;
		if (p(i)) return function (t, e) {
			const i = t.getDatasetMeta(e),
				n = i && t.isDatasetVisible(e);
			return n ? i.dataset : null
		}(e, i);
		if ("stack" === i) return function (t) {
			const {
				scale: e,
				index: i,
				line: n
			} = t, s = [], o = n.segments, r = n.points, a = function (t, i) {
				const n = [],
					s = t.getMatchingVisibleMetas("line");
				for (let e = 0; e < s.length; e++) {
					const t = s[e];
					if (t.index === i) break;
					t.hidden || n.unshift(t.dataset)
				}
				return n
			}(e, i);
			a.push(sr({
				x: null,
				y: e.bottom
			}, n));
			for (let t = 0; t < o.length; t++) {
				const e = o[t];
				for (let t = e.start; t <= e.end; t++) lr(s, r[t], a)
			}
			return new ro({
				points: s,
				options: {}
			})
		}(t);
		if ("shape" === i) return !0;
		const s = function (t) {
			const e = t.scale || {};
			if (e.getPointPositionForValue) return function (t) {
				const {
					scale: e,
					fill: i
				} = t, n = e.options, s = e.getLabels().length, o = n.reverse ? e.max : e.min, r = function (t, e, i) {
					let n;
					return n = "start" === t ? i : "end" === t ? e.options.reverse ? e.min : e.max : E(t) ? t.value : e.getBaseValue(), n
				}(i, e, o), a = [];
				if (n.grid.circular) {
					const t = e.getPointPositionForValue(0, o);
					return new cr({
						x: t.x,
						y: t.y,
						radius: e.getDistanceFromCenterForValue(r)
					})
				}
				for (let t = 0; t < s; ++t) a.push(e.getPointPositionForValue(t, r));
				return a
			}(t);
			return function (t) {
				const {
					scale: e = {},
					fill: i
				} = t, n = function (t, e) {
					let i = null;
					return "start" === t ? i = e.bottom : "end" === t ? i = e.top : E(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i
				}(i, e);
				if (p(n)) {
					const t = e.isHorizontal();
					return {
						x: t ? n : null,
						y: t ? null : n
					}
				}
				return null
			}(t)
		}(t);
		return s instanceof cr ? s : sr(s, n)
	}

	function dr(t, e, i) {
		const n = ur(e),
			{
				line: s,
				scale: o,
				axis: r
			} = e,
			a = s.options,
			l = a.fill,
			h = a.backgroundColor,
			{
				above: c = h,
				below: u = h
			} = l || {};
		n && s.points.length && (Ve(t, i), function (t, e) {
			const {
				line: i,
				target: n,
				above: s,
				below: o,
				area: r,
				scale: a
			} = e, l = i._loop ? "angle" : e.axis;
			t.save(), "x" === l && o !== s && (fr(t, n, r.top), pr(t, {
				line: i,
				target: n,
				color: s,
				scale: a,
				property: l
			}), t.restore(), t.save(), fr(t, n, r.bottom));
			pr(t, {
				line: i,
				target: n,
				color: o,
				scale: a,
				property: l
			}), t.restore()
		}(t, {
			line: s,
			target: n,
			above: c,
			below: u,
			area: i,
			scale: o,
			axis: r
		}), $e(t))
	}

	function fr(s, o, r) {
		const {
			segments: a,
			points: l
		} = o;
		let h = !0,
			c = !1;
		s.beginPath();
		for (const n of a) {
			const {
				start: a,
				end: t
			} = n, e = l[a], i = l[ir(a, t, l)];
			h ? (s.moveTo(e.x, e.y), h = !1) : (s.lineTo(e.x, r), s.lineTo(e.x, e.y)), c = !!o.pathSegment(s, n, {
				move: c
			}), c ? s.closePath() : s.lineTo(i.x, r)
		}
		s.lineTo(o.first().x, r), s.closePath(), s.clip()
	}

	function pr(r, a) {
		const {
			line: l,
			target: h,
			property: c,
			color: u,
			scale: d
		} = a, f = function (s, o, r) {
			const a = s.segments,
				l = s.points,
				h = o.points,
				c = [];
			for (const s of a) {
				let {
					start: t,
					end: e
				} = s;
				e = ir(t, e, l);
				const i = er(r, l[t], l[e], s.loop);
				if (!o.segments) {
					c.push({
						source: s,
						target: i,
						start: l[t],
						end: l[e]
					});
					continue
				}
				const n = ji(o, i);
				for (const o of n) {
					const a = er(r, h[o.start], h[o.end], o.loop),
						t = Bi(s, l, a);
					for (const s of t) c.push({
						source: s,
						target: o,
						start: {
							[r]: nr(i, a, "start", Math.max)
						},
						end: {
							[r]: nr(i, a, "end", Math.min)
						}
					})
				}
			}
			return c
		}(l, h, c);
		for (const {
			source: a,
			target: n,
			start: s,
			end: o
		}
			of f) {
			const {
				style: {
					backgroundColor: f = u
				} = {}
			} = a, t = !0 !== h;
			r.save(), r.fillStyle = f, gr(r, d, t && er(c, s, o)), r.beginPath();
			const e = !!l.pathSegment(r, a);
			let i;
			if (t) {
				e ? r.closePath() : mr(r, h, o, c);
				const a = !!h.pathSegment(r, n, {
					move: e,
					reverse: !0
				});
				i = e && a, i || mr(r, h, s, c)
			}
			r.closePath(), r.fill(i ? "evenodd" : "nonzero"), r.restore()
		}
	}

	function gr(t, e, i) {
		const {
			top: n,
			bottom: s
		} = e.chart.chartArea, {
			property: o,
			start: r,
			end: a
		} = i || {};
		"x" === o && (t.beginPath(), t.rect(r, n, a - r, s - n), t.clip())
	}

	function mr(t, e, i, n) {
		const s = e.interpolate(i, n);
		s && t.lineTo(s.x, s.y)
	}
	var vr = {
		id: "filler",
		afterDatasetsUpdate(t, e, i) {
			const n = (t.data.datasets || []).length,
				s = [];
			let o, r, a, l;
			for (r = 0; r < n; ++r) o = t.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof ro && (l = {
				visible: t.isDatasetVisible(r),
				index: r,
				fill: ar(a, r, n),
				chart: t,
				axis: o.controller.options.indexAxis,
				scale: o.vScale,
				line: a
			}), o.$filler = l, s.push(l);
			for (r = 0; r < n; ++r) l = s[r], l && !1 !== l.fill && (l.fill = rr(s, r, i.propagate))
		},
		beforeDraw(e, t, i) {
			const n = "beforeDraw" === i.drawTime,
				s = e.getSortedVisibleDatasetMetas(),
				o = e.chartArea;
			for (let t = s.length - 1; t >= 0; --t) {
				const i = s[t].$filler;
				i && (i.line.updateControlPoints(o, i.axis), n && i.fill && dr(e.ctx, i, o))
			}
		},
		beforeDatasetsDraw(e, t, i) {
			if ("beforeDatasetsDraw" !== i.drawTime) return;
			const n = e.getSortedVisibleDatasetMetas();
			for (let t = n.length - 1; t >= 0; --t) {
				const i = n[t].$filler;
				or(i) && dr(e.ctx, i, e.chartArea)
			}
		},
		beforeDatasetDraw(t, e, i) {
			const n = e.meta.$filler;
			or(n) && "beforeDatasetDraw" === i.drawTime && dr(t.ctx, n, t.chartArea)
		},
		defaults: {
			propagate: !0,
			drawTime: "beforeDatasetDraw"
		}
	};
	const br = (t, e) => {
		let {
			boxHeight: i = e,
			boxWidth: n = e
		} = t;
		return t.usePointStyle && (i = Math.min(i, e), n = t.pointStyleWidth || Math.min(n, e)), {
			boxWidth: n,
			boxHeight: i,
			itemHeight: Math.max(e, i)
		}
	};
	class _r extends e {
		constructor(t) {
			super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
		}
		update(t, e, i) {
			this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit()
		}
		setDimensions() {
			this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height)
		}
		buildLabels() {
			const i = this.options.labels || {};
			let t = f(i.generateLabels, [this.chart], this) || [];
			i.filter && (t = t.filter(t => i.filter(t, this.chart.data))), i.sort && (t = t.sort((t, e) => i.sort(t, e, this.chart.data))), this.options.reverse && t.reverse(), this.legendItems = t
		}
		fit() {
			const {
				options: t,
				ctx: e
			} = this;
			if (!t.display) return void (this.width = this.height = 0);
			const i = t.labels,
				n = P(i.font),
				s = n.size,
				o = this._computeTitleHeight(),
				{
					boxWidth: r,
					itemHeight: a
				} = br(i, s);
			let l, h;
			e.font = n.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, s, r, a) + 10) : (h = this.maxHeight, l = this._fitCols(o, n, r, a) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight)
		}
		_fitRows(t, n, s, o) {
			const {
				ctx: r,
				maxWidth: a,
				options: {
					labels: {
						padding: l
					}
				}
			} = this, h = this.legendHitBoxes = [], c = this.lineWidths = [0], u = o + l;
			let d = t;
			r.textAlign = "left", r.textBaseline = "middle";
			let f = -1,
				p = -u;
			return this.legendItems.forEach((t, e) => {
				const i = s + n / 2 + r.measureText(t.text).width;
				(0 === e || c[c.length - 1] + i + 2 * l > a) && (d += u, c[c.length - (e > 0 ? 0 : 1)] = 0, p += u, f++), h[e] = {
					left: 0,
					top: p,
					row: f,
					width: i,
					height: o
				}, c[c.length - 1] += i + l
			}), d
		}
		_fitCols(t, s, o, r) {
			const {
				ctx: a,
				maxHeight: e,
				options: {
					labels: {
						padding: l
					}
				}
			} = this, h = this.legendHitBoxes = [], c = this.columnSizes = [], u = e - t;
			let d = l,
				f = 0,
				p = 0,
				g = 0,
				m = 0;
			return this.legendItems.forEach((t, e) => {
				const {
					itemWidth: i,
					itemHeight: n
				} = function (t, e, i, n, s) {
					const o = function (t, e, i, n) {
						let s = t.text;
						s && "string" != typeof s && (s = s.reduce((t, e) => t.length > e.length ? t : e));
						return e + i.size / 2 + n.measureText(s).width
					}(n, t, e, i),
						r = function (t, e, i) {
							let n = t;
							"string" != typeof e.text && (n = yr(e, i));
							return n
						}(s, n, e.lineHeight);
					return {
						itemWidth: o,
						itemHeight: r
					}
				}(o, s, a, t, r);
				e > 0 && p + n + 2 * l > u && (d += f + l, c.push({
					width: f,
					height: p
				}), g += f + l, m++, f = p = 0), h[e] = {
					left: g,
					top: p,
					col: m,
					width: i,
					height: n
				}, f = Math.max(f, i), p += n + l
			}), d += f, c.push({
				width: f,
				height: p
			}), d
		}
		adjustHitBoxes() {
			if (!this.options.display) return;
			const n = this._computeTitleHeight(),
				{
					legendHitBoxes: s,
					options: {
						align: o,
						labels: {
							padding: r
						},
						rtl: t
					}
				} = this,
				a = Ri(t, this.left, this.width);
			if (this.isHorizontal()) {
				let e = 0,
					i = M(o, this.left + r, this.right - this.lineWidths[e]);
				for (const t of s) e !== t.row && (e = t.row, i = M(o, this.left + r, this.right - this.lineWidths[e])), t.top += this.top + n + r, t.left = a.leftForLtr(a.x(i), t.width), i += t.width + r
			} else {
				let e = 0,
					i = M(o, this.top + n + r, this.bottom - this.columnSizes[e].height);
				for (const t of s) t.col !== e && (e = t.col, i = M(o, this.top + n + r, this.bottom - this.columnSizes[e].height)), t.top = i, t.left += this.left + r, t.left = a.leftForLtr(a.x(t.left), t.width), i += t.height + r
			}
		}
		isHorizontal() {
			return "top" === this.options.position || "bottom" === this.options.position
		}
		draw() {
			if (this.options.display) {
				const t = this.ctx;
				Ve(t, this), this._draw(), $e(t)
			}
		}
		_draw() {
			const {
				options: a,
				columnSizes: l,
				lineWidths: h,
				ctx: c
			} = this, {
				align: u,
				labels: d
			} = a, f = S.color, p = Ri(a.rtl, this.left, this.width), g = P(d.font), {
				padding: m
			} = d, v = g.size, b = v / 2;
			let _;
			this.drawTitle(), c.textAlign = p.textAlign("left"), c.textBaseline = "middle", c.lineWidth = .5, c.font = g.string;
			const {
				boxWidth: y,
				boxHeight: x,
				itemHeight: w
			} = br(d, v), k = this.isHorizontal(), C = this._computeTitleHeight();
			_ = k ? {
				x: M(u, this.left + m, this.right - h[0]),
				y: this.top + m + C,
				line: 0
			} : {
				x: this.left + m,
				y: M(u, this.top + C + m, this.bottom - l[0].height),
				line: 0
			}, Fi(this.ctx, a.textDirection);
			const D = w + m;
			this.legendItems.forEach((t, e) => {
				c.strokeStyle = t.fontColor, c.fillStyle = t.fontColor;
				const i = c.measureText(t.text).width,
					n = p.textAlign(t.textAlign || (t.textAlign = d.textAlign)),
					s = y + b + i;
				let o = _.x,
					r = _.y;
				p.setWidth(this.width), k ? e > 0 && o + s + m > this.right && (r = _.y += D, _.line++, o = _.x = M(u, this.left + m, this.right - h[_.line])) : e > 0 && r + D > this.bottom && (o = _.x = o + l[_.line].width + m, _.line++, r = _.y = M(u, this.top + C + m, this.bottom - l[_.line].height));
				if (function (t, e, i) {
					if (isNaN(y) || y <= 0 || isNaN(x) || x < 0) return;
					c.save();
					const n = O(i.lineWidth, 1);
					if (c.fillStyle = O(i.fillStyle, f), c.lineCap = O(i.lineCap, "butt"), c.lineDashOffset = O(i.lineDashOffset, 0), c.lineJoin = O(i.lineJoin, "miter"), c.lineWidth = n, c.strokeStyle = O(i.strokeStyle, f), c.setLineDash(O(i.lineDash, [])), d.usePointStyle) {
						const f = {
							radius: x * Math.SQRT2 / 2,
							pointStyle: i.pointStyle,
							rotation: i.rotation,
							borderWidth: n
						},
							O = p.xPlus(t, y / 2);
						Ye(c, f, O, e + b, d.pointStyleWidth && y)
					} else {
						const d = e + Math.max((v - x) / 2, 0),
							f = p.leftForLtr(t, y),
							O = Oi(i.borderRadius);
						c.beginPath(), Object.values(O).some(t => 0 !== t) ? Ze(c, {
							x: f,
							y: d,
							w: y,
							h: x,
							radius: O
						}) : c.rect(f, d, y, x), c.fill(), 0 !== n && c.stroke()
					}
					c.restore()
				}(p.x(o), r, t), o = St(n, o + y + b, k ? o + s : this.right, a.rtl), function (t, e, i) {
					Xe(c, i.text, t, e + w / 2, g, {
						strikethrough: i.hidden,
						textAlign: p.textAlign(i.textAlign)
					})
				}(p.x(o), r, t), k) _.x += s + m;
				else if ("string" != typeof t.text) {
					const a = g.lineHeight;
					_.y += yr(t, a)
				} else _.y += D
			}), Hi(this.ctx, a.textDirection)
		}
		drawTitle() {
			const t = this.options,
				e = t.title,
				i = P(e.font),
				n = R(e.padding);
			if (!e.display) return;
			const s = Ri(t.rtl, this.left, this.width),
				o = this.ctx,
				r = e.position,
				a = i.size / 2,
				l = n.top + a;
			let h, c = this.left,
				u = this.width;
			if (this.isHorizontal()) u = Math.max(...this.lineWidths), h = this.top + l, c = M(t.align, c, this.right - u);
			else {
				const e = this.columnSizes.reduce((t, e) => Math.max(t, e.height), 0);
				h = l + M(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight())
			}
			const d = M(r, c, c + u);
			o.textAlign = s.textAlign(Tt(r)), o.textBaseline = "middle", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Xe(o, e.text, d, h, i)
		}
		_computeTitleHeight() {
			const t = this.options.title,
				e = P(t.font),
				i = R(t.padding);
			return t.display ? e.lineHeight + i.height : 0
		}
		_getLegendItemAt(t, e) {
			let i, n, s;
			if (x(t, this.left, this.right) && x(e, this.top, this.bottom))
				for (s = this.legendHitBoxes, i = 0; i < s.length; ++i)
					if (n = s[i], x(t, n.left, n.left + n.width) && x(e, n.top, n.top + n.height)) return this.legendItems[i];
			return null
		}
		handleEvent(i) {
			const n = this.options;
			if (! function (t, e) {
				if (("mousemove" === t || "mouseout" === t) && (e.onHover || e.onLeave)) return !0;
				if (e.onClick && ("click" === t || "mouseup" === t)) return !0;
				return !1
			}(i.type, n)) return;
			const s = this._getLegendItemAt(i.x, i.y);
			if ("mousemove" === i.type || "mouseout" === i.type) {
				const t = this._hoveredItem,
					e = (r = s, null !== (o = t) && null !== r && o.datasetIndex === r.datasetIndex && o.index === r.index);
				t && !e && f(n.onLeave, [i, t, this], this), this._hoveredItem = s, s && !e && f(n.onHover, [i, s, this], this)
			} else s && f(n.onClick, [i, s, this], this);
			var o, r
		}
	}

	function yr(t, e) {
		return e * (t.text ? t.text.length + .5 : 0)
	}
	var xr = {
		id: "legend",
		_element: _r,
		start(t, e, i) {
			const n = t.legend = new _r({
				ctx: t.ctx,
				options: i,
				chart: t
			});
			s.configure(t, n, i), s.addBox(t, n)
		},
		stop(t) {
			s.removeBox(t, t.legend), delete t.legend
		},
		beforeUpdate(t, e, i) {
			const n = t.legend;
			s.configure(t, n, i), n.options = i
		},
		afterUpdate(t) {
			const e = t.legend;
			e.buildLabels(), e.adjustHitBoxes()
		},
		afterEvent(t, e) {
			e.replay || t.legend.handleEvent(e.event)
		},
		defaults: {
			display: !0,
			position: "top",
			align: "center",
			fullSize: !0,
			reverse: !1,
			weight: 1e3,
			onClick(t, e, i) {
				const n = e.datasetIndex,
					s = i.chart;
				s.isDatasetVisible(n) ? (s.hide(n), e.hidden = !0) : (s.show(n), e.hidden = !1)
			},
			onHover: null,
			onLeave: null,
			labels: {
				color: t => t.chart.options.color,
				boxWidth: 40,
				padding: 10,
				generateLabels(t) {
					const n = t.data.datasets,
						{
							labels: {
								usePointStyle: s,
								pointStyle: o,
								textAlign: r,
								color: a,
								useBorderRadius: l,
								borderRadius: h
							}
						} = t.legend.options;
					return t._getSortedDatasetMetas().map(t => {
						const e = t.controller.getStyle(s ? 0 : void 0),
							i = R(e.borderWidth);
						return {
							text: n[t.index].label,
							fillStyle: e.backgroundColor,
							fontColor: a,
							hidden: !t.visible,
							lineCap: e.borderCapStyle,
							lineDash: e.borderDash,
							lineDashOffset: e.borderDashOffset,
							lineJoin: e.borderJoinStyle,
							lineWidth: (i.width + i.height) / 4,
							strokeStyle: e.borderColor,
							pointStyle: o || e.pointStyle,
							rotation: e.rotation,
							textAlign: r || e.textAlign,
							borderRadius: l && (h || e.borderRadius),
							datasetIndex: t.index
						}
					}, this)
				}
			},
			title: {
				color: t => t.chart.options.color,
				display: !1,
				position: "center",
				text: ""
			}
		},
		descriptors: {
			_scriptable: t => !t.startsWith("on"),
			labels: {
				_scriptable: t => !["generateLabels", "filter", "sort"].includes(t)
			}
		}
	};
	class wr extends e {
		constructor(t) {
			super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
		}
		update(t, e) {
			const i = this.options;
			if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0);
			this.width = this.right = t, this.height = this.bottom = e;
			const n = I(i.text) ? i.text.length : 1;
			this._padding = R(i.padding);
			const s = n * P(i.font).lineHeight + this._padding.height;
			this.isHorizontal() ? this.height = s : this.width = s
		}
		isHorizontal() {
			const t = this.options.position;
			return "top" === t || "bottom" === t
		}
		_drawArgs(t) {
			const {
				top: e,
				left: i,
				bottom: n,
				right: s,
				options: o
			} = this, r = o.align;
			let a, l, h, c = 0;
			return this.isHorizontal() ? (l = M(r, i, s), h = e + t, a = s - i) : ("left" === o.position ? (l = i + t, h = M(r, n, e), c = -.5 * A) : (l = s - t, h = M(r, e, n), c = .5 * A), a = n - e), {
				titleX: l,
				titleY: h,
				maxWidth: a,
				rotation: c
			}
		}
		draw() {
			const t = this.ctx,
				e = this.options;
			if (!e.display) return;
			const i = P(e.font),
				n = i.lineHeight / 2 + this._padding.top,
				{
					titleX: s,
					titleY: o,
					maxWidth: r,
					rotation: a
				} = this._drawArgs(n);
			Xe(t, e.text, 0, 0, i, {
				color: e.color,
				maxWidth: r,
				rotation: a,
				textAlign: Tt(e.align),
				textBaseline: "middle",
				translation: [s, o]
			})
		}
	}
	var kr = {
		id: "title",
		_element: wr,
		start(t, e, i) {
			! function (t, e) {
				const i = new wr({
					ctx: t.ctx,
					options: e,
					chart: t
				});
				s.configure(t, i, e), s.addBox(t, i), t.titleBlock = i
			}(t, i)
		},
		stop(t) {
			const e = t.titleBlock;
			s.removeBox(t, e), delete t.titleBlock
		},
		beforeUpdate(t, e, i) {
			const n = t.titleBlock;
			s.configure(t, n, i), n.options = i
		},
		defaults: {
			align: "center",
			display: !1,
			font: {
				weight: "bold"
			},
			fullSize: !0,
			padding: 10,
			position: "top",
			text: "",
			weight: 2e3
		},
		defaultRoutes: {
			color: "color"
		},
		descriptors: {
			_scriptable: !0,
			_indexable: !1
		}
	};
	const Cr = new WeakMap;
	var Dr = {
		id: "subtitle",
		start(t, e, i) {
			const n = new wr({
				ctx: t.ctx,
				options: i,
				chart: t
			});
			s.configure(t, n, i), s.addBox(t, n), Cr.set(t, n)
		},
		stop(t) {
			s.removeBox(t, Cr.get(t)), Cr.delete(t)
		},
		beforeUpdate(t, e, i) {
			const n = Cr.get(t);
			s.configure(t, n, i), n.options = i
		},
		defaults: {
			align: "center",
			display: !1,
			font: {
				weight: "normal"
			},
			fullSize: !0,
			padding: 0,
			position: "top",
			text: "",
			weight: 1500
		},
		defaultRoutes: {
			color: "color"
		},
		descriptors: {
			_scriptable: !0,
			_indexable: !1
		}
	};
	const Mr = {
		average(t) {
			if (!t.length) return !1;
			let e, i, n = 0,
				s = 0,
				o = 0;
			for (e = 0, i = t.length; e < i; ++e) {
				const i = t[e].element;
				if (i && i.hasValue()) {
					const t = i.tooltipPosition();
					n += t.x, s += t.y, ++o
				}
			}
			return {
				x: n / o,
				y: s / o
			}
		}, nearest(t, e) {
			if (!t.length) return !1;
			let i, n, s, o = e.x,
				r = e.y,
				a = Number.POSITIVE_INFINITY;
			for (i = 0, n = t.length; i < n; ++i) {
				const n = t[i].element;
				if (n && n.hasValue()) {
					const t = ft(e, n.getCenterPoint());
					t < a && (a = t, s = n)
				}
			}
			if (s) {
				const t = s.tooltipPosition();
				o = t.x, r = t.y
			}
			return {
				x: o,
				y: r
			}
		}
	};

	function D(t, e) {
		return e && (I(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
	}

	function Tr(t) {
		return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t
	}

	function Sr(t, e) {
		const {
			element: i,
			datasetIndex: n,
			index: s
		} = e, o = t.getDatasetMeta(n).controller, {
			label: r,
			value: a
		} = o.getLabelAndValue(s);
		return {
			chart: t,
			label: r,
			parsed: o.getParsed(s),
			raw: t.data.datasets[n].data[s],
			formattedValue: a,
			dataset: o.getDataset(),
			dataIndex: s,
			datasetIndex: n,
			element: i
		}
	}

	function Pr(t, e) {
		const i = t.chart.ctx,
			{
				body: n,
				footer: s,
				title: o
			} = t,
			{
				boxWidth: r,
				boxHeight: a
			} = e,
			l = P(e.bodyFont),
			h = P(e.titleFont),
			c = P(e.footerFont),
			u = o.length,
			d = s.length,
			f = n.length,
			p = R(e.padding);
		let g = p.height,
			m = 0,
			v = n.reduce((t, e) => t + e.before.length + e.lines.length + e.after.length, 0);
		if (v += t.beforeBody.length + t.afterBody.length, u && (g += u * h.lineHeight + (u - 1) * e.titleSpacing + e.titleMarginBottom), v) {
			g += f * (e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight) + (v - f) * l.lineHeight + (v - 1) * e.bodySpacing
		}
		d && (g += e.footerMarginTop + d * c.lineHeight + (d - 1) * e.footerSpacing);
		let b = 0;
		const _ = function (t) {
			m = Math.max(m, i.measureText(t).width + b)
		};
		return i.save(), i.font = h.string, C(t.title, _), i.font = l.string, C(t.beforeBody.concat(t.afterBody), _), b = e.displayColors ? r + 2 + e.boxPadding : 0, C(n, t => {
			C(t.before, _), C(t.lines, _), C(t.after, _)
		}), b = 0, i.font = c.string, C(t.footer, _), i.restore(), m += p.width, {
			width: m,
			height: g
		}
	}

	function Ir(t, e, i, n) {
		const {
			x: s,
			width: o
		} = i, {
			width: r,
			chartArea: {
				left: a,
				right: l
			}
		} = t;
		let h = "center";
		return "center" === n ? h = s <= (a + l) / 2 ? "left" : "right" : s <= o / 2 ? h = "left" : s >= r - o / 2 && (h = "right"),
			function (t, e, i, n) {
				const {
					x: s,
					width: o
				} = n, r = i.caretSize + i.caretPadding;
				return "left" === t && s + o + r > e.width || "right" === t && s - o - r < 0 || void 0
			}(h, t, e, i) && (h = "center"), h
	}

	function Er(t, e, i) {
		const n = i.yAlign || e.yAlign || function (t, e) {
			const {
				y: i,
				height: n
			} = e;
			return i < n / 2 ? "top" : i > t.height - n / 2 ? "bottom" : "center"
		}(t, i);
		return {
			xAlign: i.xAlign || e.xAlign || Ir(t, e, i, n),
			yAlign: n
		}
	}

	function Or(t, e, i, n) {
		const {
			caretSize: s,
			caretPadding: o,
			cornerRadius: r
		} = t, {
			xAlign: a,
			yAlign: l
		} = i, h = s + o, {
			topLeft: c,
			topRight: u,
			bottomLeft: d,
			bottomRight: f
		} = Oi(r);
		let p = function (t, e) {
			let {
				x: i,
				width: n
			} = t;
			return "right" === e ? i -= n : "center" === e && (i -= n / 2), i
		}(e, a);
		const g = function (t, e, i) {
			let {
				y: n,
				height: s
			} = t;
			return "top" === e ? n += i : n -= "bottom" === e ? s + i : s / 2, n
		}(e, l, h);
		return "center" === l ? "left" === a ? p += h : "right" === a && (p -= h) : "left" === a ? p -= Math.max(c, d) + s : "right" === a && (p += Math.max(u, f) + s), {
			x: _(p, 0, n.width - e.width),
			y: _(g, 0, n.height - e.height)
		}
	}

	function Ar(t, e, i) {
		const n = R(i.padding);
		return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - n.right : t.x + n.left
	}

	function Lr(t) {
		return D([], Tr(t))
	}

	function Nr(t, e) {
		const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
		return i ? t.override(i) : t
	}
	const Rr = {
		beforeTitle: t,
		title(n) {
			if (n.length > 0) {
				const t = n[0],
					e = t.chart.data.labels,
					i = e ? e.length : 0;
				if (this && this.options && "dataset" === this.options.mode) return t.dataset.label || "";
				if (t.label) return t.label;
				if (i > 0 && t.dataIndex < i) return e[t.dataIndex]
			}
			return ""
		},
		afterTitle: t,
		beforeBody: t,
		beforeLabel: t,
		label(t) {
			if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue;
			let e = t.dataset.label || "";
			e && (e += ": ");
			const i = t.formattedValue;
			return T(i) || (e += i), e
		},
		labelColor(t) {
			const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
			return {
				borderColor: e.borderColor,
				backgroundColor: e.backgroundColor,
				borderWidth: e.borderWidth,
				borderDash: e.borderDash,
				borderDashOffset: e.borderDashOffset,
				borderRadius: 0
			}
		},
		labelTextColor() {
			return this.options.bodyColor
		},
		labelPointStyle(t) {
			const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
			return {
				pointStyle: e.pointStyle,
				rotation: e.rotation
			}
		},
		afterLabel: t,
		afterBody: t,
		beforeFooter: t,
		footer: t,
		afterFooter: t
	};

	function F(t, e, i, n) {
		const s = t[e].call(i, n);
		return void 0 === s ? Rr[e].call(i, n) : s
	}
	class Fr extends e {
		static positioners = Mr;
		constructor(t) {
			super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
		}
		initialize(t) {
			this.options = t, this._cachedAnimations = void 0, this.$context = void 0
		}
		_resolveAnimations() {
			const t = this._cachedAnimations;
			if (t) return t;
			const e = this.chart,
				i = this.options.setContext(this.getContext()),
				n = i.enabled && e.options.animation && i.animations,
				s = new Rn(this.chart, n);
			return n._cacheable && (this._cachedAnimations = Object.freeze(s)), s
		}
		getContext() {
			return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, Ni(t, {
				tooltip: e,
				tooltipItems: i,
				type: "tooltip"
			})));
			var t, e, i
		}
		getTitle(t, e) {
			const {
				callbacks: i
			} = e, n = F(i, "beforeTitle", this, t), s = F(i, "title", this, t), o = F(i, "afterTitle", this, t);
			let r = [];
			return r = D(r, Tr(n)), r = D(r, Tr(s)), r = D(r, Tr(o)), r
		}
		getBeforeBody(t, e) {
			return Lr(F(e.callbacks, "beforeBody", this, t))
		}
		getBody(t, e) {
			const {
				callbacks: n
			} = e, s = [];
			return C(t, t => {
				const e = {
					before: [],
					lines: [],
					after: []
				},
					i = Nr(n, t);
				D(e.before, Tr(F(i, "beforeLabel", this, t))), D(e.lines, F(i, "label", this, t)), D(e.after, Tr(F(i, "afterLabel", this, t))), s.push(e)
			}), s
		}
		getAfterBody(t, e) {
			return Lr(F(e.callbacks, "afterBody", this, t))
		}
		getFooter(t, e) {
			const {
				callbacks: i
			} = e, n = F(i, "beforeFooter", this, t), s = F(i, "footer", this, t), o = F(i, "afterFooter", this, t);
			let r = [];
			return r = D(r, Tr(n)), r = D(r, Tr(s)), r = D(r, Tr(o)), r
		}
		_createItems(n) {
			const t = this._active,
				s = this.chart.data,
				i = [],
				o = [],
				r = [];
			let e, a, l = [];
			for (e = 0, a = t.length; e < a; ++e) l.push(Sr(this.chart, t[e]));
			return n.filter && (l = l.filter((t, e, i) => n.filter(t, e, i, s))), n.itemSort && (l = l.sort((t, e) => n.itemSort(t, e, s))), C(l, t => {
				const e = Nr(n.callbacks, t);
				i.push(F(e, "labelColor", this, t)), o.push(F(e, "labelPointStyle", this, t)), r.push(F(e, "labelTextColor", this, t))
			}), this.labelColors = i, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = l, l
		}
		update(n, s) {
			const o = this.options.setContext(this.getContext()),
				r = this._active;
			let a, l = [];
			if (r.length) {
				const n = Mr[o.position].call(this, r, this._eventPosition);
				l = this._createItems(o), this.title = this.getTitle(l, o), this.beforeBody = this.getBeforeBody(l, o), this.body = this.getBody(l, o), this.afterBody = this.getAfterBody(l, o), this.footer = this.getFooter(l, o);
				const s = this._size = Pr(this, o),
					t = Object.assign({}, n, s),
					e = Er(this.chart, o, t),
					i = Or(o, t, e, this.chart);
				this.xAlign = e.xAlign, this.yAlign = e.yAlign, a = {
					opacity: 1,
					x: i.x,
					y: i.y,
					width: s.width,
					height: s.height,
					caretX: n.x,
					caretY: n.y
				}
			} else 0 !== this.opacity && (a = {
				opacity: 0
			});
			this._tooltipItems = l, this.$context = void 0, a && this._resolveAnimations().update(this, a), n && o.external && o.external.call(this, {
				chart: this.chart,
				tooltip: this,
				replay: s
			})
		}
		drawCaret(t, e, i, n) {
			const s = this.getCaretPosition(t, i, n);
			e.lineTo(s.x1, s.y1), e.lineTo(s.x2, s.y2), e.lineTo(s.x3, s.y3)
		}
		getCaretPosition(t, e, i) {
			const {
				xAlign: n,
				yAlign: s
			} = this, {
				caretSize: o,
				cornerRadius: r
			} = i, {
				topLeft: a,
				topRight: l,
				bottomLeft: h,
				bottomRight: c
			} = Oi(r), {
				x: u,
				y: d
			} = t, {
				width: f,
				height: p
			} = e;
			let g, m, v, b, _, y;
			return "center" === s ? (_ = d + p / 2, "left" === n ? (g = u, m = g - o, b = _ + o, y = _ - o) : (g = u + f, m = g + o, b = _ - o, y = _ + o), v = g) : (m = "left" === n ? u + Math.max(a, h) + o : "right" === n ? u + f - Math.max(l, c) - o : this.caretX, "top" === s ? (b = d, _ = b - o, g = m - o, v = m + o) : (b = d + p, _ = b + o, g = m + o, v = m - o), y = b), {
				x1: g,
				x2: m,
				x3: v,
				y1: b,
				y2: _,
				y3: y
			}
		}
		drawTitle(e, i, n) {
			const s = this.title,
				o = s.length;
			let r, a, l;
			if (o) {
				const t = Ri(n.rtl, this.x, this.width);
				for (e.x = Ar(this, n.titleAlign, n), i.textAlign = t.textAlign(n.titleAlign), i.textBaseline = "middle", r = P(n.titleFont), a = n.titleSpacing, i.fillStyle = n.titleColor, i.font = r.string, l = 0; l < o; ++l) i.fillText(s[l], t.x(e.x), e.y + r.lineHeight / 2), e.y += r.lineHeight + a, l + 1 === o && (e.y += n.titleMarginBottom - a)
			}
		}
		_drawColorBox(t, e, i, n, s) {
			const o = this.labelColors[i],
				r = this.labelPointStyles[i],
				{
					boxHeight: a,
					boxWidth: l
				} = s,
				h = P(s.bodyFont),
				c = Ar(this, "left", s),
				u = n.x(c),
				d = a < h.lineHeight ? (h.lineHeight - a) / 2 : 0,
				f = e.y + d;
			if (s.usePointStyle) {
				const e = {
					radius: Math.min(l, a) / 2,
					pointStyle: r.pointStyle,
					rotation: r.rotation,
					borderWidth: 1
				},
					i = n.leftForLtr(u, l) + l / 2,
					E = f + a / 2;
				t.strokeStyle = s.multiKeyBackground, t.fillStyle = s.multiKeyBackground, je(t, e, i, E), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, je(t, e, i, E)
			} else {
				t.lineWidth = E(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, t.strokeStyle = o.borderColor, t.setLineDash(o.borderDash || []), t.lineDashOffset = o.borderDashOffset || 0;
				const e = n.leftForLtr(u, l),
					i = n.leftForLtr(n.xPlus(u, 1), l - 2),
					r = Oi(o.borderRadius);
				Object.values(r).some(t => 0 !== t) ? (t.beginPath(), t.fillStyle = s.multiKeyBackground, Ze(t, {
					x: e,
					y: f,
					w: l,
					h: a,
					radius: r
				}), t.fill(), t.stroke(), t.fillStyle = o.backgroundColor, t.beginPath(), Ze(t, {
					x: i,
					y: f + 1,
					w: l - 2,
					h: a - 2,
					radius: r
				}), t.fill()) : (t.fillStyle = s.multiKeyBackground, t.fillRect(e, f, l, a), t.strokeRect(e, f, l, a), t.fillStyle = o.backgroundColor, t.fillRect(i, f + 1, l - 2, a - 2))
			}
			t.fillStyle = this.labelTextColors[i]
		}
		drawBody(e, i, t) {
			const {
				body: n
			} = this, {
				bodySpacing: s,
				bodyAlign: o,
				displayColors: r,
				boxHeight: a,
				boxWidth: l,
				boxPadding: h
			} = t, c = P(t.bodyFont);
			let u = c.lineHeight,
				d = 0;
			const f = Ri(t.rtl, this.x, this.width),
				p = function (t) {
					i.fillText(t, f.x(e.x + d), e.y + u / 2), e.y += u + s
				},
				g = f.textAlign(o);
			let m, v, b, _, y, x, w;
			for (i.textAlign = o, i.textBaseline = "middle", i.font = c.string, e.x = Ar(this, g, t), i.fillStyle = t.bodyColor, C(this.beforeBody, p), d = r && "right" !== g ? "center" === o ? l / 2 + h : l + 2 + h : 0, _ = 0, x = n.length; _ < x; ++_) {
				for (m = n[_], v = this.labelTextColors[_], i.fillStyle = v, C(m.before, p), b = m.lines, r && b.length && (this._drawColorBox(i, e, _, f, t), u = Math.max(c.lineHeight, a)), y = 0, w = b.length; y < w; ++y) p(b[y]), u = c.lineHeight;
				C(m.after, p)
			}
			d = 0, u = c.lineHeight, C(this.afterBody, p), e.y -= s
		}
		drawFooter(e, i, n) {
			const s = this.footer,
				o = s.length;
			let r, a;
			if (o) {
				const t = Ri(n.rtl, this.x, this.width);
				for (e.x = Ar(this, n.footerAlign, n), e.y += n.footerMarginTop, i.textAlign = t.textAlign(n.footerAlign), i.textBaseline = "middle", r = P(n.footerFont), i.fillStyle = n.footerColor, i.font = r.string, a = 0; a < o; ++a) i.fillText(s[a], t.x(e.x), e.y + r.lineHeight / 2), e.y += r.lineHeight + n.footerSpacing
			}
		}
		drawBackground(t, e, i, n) {
			const {
				xAlign: s,
				yAlign: o
			} = this, {
				x: r,
				y: a
			} = t, {
				width: l,
				height: h
			} = i, {
				topLeft: c,
				topRight: u,
				bottomLeft: d,
				bottomRight: f
			} = Oi(n.cornerRadius);
			e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(r + c, a), "top" === o && this.drawCaret(t, e, i, n), e.lineTo(r + l - u, a), e.quadraticCurveTo(r + l, a, r + l, a + u), "center" === o && "right" === s && this.drawCaret(t, e, i, n), e.lineTo(r + l, a + h - f), e.quadraticCurveTo(r + l, a + h, r + l - f, a + h), "bottom" === o && this.drawCaret(t, e, i, n), e.lineTo(r + d, a + h), e.quadraticCurveTo(r, a + h, r, a + h - d), "center" === o && "left" === s && this.drawCaret(t, e, i, n), e.lineTo(r, a + c), e.quadraticCurveTo(r, a, r + c, a), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke()
		}
		_updateAnimationTarget(s) {
			const o = this.chart,
				r = this.$animations,
				a = r && r.x,
				l = r && r.y;
			if (a || l) {
				const r = Mr[s.position].call(this, this._active, this._eventPosition);
				if (!r) return;
				const t = this._size = Pr(this, s),
					e = Object.assign({}, r, this._size),
					i = Er(o, s, e),
					n = Or(s, e, i, o);
				a._to === n.x && l._to === n.y || (this.xAlign = i.xAlign, this.yAlign = i.yAlign, this.width = t.width, this.height = t.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, n))
			}
		}
		_willRender() {
			return !!this.opacity
		}
		draw(t) {
			const e = this.options.setContext(this.getContext());
			let i = this.opacity;
			if (!i) return;
			this._updateAnimationTarget(e);
			const n = {
				width: this.width,
				height: this.height
			},
				s = {
					x: this.x,
					y: this.y
				};
			i = Math.abs(i) < .001 ? 0 : i;
			const o = R(e.padding),
				r = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
			e.enabled && r && (t.save(), t.globalAlpha = i, this.drawBackground(s, t, n, e), Fi(t, e.textDirection), s.y += o.top, this.drawTitle(s, t, e), this.drawBody(s, t, e), this.drawFooter(s, t, e), Hi(t, e.textDirection), t.restore())
		}
		getActiveElements() {
			return this._active || []
		}
		setActiveElements(t, e) {
			const i = this._active,
				n = t.map(({
					datasetIndex: t,
					index: e
				}) => {
					const i = this.chart.getDatasetMeta(t);
					if (!i) throw new Error("Cannot find a dataset at index " + t);
					return {
						datasetIndex: t,
						element: i.data[e],
						index: e
					}
				}),
				s = !B(i, n),
				o = this._positionChanged(n, e);
			(s || o) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0))
		}
		handleEvent(t, e, i = !0) {
			if (e && this._ignoreReplayEvents) return !1;
			this._ignoreReplayEvents = !1;
			const n = this.options,
				s = this._active || [],
				o = this._getActiveElements(t, s, e, i),
				r = this._positionChanged(o, t),
				a = e || !B(o, s) || r;
			return a && (this._active = o, (n.enabled || n.external) && (this._eventPosition = {
				x: t.x,
				y: t.y
			}, this.update(!0, e))), a
		}
		_getActiveElements(t, e, i, n) {
			const s = this.options;
			if ("mouseout" === t.type) return [];
			if (!n) return e;
			const o = this.chart.getElementsAtEventForMode(t, s.mode, s, i);
			return s.reverse && o.reverse(), o
		}
		_positionChanged(t, e) {
			const {
				caretX: i,
				caretY: n,
				options: s
			} = this, o = Mr[s.position].call(this, t, e);
			return !1 !== o && (i !== o.x || n !== o.y)
		}
	}
	var Hr = {
		id: "tooltip",
		_element: Fr,
		positioners: Mr,
		afterInit(t, e, i) {
			i && (t.tooltip = new Fr({
				chart: t,
				options: i
			}))
		},
		beforeUpdate(t, e, i) {
			t.tooltip && t.tooltip.initialize(i)
		},
		reset(t, e, i) {
			t.tooltip && t.tooltip.initialize(i)
		},
		afterDraw(e) {
			const i = e.tooltip;
			if (i && i._willRender()) {
				const t = {
					tooltip: i
				};
				if (!1 === e.notifyPlugins("beforeTooltipDraw", {
					...t, cancelable: !0
				})) return;
				i.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", t)
			}
		},
		afterEvent(e, i) {
			if (e.tooltip) {
				const t = i.replay;
				e.tooltip.handleEvent(i.event, t, i.inChartArea) && (i.changed = !0)
			}
		},
		defaults: {
			enabled: !0,
			external: null,
			position: "average",
			backgroundColor: "rgba(0,0,0,0.8)",
			titleColor: "#fff",
			titleFont: {
				weight: "bold"
			},
			titleSpacing: 2,
			titleMarginBottom: 6,
			titleAlign: "left",
			bodyColor: "#fff",
			bodySpacing: 2,
			bodyFont: {},
			bodyAlign: "left",
			footerColor: "#fff",
			footerSpacing: 2,
			footerMarginTop: 6,
			footerFont: {
				weight: "bold"
			},
			footerAlign: "left",
			padding: 6,
			caretPadding: 2,
			caretSize: 5,
			cornerRadius: 6,
			boxHeight: (t, e) => e.bodyFont.size,
			boxWidth: (t, e) => e.bodyFont.size,
			multiKeyBackground: "#fff",
			displayColors: !0,
			boxPadding: 0,
			borderColor: "rgba(0,0,0,0)",
			borderWidth: 0,
			animation: {
				duration: 400,
				easing: "easeOutQuart"
			},
			animations: {
				numbers: {
					type: "number",
					properties: ["x", "y", "width", "height", "caretX", "caretY"]
				},
				opacity: {
					easing: "linear",
					duration: 200
				}
			},
			callbacks: Rr
		},
		defaultRoutes: {
			bodyFont: "font",
			footerFont: "font",
			titleFont: "font"
		},
		descriptors: {
			_scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t,
			_indexable: !1,
			callbacks: {
				_scriptable: !1,
				_indexable: !1
			},
			animation: {
				_fallback: !1
			},
			animations: {
				_fallback: "animation"
			}
		},
		additionalOptionScopes: ["interaction"]
	};
	return i.register(qs, Vo, go, n), i.helpers = {
		...qi
	}, i._adapters = Rs, i.Animation = Nn, i.Animations = Rn, i.animator = c, i.controllers = d.controllers.items, i.DatasetController = Gn, i.Element = e, i.elements = go, i.Interaction = tn, i.layouts = s, i.platforms = On, i.Scale = ss, i.Ticks = ve, Object.assign(i, qs, Vo, go, n, On), i.Chart = i, "undefined" != typeof window && (window.Chart = i), i
});
! function (t, e) {
	"object" == typeof exports && "undefined" != typeof module ? e(require("moment"), require("chart.js")) : "function" == typeof define && define.amd ? define(["moment", "chart.js"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).moment, t.Chart)
}(this, function (t, e) {
	"use strict";

	function i(t) {
		return t && "object" == typeof t && "default" in t ? t : {
			default: t
		}
	}
	var n = i(t);
	const s = {
		datetime: "MMM D, YYYY, h:mm:ss a",
		millisecond: "h:mm:ss.SSS a",
		second: "h:mm:ss a",
		minute: "h:mm a",
		hour: "hA",
		day: "MMM D",
		week: "ll",
		month: "MMM YYYY",
		quarter: "[Q]Q - YYYY",
		year: "YYYY"
	};
	e._adapters._date.override("function" == typeof n.default ? {
		_id: "moment",
		formats: function () {
			return s
		},
		parse: function (t, e) {
			return "string" == typeof t && "string" == typeof e ? t = n.default(t, e) : t instanceof n.default || (t = n.default(t)), t.isValid() ? t.valueOf() : null
		},
		format: function (t, e) {
			return n.default(t).format(e)
		},
		add: function (t, e, i) {
			return n.default(t).add(e, i).valueOf()
		},
		diff: function (t, e, i) {
			return n.default(t).diff(n.default(e), i)
		},
		startOf: function (t, e, i) {
			return t = n.default(t), "isoWeek" === e ? (i = Math.trunc(Math.min(Math.max(0, i), 6)), t.isoWeekday(i).startOf("day").valueOf()) : t.startOf(e).valueOf()
		},
		endOf: function (t, e) {
			return n.default(t).endOf(e).valueOf()
		}
	} : {})
});
var Autocomplete = function () {
	"use strict";

	function w(t, e) {
		if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
	}

	function s(t, e) {
		for (var i = 0; i < e.length; i++) {
			var n = e[i];
			n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
		}
	}

	function k(t, e, i) {
		return e in t ? Object.defineProperty(t, e, {
			value: i,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : t[e] = i, t
	}
	var n = function (t, e) {
		return t.matches ? t.matches(e) : t.msMatchesSelector ? t.msMatchesSelector(e) : t.webkitMatchesSelector ? t.webkitMatchesSelector(e) : null
	},
		C = function (t, e) {
			return t.closest ? t.closest(e) : function (t, e) {
				for (var i = t; i && 1 === i.nodeType;) {
					if (n(i, e)) return i;
					i = i.parentNode
				}
				return null
			}(t, e)
		},
		D = function (t) {
			return Boolean(t && "function" == typeof t.then)
		},
		b = function t() {
			var s = this,
				e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
				i = e.search,
				n = e.autoSelect,
				o = void 0 !== n && n,
				r = e.setValue,
				a = void 0 === r ? function () { } : r,
				l = e.setAttribute,
				h = void 0 === l ? function () { } : l,
				c = e.onUpdate,
				u = void 0 === c ? function () { } : c,
				d = e.onSubmit,
				f = void 0 === d ? function () { } : d,
				p = e.onShow,
				g = void 0 === p ? function () { } : p,
				m = e.onHide,
				v = void 0 === m ? function () { } : m,
				b = e.onLoading,
				_ = void 0 === b ? function () { } : b,
				y = e.onLoaded,
				x = void 0 === y ? function () { } : y;
			w(this, t), k(this, "value", ""), k(this, "searchCounter", 0), k(this, "results", []), k(this, "selectedIndex", -1), k(this, "handleInput", function (t) {
				var e = t.target.value;
				s.updateResults(e), s.value = e
			}), k(this, "handleKeyDown", function (t) {
				var e = t.key;
				switch (e) {
					case "Up":
					case "Down":
					case "ArrowUp":
					case "ArrowDown":
						var i = "ArrowUp" === e || "Up" === e ? s.selectedIndex - 1 : s.selectedIndex + 1;
						t.preventDefault(), s.handleArrows(i);
						break;
					case "Tab":
						s.selectResult();
						break;
					case "Enter":
						var n = s.results[s.selectedIndex];
						s.selectResult(), s.onSubmit(n);
						break;
					case "Esc":
					case "Escape":
						s.hideResults(), s.setValue();
						break;
					default:
						return
				}
			}), k(this, "handleFocus", function (t) {
				var e = t.target.value;
				s.updateResults(e), s.value = e
			}), k(this, "handleBlur", function () {
				s.hideResults()
			}), k(this, "handleResultMouseDown", function (t) {
				t.preventDefault()
			}), k(this, "handleResultClick", function (t) {
				var e = t.target,
					i = C(e, "[data-result-index]");
				if (i) {
					s.selectedIndex = parseInt(i.dataset.resultIndex, 10);
					var n = s.results[s.selectedIndex];
					s.selectResult(), s.onSubmit(n)
				}
			}), k(this, "handleArrows", function (t) {
				var e = s.results.length;
				s.selectedIndex = (t % e + e) % e, s.onUpdate(s.results, s.selectedIndex)
			}), k(this, "selectResult", function () {
				var t = s.results[s.selectedIndex];
				t && s.setValue(t), s.hideResults()
			}), k(this, "updateResults", function (t) {
				var e = ++s.searchCounter;
				s.onLoading(), s.search(t).then(function (t) {
					e === s.searchCounter && (s.results = t, s.onLoaded(), 0 !== s.results.length ? (s.selectedIndex = s.autoSelect ? 0 : -1, s.onUpdate(s.results, s.selectedIndex), s.showResults()) : s.hideResults())
				})
			}), k(this, "showResults", function () {
				s.setAttribute("aria-expanded", !0), s.onShow()
			}), k(this, "hideResults", function () {
				s.selectedIndex = -1, s.results = [], s.setAttribute("aria-expanded", !1), s.setAttribute("aria-activedescendant", ""), s.onUpdate(s.results, s.selectedIndex), s.onHide()
			}), k(this, "checkSelectedResultVisible", function (t) {
				var e = t.querySelector('[data-result-index="'.concat(s.selectedIndex, '"]'));
				if (e) {
					var i = t.getBoundingClientRect(),
						n = e.getBoundingClientRect();
					n.top < i.top ? t.scrollTop -= i.top - n.top : n.bottom > i.bottom && (t.scrollTop += n.bottom - i.bottom)
				}
			}), this.search = D(i) ? i : function (t) {
				return Promise.resolve(i(t))
			}, this.autoSelect = o, this.setValue = a, this.setAttribute = h, this.onUpdate = u, this.onSubmit = f, this.onShow = g, this.onHide = v, this.onLoading = _, this.onLoaded = x
		},
		e = 0,
		_ = function () {
			var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
			return "".concat(t).concat(++e)
		},
		y = function (t, e) {
			var i = t.getBoundingClientRect(),
				n = e.getBoundingClientRect();
			return i.bottom + n.height > window.innerHeight && window.innerHeight - i.bottom < i.top && window.pageYOffset + i.top - n.height > 0 ? "above" : "below"
		},
		x = function (s, o, r) {
			var a;
			return function () {
				var t = this,
					e = arguments,
					i = function () {
						a = null, r || s.apply(t, e)
					},
					n = r && !a;
				clearTimeout(a), a = setTimeout(i, o), n && s.apply(t, e)
			}
		},
		M = function () {
			function n(t, e, i) {
				w(this, n), this.id = "".concat(i, "-result-").concat(t), this.class = "".concat(i, "-result"), this["data-result-index"] = t, this.role = "option", t === e && (this["aria-selected"] = "true")
			}
			var t, e, i;
			return t = n, (e = [{
				key: "toString",
				value: function () {
					var i = this;
					return Object.keys(this).reduce(function (t, e) {
						return "".concat(t, " ").concat(e, '="').concat(i[e], '"')
					}, "")
				}
			}]) && s(t.prototype, e), i && s(t, i), n
		}();
	return function t(e) {
		var o = this,
			i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
			n = i.search,
			s = i.onSubmit,
			r = void 0 === s ? function () { } : s,
			a = i.onUpdate,
			l = void 0 === a ? function () { } : a,
			h = i.baseClass,
			c = void 0 === h ? "autocomplete" : h,
			u = i.autoSelect,
			d = i.getResultValue,
			f = void 0 === d ? function (t) {
				return t
			} : d,
			p = i.renderResult,
			g = i.debounceTime,
			m = void 0 === g ? 0 : g;
		w(this, t), k(this, "expanded", !1), k(this, "loading", !1), k(this, "position", {}), k(this, "resetPosition", !0), k(this, "initialize", function () {
			o.root.style.position = "relative", o.input.setAttribute("role", "combobox"), o.input.setAttribute("autocomplete", "off"), o.input.setAttribute("autocapitalize", "off"), o.input.setAttribute("autocorrect", "off"), o.input.setAttribute("spellcheck", "false"), o.input.setAttribute("aria-autocomplete", "list"), o.input.setAttribute("aria-haspopup", "listbox"), o.input.setAttribute("aria-expanded", "false"), o.resultList.setAttribute("role", "listbox"), o.resultList.style.position = "absolute", o.resultList.style.zIndex = "1", o.resultList.style.minWidth = "100%", o.resultList.style.boxSizing = "border-box", o.resultList.id || (o.resultList.id = _("".concat(o.baseClass, "-result-list-"))), o.input.setAttribute("aria-owns", o.resultList.id), document.body.addEventListener("click", o.handleDocumentClick), o.input.addEventListener("input", o.core.handleInput), o.input.addEventListener("keydown", o.core.handleKeyDown), o.input.addEventListener("focus", o.core.handleFocus), o.input.addEventListener("blur", o.core.handleBlur), o.resultList.addEventListener("mousedown", o.core.handleResultMouseDown), o.resultList.addEventListener("click", o.core.handleResultClick), o.updateStyle()
		}), k(this, "setAttribute", function (t, e) {
			o.input.setAttribute(t, e)
		}), k(this, "setValue", function (t) {
			o.input.value = t ? o.getResultValue(t) : ""
		}), k(this, "renderResult", function (t, e) {
			return "<li ".concat(e, ">").concat(o.getResultValue(t), "</li>")
		}), k(this, "handleUpdate", function (t, s) {
			o.resultList.innerHTML = "", t.forEach(function (t, e) {
				var i = new M(e, s, o.baseClass),
					n = o.renderResult(t, i);
				"string" == typeof n ? o.resultList.insertAdjacentHTML("beforeend", n) : o.resultList.insertAdjacentElement("beforeend", n)
			}), o.input.setAttribute("aria-activedescendant", s > -1 ? "".concat(o.baseClass, "-result-").concat(s) : ""), o.resetPosition && (o.resetPosition = !1, o.position = y(o.input, o.resultList), o.updateStyle()), o.core.checkSelectedResultVisible(o.resultList), o.onUpdate(t, s)
		}), k(this, "handleShow", function () {
			o.expanded = !0, o.updateStyle()
		}), k(this, "handleHide", function () {
			o.expanded = !1, o.resetPosition = !0, o.updateStyle()
		}), k(this, "handleLoading", function () {
			o.loading = !0, o.updateStyle()
		}), k(this, "handleLoaded", function () {
			o.loading = !1, o.updateStyle()
		}), k(this, "handleDocumentClick", function (t) {
			o.root.contains(t.target) || o.core.hideResults()
		}), k(this, "updateStyle", function () {
			o.root.dataset.expanded = o.expanded, o.root.dataset.loading = o.loading, o.root.dataset.position = o.position, o.resultList.style.visibility = o.expanded ? "visible" : "hidden", o.resultList.style.pointerEvents = o.expanded ? "auto" : "none", "below" === o.position ? (o.resultList.style.bottom = null, o.resultList.style.top = "100%") : (o.resultList.style.top = null, o.resultList.style.bottom = "100%")
		}), this.root = "string" == typeof e ? document.querySelector(e) : e, this.input = this.root.querySelector("input"), this.resultList = this.root.querySelector("ul"), this.baseClass = c, this.getResultValue = f, this.onUpdate = l, "function" == typeof p && (this.renderResult = p);
		var v = new b({
			search: n,
			autoSelect: u,
			setValue: this.setValue,
			setAttribute: this.setAttribute,
			onUpdate: this.handleUpdate,
			onSubmit: r,
			onShow: this.handleShow,
			onHide: this.handleHide,
			onLoading: this.handleLoading,
			onLoaded: this.handleLoaded
		});
		m > 0 && (v.handleInput = x(v.handleInput, m)), this.core = v, this.initialize()
	}
}();
! function (t, e) {
	"object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.ClipboardJS = e() : t.ClipboardJS = e()
}(this, function () {
	return n = {}, s.m = i = [function (t, e) {
		t.exports = function (t) {
			var e;
			if ("SELECT" === t.nodeName) t.focus(), e = t.value;
			else if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) {
				var i = t.hasAttribute("readonly");
				i || t.setAttribute("readonly", ""), t.select(), t.setSelectionRange(0, t.value.length), i || t.removeAttribute("readonly"), e = t.value
			} else {
				t.hasAttribute("contenteditable") && t.focus();
				var n = window.getSelection(),
					s = document.createRange();
				s.selectNodeContents(t), n.removeAllRanges(), n.addRange(s), e = n.toString()
			}
			return e
		}
	}, function (t, e) {
		function i() { }
		i.prototype = {
			on: function (t, e, i) {
				var n = this.e || (this.e = {});
				return (n[t] || (n[t] = [])).push({
					fn: e,
					ctx: i
				}), this
			},
			once: function (t, e, i) {
				var n = this;

				function s() {
					n.off(t, s), e.apply(i, arguments)
				}
				return s._ = e, this.on(t, s, i)
			},
			emit: function (t) {
				for (var e = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[t] || []).slice(), n = 0, s = i.length; n < s; n++) i[n].fn.apply(i[n].ctx, e);
				return this
			},
			off: function (t, e) {
				var i = this.e || (this.e = {}),
					n = i[t],
					s = [];
				if (n && e)
					for (var o = 0, r = n.length; o < r; o++) n[o].fn !== e && n[o].fn._ !== e && s.push(n[o]);
				return s.length ? i[t] = s : delete i[t], this
			}
		}, t.exports = i, t.exports.TinyEmitter = i
	}, function (t, e, i) {
		var d = i(3),
			f = i(4);
		t.exports = function (t, e, i) {
			if (!t && !e && !i) throw new Error("Missing required arguments");
			if (!d.string(e)) throw new TypeError("Second argument must be a String");
			if (!d.fn(i)) throw new TypeError("Third argument must be a Function");
			if (d.node(t)) return c = e, u = i, (h = t).addEventListener(c, u), {
				destroy: function () {
					h.removeEventListener(c, u)
				}
			};
			if (d.nodeList(t)) return r = t, a = e, l = i, Array.prototype.forEach.call(r, function (t) {
				t.addEventListener(a, l)
			}), {
				destroy: function () {
					Array.prototype.forEach.call(r, function (t) {
						t.removeEventListener(a, l)
					})
				}
			};
			if (d.string(t)) return n = t, s = e, o = i, f(document.body, n, s, o);
			throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
			var n, s, o, r, a, l, h, c, u
		}
	}, function (t, i) {
		i.node = function (t) {
			return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType
		}, i.nodeList = function (t) {
			var e = Object.prototype.toString.call(t);
			return void 0 !== t && ("[object NodeList]" === e || "[object HTMLCollection]" === e) && "length" in t && (0 === t.length || i.node(t[0]))
		}, i.string = function (t) {
			return "string" == typeof t || t instanceof String
		}, i.fn = function (t) {
			return "[object Function]" === Object.prototype.toString.call(t)
		}
	}, function (t, e, i) {
		var r = i(5);

		function o(t, e, i, n, s) {
			var o = function (e, i, t, n) {
				return function (t) {
					t.delegateTarget = r(t.target, i), t.delegateTarget && n.call(e, t)
				}
			}.apply(this, arguments);
			return t.addEventListener(i, o, s), {
				destroy: function () {
					t.removeEventListener(i, o, s)
				}
			}
		}
		t.exports = function (t, e, i, n, s) {
			return "function" == typeof t.addEventListener ? o.apply(null, arguments) : "function" == typeof i ? o.bind(null, document).apply(null, arguments) : ("string" == typeof t && (t = document.querySelectorAll(t)), Array.prototype.map.call(t, function (t) {
				return o(t, e, i, n, s)
			}))
		}
	}, function (t, e) {
		if ("undefined" != typeof Element && !Element.prototype.matches) {
			var i = Element.prototype;
			i.matches = i.matchesSelector || i.mozMatchesSelector || i.msMatchesSelector || i.oMatchesSelector || i.webkitMatchesSelector
		}
		t.exports = function (t, e) {
			for (; t && 9 !== t.nodeType;) {
				if ("function" == typeof t.matches && t.matches(e)) return t;
				t = t.parentNode
			}
		}
	}, function (t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			s = i.n(n),
			o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
				return typeof t
			} : function (t) {
				return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
			};

		function r(t, e) {
			for (var i = 0; i < e.length; i++) {
				var n = e[i];
				n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
			}
		}

		function a(t) {
			! function (t, e) {
				if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
			}(this, a), this.resolveOptions(t), this.initSelection()
		}
		var l = (function (t, e, i) {
			return e && r(t.prototype, e), i && r(t, i), t
		}(a, [{
			key: "resolveOptions",
			value: function (t) {
				var e = 0 < arguments.length && void 0 !== t ? t : {};
				this.action = e.action, this.container = e.container, this.emitter = e.emitter, this.target = e.target, this.text = e.text, this.trigger = e.trigger, this.selectedText = ""
			}
		}, {
			key: "initSelection",
			value: function () {
				this.text ? this.selectFake() : this.target && this.selectTarget()
			}
		}, {
			key: "selectFake",
			value: function () {
				var t = this,
					e = "rtl" == document.documentElement.getAttribute("dir");
				this.removeFake(), this.fakeHandlerCallback = function () {
					return t.removeFake()
				}, this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || !0, this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", this.fakeElem.style.position = "absolute", this.fakeElem.style[e ? "right" : "left"] = "-9999px";
				var i = window.pageYOffset || document.documentElement.scrollTop;
				this.fakeElem.style.top = i + "px", this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, this.container.appendChild(this.fakeElem), this.selectedText = s()(this.fakeElem), this.copyText()
			}
		}, {
			key: "removeFake",
			value: function () {
				this.fakeHandler && (this.container.removeEventListener("click", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem && (this.container.removeChild(this.fakeElem), this.fakeElem = null)
			}
		}, {
			key: "selectTarget",
			value: function () {
				this.selectedText = s()(this.target), this.copyText()
			}
		}, {
			key: "copyText",
			value: function () {
				var e = void 0;
				try {
					e = document.execCommand(this.action)
				} catch (t) {
					e = !1
				}
				this.handleResult(e)
			}
		}, {
			key: "handleResult",
			value: function (t) {
				this.emitter.emit(t ? "success" : "error", {
					action: this.action,
					text: this.selectedText,
					trigger: this.trigger,
					clearSelection: this.clearSelection.bind(this)
				})
			}
		}, {
			key: "clearSelection",
			value: function () {
				this.trigger && this.trigger.focus(), document.activeElement.blur(), window.getSelection().removeAllRanges()
			}
		}, {
			key: "destroy",
			value: function () {
				this.removeFake()
			}
		}, {
			key: "action",
			set: function (t) {
				var e = 0 < arguments.length && void 0 !== t ? t : "copy";
				if (this._action = e, "copy" !== this._action && "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"')
			},
			get: function () {
				return this._action
			}
		}, {
			key: "target",
			set: function (t) {
				if (void 0 !== t) {
					if (!t || "object" !== (void 0 === t ? "undefined" : o(t)) || 1 !== t.nodeType) throw new Error('Invalid "target" value, use a valid Element');
					if ("copy" === this.action && t.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
					if ("cut" === this.action && (t.hasAttribute("readonly") || t.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
					this._target = t
				}
			},
			get: function () {
				return this._target
			}
		}]), a),
			h = i(1),
			c = i.n(h),
			u = i(2),
			d = i.n(u),
			f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
				return typeof t
			} : function (t) {
				return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
			},
			p = function (t, e, i) {
				return e && g(t.prototype, e), i && g(t, i), t
			};

		function g(t, e) {
			for (var i = 0; i < e.length; i++) {
				var n = e[i];
				n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
			}
		}
		var m = (function (t, e) {
			if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
			t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
		}(v, c.a), p(v, [{
			key: "resolveOptions",
			value: function (t) {
				var e = 0 < arguments.length && void 0 !== t ? t : {};
				this.action = "function" == typeof e.action ? e.action : this.defaultAction, this.target = "function" == typeof e.target ? e.target : this.defaultTarget, this.text = "function" == typeof e.text ? e.text : this.defaultText, this.container = "object" === f(e.container) ? e.container : document.body
			}
		}, {
			key: "listenClick",
			value: function (t) {
				var e = this;
				this.listener = d()(t, "click", function (t) {
					return e.onClick(t)
				})
			}
		}, {
			key: "onClick",
			value: function (t) {
				var e = t.delegateTarget || t.currentTarget;
				this.clipboardAction && (this.clipboardAction = null), this.clipboardAction = new l({
					action: this.action(e),
					target: this.target(e),
					text: this.text(e),
					container: this.container,
					trigger: e,
					emitter: this
				})
			}
		}, {
			key: "defaultAction",
			value: function (t) {
				return b("action", t)
			}
		}, {
			key: "defaultTarget",
			value: function (t) {
				var e = b("target", t);
				if (e) return document.querySelector(e)
			}
		}, {
			key: "defaultText",
			value: function (t) {
				return b("text", t)
			}
		}, {
			key: "destroy",
			value: function () {
				this.listener.destroy(), this.clipboardAction && (this.clipboardAction.destroy(), this.clipboardAction = null)
			}
		}], [{
			key: "isSupported",
			value: function (t) {
				var e = 0 < arguments.length && void 0 !== t ? t : ["copy", "cut"],
					i = "string" == typeof e ? [e] : e,
					n = !!document.queryCommandSupported;
				return i.forEach(function (t) {
					n = n && !!document.queryCommandSupported(t)
				}), n
			}
		}]), v);

		function v(t, e) {
			! function (t, e) {
				if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
			}(this, v);
			var i = function (t, e) {
				if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return !e || "object" != typeof e && "function" != typeof e ? t : e
			}(this, (v.__proto__ || Object.getPrototypeOf(v)).call(this));
			return i.resolveOptions(e), i.listenClick(t), i
		}

		function b(t, e) {
			var i = "data-clipboard-" + t;
			if (e.hasAttribute(i)) return e.getAttribute(i)
		}
		e.default = m
	}], s.c = n, s.d = function (t, e, i) {
		s.o(t, e) || Object.defineProperty(t, e, {
			enumerable: !0,
			get: i
		})
	}, s.r = function (t) {
		"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
			value: "Module"
		}), Object.defineProperty(t, "__esModule", {
			value: !0
		})
	}, s.t = function (e, t) {
		if (1 & t && (e = s(e)), 8 & t) return e;
		if (4 & t && "object" == typeof e && e && e.__esModule) return e;
		var i = Object.create(null);
		if (s.r(i), Object.defineProperty(i, "default", {
			enumerable: !0,
			value: e
		}), 2 & t && "string" != typeof e)
			for (var n in e) s.d(i, n, function (t) {
				return e[t]
			}.bind(null, n));
		return i
	}, s.n = function (t) {
		var e = t && t.__esModule ? function () {
			return t.default
		} : function () {
			return t
		};
		return s.d(e, "a", e), e
	}, s.o = function (t, e) {
		return Object.prototype.hasOwnProperty.call(t, e)
	}, s.p = "", s(s.s = 6).default;

	function s(t) {
		if (n[t]) return n[t].exports;
		var e = n[t] = {
			i: t,
			l: !1,
			exports: {}
		};
		return i[t].call(e.exports, e, e.exports, s), e.l = !0, e.exports
	}
	var i, n
});
